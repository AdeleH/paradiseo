<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>EO: CMAParams.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<div class="nav">
<a class="el" href="dir_000000.html">src</a>&nbsp;/&nbsp;<a class="el" href="dir_000010.html">es</a></div>
<h1>CMAParams.cpp</h1><div class="fragment"><pre class="fragment">00001 
00002 <span class="comment">/*</span>
00003 <span class="comment"> * C++ification of Nikolaus Hansen's original C-source code for the</span>
00004 <span class="comment"> * CMA-ES</span>
00005 <span class="comment"> *</span>
00006 <span class="comment"> * C++-ificiation performed by Maarten Keijzer (C) 2005. Licensed under</span>
00007 <span class="comment"> * the LGPL. Original copyright of Nikolaus Hansen can be found below</span>
00008 <span class="comment"> *</span>
00009 <span class="comment"> *</span>
00010 <span class="comment"> * </span>
00011 <span class="comment"> */</span>
00012 
00013 <span class="comment">/* --------------------------------------------------------- */</span>
00014 <span class="comment">/* --------------------------------------------------------- */</span>
00015 <span class="comment">/* --- File: cmaes.c  -------- Author: Nikolaus Hansen   --- */</span>
00016 <span class="comment">/* --------------------------------------------------------- */</span>
00017 <span class="comment">/*</span>
00018 <span class="comment"> *      CMA-ES for non-linear function minimization.</span>
00019 <span class="comment"> *</span>
00020 <span class="comment"> *           Copyright (C) 1996, 2003  Nikolaus Hansen.</span>
00021 <span class="comment"> *           e-mail: hansen@bionik.tu-berlin.de</span>
00022 <span class="comment"> *</span>
00023 <span class="comment"> *           This library is free software; you can redistribute it and/or</span>
00024 <span class="comment"> *           modify it under the terms of the GNU Lesser General Public</span>
00025 <span class="comment"> *           License as published by the Free Software Foundation; either</span>
00026 <span class="comment"> *           version 2.1 of the License, or (at your option) any later</span>
00027 <span class="comment"> *           version (see http://www.gnu.org/copyleft/lesser.html).</span>
00028 <span class="comment"> *</span>
00029 <span class="comment"> *           This library is distributed in the hope that it will be useful,</span>
00030 <span class="comment"> *           but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00031 <span class="comment"> *           MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
00032 <span class="comment"> *           Lesser General Public License for more details.</span>
00033 <span class="comment"> * </span>
00034 <span class="comment"> *                                                             */</span>
00035 <span class="comment">/* --- Changes : ---</span>
00036 <span class="comment"> *   03/03/21: argument const double *rgFunVal of</span>
00037 <span class="comment"> *   cmaes_ReestimateDistribution() was treated incorrectly.</span>
00038 <span class="comment"> *   03/03/29: restart via cmaes_resume_distribution() implemented.</span>
00039 <span class="comment"> *   03/03/30: Always max std dev / largest axis is printed first.</span>
00040 <span class="comment"> *   03/08/30: Damping is adjusted for large mueff.</span>
00041 <span class="comment"> *   03/10/30: Damping is adjusted for large mueff always.</span>
00042 <span class="comment"> *   04/04/22: Cumulation time and damping for step size adjusted.</span>
00043 <span class="comment"> *   No iniphase but conditional update of pc.</span>
00044 <span class="comment"> *   Version 2.23.</span>
00045 <span class="comment"> *                               */</span>
00046 
00047 <span class="preprocessor">#include &lt;es/CMAParams.h&gt;</span>
00048 <span class="preprocessor">#include &lt;utils/eoParser.h&gt;</span>
00049 
00050 <span class="preprocessor">#include &lt;string&gt;</span>
00051 
00052 <span class="keyword">using</span> <span class="keyword">namespace </span>std;
00053 
00054 <span class="keyword">namespace </span>eo {
00055 
00056 CMAParams::CMAParams(eoParser&amp; parser, <span class="keywordtype">unsigned</span> dimensionality) {
00057     
00058     string section = <span class="stringliteral">"CMA parameters"</span>;
00059     
00060     n = parser.createParam(dimensionality, <span class="stringliteral">"dimensionality"</span>, <span class="stringliteral">"Dimensionality (N) of the problem"</span>, <span class="charliteral">'N'</span>, section, dimensionality == 0).value();
00061     
00062     maxgen = parser.createParam(
00063             1000,
00064             <span class="stringliteral">"max-gen"</span>,
00065             <span class="stringliteral">"Maximum number of generations that the system will run (needed for damping)"</span>,
00066             <span class="charliteral">'M'</span>,
00067             section).value();
00068     
00069     
00070     <span class="keywordflow">if</span> (n == 0) {
00071         <span class="keywordflow">return</span>;
00072     }
00073     
00074     defaults(n, maxgen);
00075     
00076     <span class="comment">/* handle lambda */</span>
00077     lambda = parser.createParam(
00078             lambda,
00079             <span class="stringliteral">"lambda"</span>,
00080             <span class="stringliteral">"Number of offspring"</span>,
00081             <span class="charliteral">'l'</span>,
00082             section).value();
00083 
00084     <span class="keywordflow">if</span> (lambda &lt; 2) {
00085         lambda = 4+(int)(3*log((<span class="keywordtype">double</span>) n));
00086         cerr &lt;&lt; <span class="stringliteral">"Too small lambda specified, setting it to "</span> &lt;&lt; lambda &lt;&lt; endl;
00087     }
00088     
00089     <span class="comment">/* handle mu */</span>
00090     mu = parser.createParam(
00091             mu,
00092             <span class="stringliteral">"mu"</span>,
00093             <span class="stringliteral">"Population size"</span>,
00094             <span class="charliteral">'m'</span>,
00095             section).value();
00096 
00097     <span class="keywordflow">if</span> (mu &gt;= lambda) {
00098         mu = lambda/2;
00099         cerr &lt;&lt; <span class="stringliteral">"Mu set larger/equal to lambda, setting it to "</span> &lt;&lt; mu &lt;&lt; endl;
00100     }
00101     
00102     <span class="comment">/* handle selection weights */</span>
00103     
00104     <span class="keywordtype">int</span> weight_type = parser.createParam(
00105             0,
00106             <span class="stringliteral">"weighting"</span>,
00107             <span class="stringliteral">"Weighting scheme (for 'selection'): 0 = logarithmic, 1 = equal, 2 = linear"</span>,
00108             <span class="charliteral">'w'</span>,
00109             section).value();
00110 
00111     <span class="keywordflow">switch</span> (weight_type) {
00112         <span class="keywordflow">case</span> 1: 
00113             {
00114                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; weights.size(); ++i) {
00115                     weights[i] = mu - i;
00116                 }
00117             }
00118         <span class="keywordflow">case</span> 2:
00119             {
00120                 weights = 1.;
00121             }
00122         <span class="keywordflow">default</span> : 
00123             {
00124                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; weights.size(); ++i) {
00125                     weights[i] = log(mu+1.)-log(i+1.);
00126                 }
00127             }
00128         
00129     }
00130 
00131     <span class="comment">/* Normalize weights and set mu_eff */</span>
00132     <span class="keywordtype">double</span> sumw = weights.sum();
00133     mueff =  sumw * sumw / (weights * weights).sum();
00134     weights /= sumw;
00135     
00136 
00137     <span class="comment">/* most of the rest depends on mu_eff, so needs to be set again */</span>
00138     
00139     <span class="comment">/* set the others using Nikolaus logic. If you want to tweak, you can parameterize over these defaults */</span>
00140     mucov = mueff;
00141     ccumsig = (mueff + 2.) / (n + mueff + 3.);
00142     ccumcov = 4. / (n + 4);
00143     
00144     <span class="keywordtype">double</span> t1 = 2. / ((n+1.4142)*(n+1.4142));
00145     <span class="keywordtype">double</span> t2 = (2.*mucov-1.) / ((n+2.)*(n+2.)+mucov);
00146     t2 = (t2 &gt; 1) ? 1 : t2;
00147     t2 = (1./mucov) * t1 + (1.-1./mucov) * t2;
00148     
00149     ccov = t2;
00150 
00151     damp = 1 + std::max(0.3,(1.-(<span class="keywordtype">double</span>)n/(<span class="keywordtype">double</span>)maxgen))
00152               * (1+2*std::max(0.,sqrt((mueff-1.)/(n+1.))-1)) <span class="comment">/* limit sigma increase */</span>
00153                     / ccumsig;
00154   
00155     vector&lt;double&gt; mins(1,0.0);
00156     mins = parser.createParam(
00157             mins,
00158             <span class="stringliteral">"min-stdev"</span>,
00159             <span class="stringliteral">"Array of minimum stdevs, last one will apply for all remaining axes"</span>,
00160             0,
00161             section).value();
00162     
00163     <span class="keywordflow">if</span> (mins.size() &gt; n) mins.resize(n);
00164 
00165     <span class="keywordflow">if</span> (mins.size()) {
00166         minStdevs = mins.back();
00167         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; mins.size(); ++i) {
00168             minStdevs[i] = mins[i];
00169         }
00170     }
00171     
00172     vector&lt;double&gt; inits(1,0.3);
00173     inits = parser.createParam(
00174             inits,
00175             <span class="stringliteral">"init-stdev"</span>,
00176             <span class="stringliteral">"Array of initial stdevs, last one will apply for all remaining axes"</span>,
00177             0,
00178             section).value();
00179     
00180     <span class="keywordflow">if</span> (inits.size() &gt; n) inits.resize(n);
00181 
00182     <span class="keywordflow">if</span> (inits.size()) {
00183         initialStdevs = inits.back();
00184         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; inits.size(); ++i) {
00185             initialStdevs[i] = inits[i];
00186         }
00187     }
00188     
00189 }
00190 
00191 <span class="keywordtype">void</span> CMAParams::defaults(<span class="keywordtype">unsigned</span> n_, <span class="keywordtype">unsigned</span> maxgen_) {
00192     n = n_;
00193     maxgen = maxgen_;
00194 
00195     lambda = 4+(int)(3*log((<span class="keywordtype">double</span>) n));
00196     mu = lambda / 2;
00197     
00198     weights.resize(mu);
00199     
00200     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; weights.size(); ++i) {
00201         weights[i] = log(mu+1.)-log(i+1.);
00202     }
00203     
00204     <span class="comment">/* Normalize weights and set mu_eff */</span>
00205     <span class="keywordtype">double</span> sumw = weights.sum();
00206     mueff =  sumw * sumw / (weights * weights).sum();
00207     weights /= sumw;
00208     
00209     mucov = mueff;
00210     ccumsig *= (mueff + 2.) / (n + mueff + 3.);
00211     ccumcov = 4. / (n + 4);
00212     
00213     <span class="keywordtype">double</span> t1 = 2. / ((n+1.4142)*(n+1.4142));
00214     <span class="keywordtype">double</span> t2 = (2.*mucov-1.) / ((n+2.)*(n+2.)+mucov);
00215     t2 = (t2 &gt; 1) ? 1 : t2;
00216     t2 = (1./mucov) * t1 + (1.-1./mucov) * t2;
00217     
00218     ccov = t2;
00219 
00220     damp = 1 + std::max(0.3,(1.-(<span class="keywordtype">double</span>)n/maxgen))
00221               * (1+2*std::max(0.,sqrt((mueff-1.)/(n+1.))-1)) <span class="comment">/* limit sigma increase */</span>
00222                     / ccumsig;
00223 
00224     minStdevs.resize(n);
00225     minStdevs = 0.0;
00226     
00227     initialStdevs.resize(n);
00228     initialStdevs = 0.3;
00229     
00230 
00231 }
00232 
00233 
00234 }<span class="comment">// namespace eo</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Thu Oct 19 05:06:34 2006 for EO by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
