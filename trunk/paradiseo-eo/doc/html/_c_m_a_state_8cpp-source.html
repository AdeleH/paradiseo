<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>EO: CMAState.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<div class="nav">
<a class="el" href="dir_000000.html">src</a>&nbsp;/&nbsp;<a class="el" href="dir_000010.html">es</a></div>
<h1>CMAState.cpp</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment"> * C++ification of Nikolaus Hansen's original C-source code for the</span>
00003 <span class="comment"> * CMA-ES</span>
00004 <span class="comment"> *</span>
00005 <span class="comment"> * C++-ificiation performed by Maarten Keijzer (C) 2005. Licensed under</span>
00006 <span class="comment"> * the LGPL. Original copyright of Nikolaus Hansen can be found below</span>
00007 <span class="comment"> *</span>
00008 <span class="comment"> *</span>
00009 <span class="comment"> * Some changes have been made to the original flow and logic of the</span>
00010 <span class="comment"> * algorithm:</span>
00011 <span class="comment"> *</span>
00012 <span class="comment"> *      - Numerical issues are now treated 'before' going into the eigenvector decomposition</span>
00013 <span class="comment"> *          (this was done out of convenience)</span>
00014 <span class="comment"> *      - dMaxSignifiKond (smallest x such that x == x + 1.0) replaced by</span>
00015 <span class="comment"> *        numeric_limits&lt;double&gt;::epsilon() (smallest x such that 1.0 != 1.0 + x)</span>
00016 <span class="comment"> *        </span>
00017 <span class="comment"> * </span>
00018 <span class="comment"> */</span>
00019 
00020 <span class="comment">/* --------------------------------------------------------- */</span>
00021 <span class="comment">/* --------------------------------------------------------- */</span>
00022 <span class="comment">/* --- File: cmaes.c  -------- Author: Nikolaus Hansen   --- */</span>
00023 <span class="comment">/* --------------------------------------------------------- */</span>
00024 <span class="comment">/*</span>
00025 <span class="comment"> *      CMA-ES for non-linear function minimization.</span>
00026 <span class="comment"> *</span>
00027 <span class="comment"> *           Copyright (C) 1996, 2003  Nikolaus Hansen.</span>
00028 <span class="comment"> *           e-mail: hansen@bionik.tu-berlin.de</span>
00029 <span class="comment"> *</span>
00030 <span class="comment"> *           This library is free software; you can redistribute it and/or</span>
00031 <span class="comment"> *           modify it under the terms of the GNU Lesser General Public</span>
00032 <span class="comment"> *           License as published by the Free Software Foundation; either</span>
00033 <span class="comment"> *           version 2.1 of the License, or (at your option) any later</span>
00034 <span class="comment"> *           version (see http://www.gnu.org/copyleft/lesser.html).</span>
00035 <span class="comment"> *</span>
00036 <span class="comment"> *           This library is distributed in the hope that it will be useful,</span>
00037 <span class="comment"> *           but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00038 <span class="comment"> *           MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
00039 <span class="comment"> *           Lesser General Public License for more details.</span>
00040 <span class="comment"> * </span>
00041 <span class="comment"> *                                                             */</span>
00042 <span class="comment">/* --- Changes : ---</span>
00043 <span class="comment"> *   03/03/21: argument const double *rgFunVal of</span>
00044 <span class="comment"> *   cmaes_ReestimateDistribution() was treated incorrectly.</span>
00045 <span class="comment"> *   03/03/29: restart via cmaes_resume_distribution() implemented.</span>
00046 <span class="comment"> *   03/03/30: Always max std dev / largest axis is printed first.</span>
00047 <span class="comment"> *   03/08/30: Damping is adjusted for large mueff.</span>
00048 <span class="comment"> *   03/10/30: Damping is adjusted for large mueff always.</span>
00049 <span class="comment"> *   04/04/22: Cumulation time and damping for step size adjusted.</span>
00050 <span class="comment"> *   No iniphase but conditional update of pc.</span>
00051 <span class="comment"> *   Version 2.23.</span>
00052 <span class="comment"> *                               */</span>
00053 
00054 <span class="preprocessor">#include &lt;valarray&gt;</span>
00055 <span class="preprocessor">#include &lt;limits&gt;</span>
00056 <span class="preprocessor">#include &lt;iostream&gt;</span>
00057 <span class="preprocessor">#include &lt;cassert&gt;</span>
00058 
00059 <span class="preprocessor">#include &lt;utils/eoRNG.h&gt;</span>
00060 
00061 <span class="preprocessor">#include &lt;es/CMAState.h&gt;</span>
00062 <span class="preprocessor">#include &lt;es/CMAParams.h&gt;</span>
00063 <span class="preprocessor">#include &lt;es/matrices.h&gt;</span>
00064 <span class="preprocessor">#include &lt;es/eig.h&gt;</span>
00065 
00066 <span class="keyword">using</span> <span class="keyword">namespace </span>std;
00067 
00068 <span class="keyword">namespace </span>eo {
00069     
00070 <span class="keyword">struct </span>CMAStateImpl {
00071     
00072     CMAParams p;
00073     
00074     lower_triangular_matrix     C; <span class="comment">// Covariance matrix</span>
00075     square_matrix               B; <span class="comment">// Eigen vectors (in columns)</span>
00076     valarray&lt;double&gt;            d; <span class="comment">// eigen values (diagonal matrix)</span>
00077     valarray&lt;double&gt;            pc; <span class="comment">// Evolution path</span>
00078     valarray&lt;double&gt;            ps; <span class="comment">// Evolution path for stepsize;</span>
00079     
00080     vector&lt;double&gt;              mean; <span class="comment">// current mean to sample around</span>
00081     <span class="keywordtype">double</span>                      sigma; <span class="comment">// global step size</span>
00082    
00083     <span class="keywordtype">unsigned</span>                    gen;
00084     vector&lt;double&gt;              fitnessHistory;
00085     
00086     
00087     CMAStateImpl(<span class="keyword">const</span> CMAParams&amp; params_, <span class="keyword">const</span> vector&lt;double&gt;&amp; m, <span class="keywordtype">double</span> sigma_) :
00088         p(params_),
00089         C(p.n), B(p.n), d(p.n), pc(p.n), ps(p.n), mean(m), sigma(sigma_),
00090         gen(0), fitnessHistory(3)
00091     {
00092         <span class="keywordtype">double</span> trace = (p.initialStdevs * p.initialStdevs).sum();
00093         <span class="comment">/* Initialize covariance structure */</span>
00094         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; p.n; ++i)
00095         {
00096             B[i][i] = 1.;
00097             d[i] = p.initialStdevs[i] * sqrt(p.n / trace);
00098             C[i][i] = d[i] * d[i];
00099             pc[i] = 0.;
00100             ps[i] = 0.;
00101         }
00102          
00103     }
00104 
00105     <span class="keywordtype">void</span> sample(vector&lt;double&gt;&amp; v) {
00106         <span class="keywordtype">unsigned</span> n = p.n;
00107         v.resize(n);
00108         
00109         vector&lt;double&gt; tmp(n);
00110         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; n; ++i)
00111             tmp[i] = d[i] * rng.<a class="code" href="classeo_rng.html#a7">normal</a>();
00112         
00113         <span class="comment">/* add mutation (sigma * B * (D*z)) */</span>
00114         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; n; ++i) {
00115             <span class="keywordtype">double</span> sum = 0;
00116             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j = 0; j &lt; n; ++j) {
00117                 sum += B[i][j] * tmp[j];
00118             }
00119             v[i] = mean[i] + sigma * sum;
00120         }
00121     }
00122     
00123     <span class="keywordtype">void</span> reestimate(<span class="keyword">const</span> vector&lt;<span class="keyword">const</span> vector&lt;double&gt;* &gt;&amp; pop, <span class="keywordtype">double</span> muBest, <span class="keywordtype">double</span> muWorst) {
00124         
00125         assert(pop.size() == p.mu);
00126         
00127         <span class="keywordtype">unsigned</span> n = p.n;
00128 
00129         fitnessHistory[gen % fitnessHistory.size()] = muBest; <span class="comment">// needed for divergence check</span>
00130         
00131         vector&lt;double&gt; oldmean = mean;
00132         valarray&lt;double&gt; BDz(n);
00133         
00134         <span class="comment">/* calculate xmean and rgBDz~N(0,C) */</span>
00135         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; n; ++i) {
00136             mean[i] = 0.;
00137             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j = 0; j &lt; pop.size(); ++j) {
00138                 mean[i] += p.weights[j] * (*pop[j])[i]; 
00139             }
00140             BDz[i] = sqrt(p.mueff)*(mean[i] - oldmean[i])/sigma; 
00141         }
00142 
00143         vector&lt;double&gt; tmp(n);
00144         <span class="comment">/* calculate z := D^(-1) * B^(-1) * rgBDz into rgdTmp */</span>
00145         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; n; ++i) {
00146             <span class="keywordtype">double</span> sum = 0.0;
00147             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j = 0; j &lt; n; ++j) {
00148                 sum += B[j][i] * BDz[j];
00149             }
00150             tmp[i] = sum / d[i];
00151         }
00152 
00153         <span class="comment">/* cumulation for sigma (ps) using B*z */</span>
00154         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; n; ++i) {
00155             <span class="keywordtype">double</span> sum = 0.0;
00156             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j = 0; j &lt; n; ++j)
00157                 sum += B[i][j] * tmp[j];
00158             
00159             ps[i] = (1. - p.ccumsig) * ps[i] + sqrt(p.ccumsig * (2. - p.ccumsig)) * sum;
00160         }
00161 
00162         <span class="comment">/* calculate norm(ps)^2 */</span>
00163         <span class="keywordtype">double</span> psxps = (ps * ps).sum();
00164 
00165         
00166         <span class="keywordtype">double</span> chiN =  sqrt((<span class="keywordtype">double</span>) p.n) * (1. - 1./(4.*p.n) + 1./(21.*p.n*p.n));
00167         <span class="comment">/* cumulation for covariance matrix (pc) using B*D*z~N(0,C) */</span>
00168         <span class="keywordtype">double</span> hsig = sqrt(psxps) / sqrt(1. - pow(1.-p.ccumsig, 2.*gen)) / chiN &lt; 1.5 + 1./(p.n-0.5);
00169         
00170         pc = (1. - p.ccumcov) * pc + hsig * sqrt(p.ccumcov * (2. - p.ccumcov)) * BDz;
00171         
00172         <span class="comment">/* stop initial phase (MK, this was not reachable in the org code, deleted) */</span>
00173 
00174         <span class="comment">/* remove momentum in ps, if ps is large and fitness is getting worse */</span>
00175 
00176         <span class="keywordflow">if</span> (gen &gt;= fitnessHistory.size()) {
00177 
00178             <span class="comment">// find direction from muBest and muWorst (muBest == muWorst handled seperately</span>
00179             <span class="keywordtype">double</span> direction = muBest &lt; muWorst? -1.0 : 1.0;
00180             
00181             <span class="keywordtype">unsigned</span> now = gen % fitnessHistory.size();
00182             <span class="keywordtype">unsigned</span> prev = (gen-1) % fitnessHistory.size();
00183             <span class="keywordtype">unsigned</span> prevprev = (gen-2) % fitnessHistory.size();
00184 
00185             <span class="keywordtype">bool</span> fitnessWorsens = (muBest == muWorst) || <span class="comment">// &lt;- increase norm also when population has converged (this deviates from Hansen's scheme)</span>
00186                             ( (direction * fitnessHistory[now] &lt; direction * fitnessHistory[prev])
00187                                             &amp;&amp;
00188                               (direction * fitnessHistory[now] &lt; direction * fitnessHistory[prevprev]));
00189         
00190             <span class="keywordflow">if</span>(psxps/p.n &gt; 1.5 + 10.*sqrt(2./p.n) &amp;&amp; fitnessWorsens) {
00191                 <span class="keywordtype">double</span> tfac = sqrt((1 + std::max(0., log(psxps/p.n))) * p.n / psxps);
00192                 ps          *= tfac;
00193                 psxps   *= tfac*tfac; 
00194             }
00195         }
00196 
00197         <span class="comment">/* update of C  */</span>
00198         <span class="comment">/* Adapt_C(t); not used anymore */</span>
00199         <span class="keywordflow">if</span> (p.ccov != 0.) {
00200             <span class="comment">//flgEigensysIsUptodate = 0;</span>
00201 
00202             <span class="comment">/* update covariance matrix */</span>
00203             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; n; ++i) {
00204                 vector&lt;double&gt;::iterator c_row = C[i];
00205                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j = 0; j &lt;= i; ++j) {
00206                     c_row[j] = 
00207                                 (1 - p.ccov) * c_row[j]
00208                                         +
00209                                 p.ccov * (1./p.mucov) * pc[i] * pc[j]
00210                                         +
00211                                 (1-hsig) * p.ccumcov * (2. - p.ccumcov) * c_row[j];
00212                     
00213                     <span class="comment">/*C[i][j] = (1 - p.ccov) * C[i][j] </span>
00214 <span class="comment">                        + sp.ccov * (1./sp.mucov) </span>
00215 <span class="comment">                        * (rgpc[i] * rgpc[j] </span>
00216 <span class="comment">                                + (1-hsig)*sp.ccumcov*(2.-sp.ccumcov) * C[i][j]); */</span>
00217                     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> k = 0; k &lt; p.mu; ++k) { <span class="comment">/* additional rank mu update */</span>
00218                         c_row[j] += p.ccov * (1-1./p.mucov) * p.weights[k]  
00219                             * ( (*pop[k])[i] - oldmean[i])
00220                             * ( (*pop[k])[j] - oldmean[j])
00221                             / sigma / sigma;
00222                     
00223                            <span class="comment">// * (rgrgx[index[k]][i] - rgxold[i]) </span>
00224                            <span class="comment">// * (rgrgx[index[k]][j] - rgxold[j])</span>
00225                            <span class="comment">// / sigma / sigma; </span>
00226                     }
00227                 }
00228             }
00229         }
00230 
00231         <span class="comment">/* update of sigma */</span>
00232         sigma *= exp(((sqrt(psxps)/chiN)-1.)/p.damp);
00233         <span class="comment">/* calculate eigensystem, must be done by caller  */</span>
00234         <span class="comment">//cmaes_UpdateEigensystem(0);</span>
00235 
00236         
00237         <span class="comment">/* treat minimal standard deviations and numeric problems </span>
00238 <span class="comment">         * Note that in contrast with the original code, some numerical issues are treated *before* we </span>
00239 <span class="comment">         * go into the eigenvalue calculation */</span>
00240         
00241         treatNumericalIssues(muBest, muWorst);
00242 
00243         gen++; <span class="comment">// increase generation</span>
00244     }
00245 
00246     <span class="keywordtype">void</span> treatNumericalIssues(<span class="keywordtype">double</span> best, <span class="keywordtype">double</span> worst) {
00247         
00248         <span class="comment">/* treat stdevs */</span>
00249         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; p.n; ++i) {
00250             <span class="keywordflow">if</span> (sigma * sqrt(C[i][i]) &lt; p.minStdevs[i]) {
00251                 <span class="comment">// increase stdev</span>
00252                 sigma *= exp(0.05+1./p.damp);
00253                 <span class="keywordflow">break</span>;
00254             }
00255         }
00256         
00257         <span class="comment">/* treat convergence */</span>
00258         <span class="keywordflow">if</span> (best == worst) {
00259             sigma *= exp(0.2 + 1./p.damp);
00260         }
00261         
00262         <span class="comment">/* Jede Hauptachse i testen, ob x == x + 0.1 * sigma * rgD[i] * B[i] */</span>
00263         <span class="comment">/* Test if all the means are not numerically out of whack with our coordinate system*/</span>
00264         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> axis = 0; axis &lt; p.n; ++axis) {
00265             <span class="keywordtype">double</span> fac = 0.1 * sigma * d[axis];
00266             <span class="keywordtype">unsigned</span> coord;
00267             <span class="keywordflow">for</span> (coord = 0; coord &lt; p.n; ++coord) {
00268                 <span class="keywordflow">if</span> (mean[coord] != mean[coord] + fac * B[coord][axis]) {
00269                     <span class="keywordflow">break</span>;
00270                 }
00271             }
00272 
00273             <span class="keywordflow">if</span> (coord == p.n) { <span class="comment">// means are way too big (little) for numerical accuraccy. Start rocking the craddle a bit more</span>
00274                 sigma *= exp(0.2+1./p.damp);
00275             }
00276             
00277         }
00278             
00279         <span class="comment">/* Testen ob eine Komponente des Objektparameters festhaengt */</span>
00280         <span class="comment">/* Correct issues with scale between objective values and covariances */</span>
00281         <span class="keywordtype">bool</span> theresAnIssue = <span class="keyword">false</span>;
00282 
00283         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; p.n; ++i) {
00284             <span class="keywordflow">if</span> (mean[i] == mean[i] + 0.2 * sigma * sqrt(C[i][i])) {
00285                 C[i][i] *= (1. + p.ccov);
00286                 theresAnIssue = <span class="keyword">true</span>;
00287             }
00288         }
00289 
00290         <span class="keywordflow">if</span> (theresAnIssue) {
00291             sigma *= exp(0.05 + 1./p.damp);
00292         }
00293     }
00294 
00295     
00296     <span class="keywordtype">bool</span> updateEigenSystem(<span class="keywordtype">unsigned</span> max_tries, <span class="keywordtype">unsigned</span> max_iters) {
00297 
00298         <span class="keywordflow">if</span> (max_iters==0) max_iters = 30 * p.n;
00299         
00300         <span class="keyword">static</span> <span class="keywordtype">double</span> lastGoodMinimumEigenValue = 1.0;
00301         
00302         <span class="comment">/* Try to get a valid calculation */</span>
00303         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> tries = 0; tries &lt; max_tries; ++tries) {
00304              
00305             <span class="keywordtype">unsigned</span> iters = eig( p.n, C, d, B, max_iters); 
00306             <span class="keywordflow">if</span> (iters &lt; max_iters) 
00307             { <span class="comment">// all is well</span>
00308                 
00309                 <span class="comment">/* find largest/smallest eigenvalues */</span>
00310                 <span class="keywordtype">double</span> minEV = d.min(); 
00311                 <span class="keywordtype">double</span> maxEV = d.max(); 
00312 
00313                 <span class="comment">/* (MK Original comment was) :Limit Condition of C to dMaxSignifKond+1 </span>
00314 <span class="comment">                 * replaced dMaxSignifKond with 1./numeric_limits&lt;double&gt;::epsilon()</span>
00315 <span class="comment">                 * */</span>
00316                 <span class="keywordflow">if</span> (maxEV * numeric_limits&lt;double&gt;::epsilon() &gt; minEV) {
00317                     <span class="keywordtype">double</span> tmp = maxEV * numeric_limits&lt;double&gt;::epsilon() - minEV;
00318                     minEV += tmp;
00319                     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0;i&lt;p.n;++i) {
00320                         C[i][i] += tmp;
00321                         d[i] += tmp;
00322                     }
00323                 } <span class="comment">/* if */</span>
00324                 lastGoodMinimumEigenValue = minEV;
00325 
00326                 d = sqrt(d);
00327 
00328                 <span class="comment">//flgEigensysIsUptodate = 1;</span>
00329                 <span class="comment">//genOfEigensysUpdate = gen; </span>
00330                 <span class="comment">//clockeigensum += clock() - clockeigenbegin;</span>
00331                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
00332             } <span class="comment">/* if cIterEig &lt; ... */</span>
00333 
00334             <span class="comment">// numerical problems, ignore them and try again</span>
00335             
00336             <span class="comment">/* Addition des letzten minEW auf die Diagonale von C */</span>
00337             <span class="comment">/* Add the last known good eigen value to the diagonal of C */</span>
00338             <span class="keywordtype">double</span> summand = lastGoodMinimumEigenValue * exp((<span class="keywordtype">double</span>) tries);
00339             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; p.n; ++i)
00340                 C[i][i] += summand;
00341 
00342         } <span class="comment">/* for iEigenCalcVers */</span>
00343         
00344         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00345         
00346     }
00347     
00348         
00349 };
00350 
00351 CMAState::CMAState(<span class="keyword">const</span> CMAParams&amp; params, <span class="keyword">const</span> std::vector&lt;double&gt;&amp; initial_point, <span class="keyword">const</span> <span class="keywordtype">double</span> initial_sigma) 
00352     : pimpl(new CMAStateImpl(params, initial_point, initial_sigma)) {}
00353 
00354 CMAState::~CMAState() { <span class="keyword">delete</span> pimpl; }
00355 CMAState::CMAState(<span class="keyword">const</span> CMAState&amp; that) : pimpl(new CMAStateImpl(*that.pimpl )) {}
00356 CMAState&amp; CMAState::operator=(<span class="keyword">const</span> CMAState&amp; that) { *pimpl = *that.pimpl; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
00357 
00358 <span class="keywordtype">void</span> CMAState::sample(vector&lt;double&gt;&amp; v)<span class="keyword"> const </span>{  pimpl-&gt;sample(v); }
00359 
00360 <span class="keywordtype">void</span> CMAState::reestimate(<span class="keyword">const</span> vector&lt;<span class="keyword">const</span> vector&lt;double&gt;* &gt;&amp; population, <span class="keywordtype">double</span> muBest, <span class="keywordtype">double</span> muWorst) { pimpl-&gt;reestimate(population, muBest, muWorst); }
00361 <span class="keywordtype">bool</span> CMAState::updateEigenSystem(<span class="keywordtype">unsigned</span> max_tries, <span class="keywordtype">unsigned</span> max_iters) { <span class="keywordflow">return</span> pimpl-&gt;updateEigenSystem(max_tries, max_iters); }
00362 
00363 
00364 } <span class="comment">// namespace eo</span>
00365 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Thu Oct 19 05:06:34 2006 for EO by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
