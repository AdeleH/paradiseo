<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>EO: eoStat.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<div class="nav">
<a class="el" href="dir_000000.html">src</a>&nbsp;/&nbsp;<a class="el" href="dir_000011.html">utils</a></div>
<h1>eoStat.h</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">// -*- mode: c++; c-indent-level: 4; c++-member-init-indent: 8; comment-column: 35; -*-</span>
00002 
00003 <span class="comment">//-----------------------------------------------------------------------------</span>
00004 <span class="comment">// eoStat.h</span>
00005 <span class="comment">// (c) Marc Schoenauer, Maarten Keijzer and GeNeura Team, 2000</span>
00006 <span class="comment">/*</span>
00007 <span class="comment">    This library is free software; you can redistribute it and/or</span>
00008 <span class="comment">    modify it under the terms of the GNU Lesser General Public</span>
00009 <span class="comment">    License as published by the Free Software Foundation; either</span>
00010 <span class="comment">    version 2 of the License, or (at your option) any later version.</span>
00011 <span class="comment"></span>
00012 <span class="comment">    This library is distributed in the hope that it will be useful,</span>
00013 <span class="comment">    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00014 <span class="comment">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
00015 <span class="comment">    Lesser General Public License for more details.</span>
00016 <span class="comment"></span>
00017 <span class="comment">    You should have received a copy of the GNU Lesser General Public</span>
00018 <span class="comment">    License along with this library; if not, write to the Free Software</span>
00019 <span class="comment">    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
00020 <span class="comment"></span>
00021 <span class="comment">    Contact: todos@geneura.ugr.es, http://geneura.ugr.es</span>
00022 <span class="comment">             Marc.Schoenauer@polytechnique.fr</span>
00023 <span class="comment">             mkeijzer@dhi.dk</span>
00024 <span class="comment"> */</span>
00025 <span class="comment">//-----------------------------------------------------------------------------</span>
00026 
00027 <span class="preprocessor">#ifndef _eoStat_h</span>
00028 <span class="preprocessor"></span><span class="preprocessor">#define _eoStat_h</span>
00029 <span class="preprocessor"></span>
00030 <span class="preprocessor">#include &lt;numeric&gt;</span> <span class="comment">// accumulate</span>
00031 
00032 <span class="preprocessor">#include &lt;eoFunctor.h&gt;</span>
00033 <span class="preprocessor">#include &lt;utils/eoParam.h&gt;</span>
00034 <span class="preprocessor">#include &lt;eoPop.h&gt;</span>
00035 <span class="preprocessor">#include &lt;eoParetoFitness.h&gt;</span>
00036 
00044 <span class="keyword">template</span> &lt;<span class="keyword">class</span> EOT&gt;
<a name="l00045"></a><a class="code" href="classeo_stat_base.html">00045</a> <span class="keyword">class </span><a class="code" href="classeo_stat_base.html">eoStatBase</a> : <span class="keyword">public</span> <a class="code" href="classeo_u_f.html">eoUF</a>&lt;const eoPop&lt;EOT&gt;&amp;, void&gt;
00046 {
00047 <span class="keyword">public</span>:
00048   <span class="keyword">virtual</span> <span class="keywordtype">void</span> lastCall(<span class="keyword">const</span> <a class="code" href="classeo_pop.html">eoPop&lt;EOT&gt;</a>&amp;) {}
00049   <span class="keyword">virtual</span> std::string className(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">"eoStatBase"</span>; }
00050 };
00051 
00057 <span class="keyword">template</span> &lt;<span class="keyword">class</span> EOT, <span class="keyword">class</span> T&gt;
<a name="l00058"></a><a class="code" href="classeo_stat.html">00058</a> <span class="keyword">class </span><a class="code" href="classeo_stat.html">eoStat</a> : <span class="keyword">public</span> <a class="code" href="classeo_value_param.html">eoValueParam</a>&lt;T&gt;, <span class="keyword">public</span> <a class="code" href="classeo_stat_base.html">eoStatBase</a>&lt;EOT&gt;
00059 {
00060 <span class="keyword">public</span>:
00061 
00062     <a class="code" href="classeo_stat.html">eoStat</a>(T _value, std::string _description)
00063         : <a class="code" href="classeo_value_param.html">eoValueParam&lt;T&gt;</a>(_value, _description)
00064         {}
00065 
00066     <span class="keyword">virtual</span> std::string className(<span class="keywordtype">void</span>)<span class="keyword"> const</span>
00067 <span class="keyword">        </span>{ <span class="keywordflow">return</span> <span class="stringliteral">"eoStat"</span>; }
00068 };
00069 
00070 
00071 
00075 <span class="keyword">template</span> &lt;<span class="keyword">class</span> EOT&gt;
<a name="l00076"></a><a class="code" href="classeo_sorted_stat_base.html">00076</a> <span class="keyword">class </span><a class="code" href="classeo_sorted_stat_base.html">eoSortedStatBase</a> : <span class="keyword">public</span> <a class="code" href="classeo_u_f.html">eoUF</a>&lt;const std::vector&lt;const EOT*&gt;&amp;, void&gt;
00077 {
00078 <span class="keyword">public</span>:
00079   <span class="keyword">virtual</span> <span class="keywordtype">void</span> lastCall(<span class="keyword">const</span> std::vector&lt;const EOT*&gt;&amp;) {}
00080   <span class="keyword">virtual</span> std::string className(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">"eoSortedStatBase"</span>; }
00081 };
00082 
00088 <span class="keyword">template</span> &lt;<span class="keyword">class</span> EOT, <span class="keyword">class</span> ParamType&gt;
<a name="l00089"></a><a class="code" href="classeo_sorted_stat.html">00089</a> <span class="keyword">class </span><a class="code" href="classeo_sorted_stat.html">eoSortedStat</a> : <span class="keyword">public</span> <a class="code" href="classeo_sorted_stat_base.html">eoSortedStatBase</a>&lt;EOT&gt;, <span class="keyword">public</span> <a class="code" href="classeo_value_param.html">eoValueParam</a>&lt;ParamType&gt;
00090 {
00091 <span class="keyword">public</span> :
00092   <a class="code" href="classeo_sorted_stat.html">eoSortedStat</a>(ParamType _value, std::string _desc) : <a class="code" href="classeo_value_param.html">eoValueParam&lt;ParamType&gt;</a>(_value, _desc) {}
00093   <span class="keyword">virtual</span> std::string className(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">"eoSortedStat"</span>; }
00094 };
00095 
00105 <span class="preprocessor">#ifdef _MSC_VER</span>
00106 <span class="preprocessor"></span><span class="keyword">template</span> &lt;<span class="keyword">class</span> EOT&gt; <span class="keyword">class </span><a class="code" href="classeo_average_stat.html">eoAverageStat</a> : <span class="keyword">public</span> <a class="code" href="classeo_stat.html">eoStat</a>&lt;EOT, EOT::Fitness&gt;
00107 #else
<a name="l00108"></a><a class="code" href="classeo_average_stat.html">00108</a> template &lt;class EOT&gt; class <a class="code" href="classeo_average_stat.html">eoAverageStat</a> : <span class="keyword">public</span> <a class="code" href="classeo_stat.html">eoStat</a>&lt;EOT, typename EOT::Fitness&gt;
00109 #endif
00110 {
00111 <span class="keyword">public</span> :
00112 
00113     <span class="keyword">using</span> <a class="code" href="classeo_stat.html">eoStat&lt;EOT, typename EOT::Fitness&gt;</a>::value;
00114 
00115     <span class="keyword">typedef</span> <span class="keyword">typename</span> EOT::Fitness Fitness;
00116 
00117     <a class="code" href="classeo_average_stat.html">eoAverageStat</a>(std::string _description = <span class="stringliteral">"Average Fitness"</span>)
00118       : <a class="code" href="classeo_stat.html">eoStat&lt;EOT, Fitness&gt;</a>(Fitness(), _description) {}
00119 
00120     <span class="keyword">static</span> Fitness sumFitness(<span class="keywordtype">double</span> _sum, <span class="keyword">const</span> <a class="code" href="struct_dummy.html">EOT</a>&amp; _eot){
00121         _sum += _eot.<a class="code" href="class_e_o.html#a2">fitness</a>();
00122         <span class="keywordflow">return</span> _sum;
00123     }
00124 
00125     <a class="code" href="classeo_average_stat.html">eoAverageStat</a>(<span class="keywordtype">double</span> _value, std::string _desc) : <a class="code" href="classeo_stat.html">eoStat&lt;EOT, double&gt;</a>(_value, _desc) {}
00126 
<a name="l00127"></a><a class="code" href="classeo_average_stat.html#a2">00127</a>     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classeo_average_stat.html#a2">operator()</a>(<span class="keyword">const</span> <a class="code" href="classeo_pop.html">eoPop&lt;EOT&gt;</a>&amp; _pop){
00128       doit(_pop, Fitness()); <span class="comment">// specializations for scalar and std::vector</span>
00129     }
00130 
00131   <span class="keyword">virtual</span> std::string className(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">"eoAverageStat"</span>; }
00132 
00133 <span class="keyword">private</span> :
00134 
00135     <span class="comment">// Specialization for pareto fitness</span>
00136     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
00137     <span class="keywordtype">void</span> doit(<span class="keyword">const</span> <a class="code" href="classeo_pop.html">eoPop&lt;EOT&gt;</a>&amp; _pop, <a class="code" href="classeo_pareto_fitness.html">eoParetoFitness&lt;T&gt;</a>)
00138     {
00139       <a class="code" href="classeo_value_param.html#a2">value</a>().clear();
00140       <a class="code" href="classeo_value_param.html#a2">value</a>().resize(_pop[0].fitness().size(), 0.0);
00141 
00142       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> o = 0; o &lt; <a class="code" href="classeo_value_param.html#a2">value</a>().size(); ++o)
00143       {
00144         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; _pop.size(); ++i)
00145         {
00146           <a class="code" href="classeo_value_param.html#a2">value</a>()[o] += _pop[i].fitness()[o];
00147         }
00148 
00149         <a class="code" href="classeo_value_param.html#a2">value</a>()[o] /= _pop.size();
00150       }
00151     }
00152 
00153     <span class="comment">// Default behavior</span>
00154     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
00155     <span class="keywordtype">void</span> doit(<span class="keyword">const</span> <a class="code" href="classeo_pop.html">eoPop&lt;EOT&gt;</a>&amp; _pop, T)
00156     {
00157         Fitness v = std::accumulate(_pop.begin(), _pop.end(), Fitness(0.0), eoAverageStat::sumFitness);
00158 
00159         <a class="code" href="classeo_value_param.html#a2">value</a>() = v / _pop.size();
00160     }
00161 
00162 };
00163 
00167 <span class="keyword">template</span> &lt;<span class="keyword">class</span> EOT&gt;
<a name="l00168"></a><a class="code" href="classeo_second_moment_stats.html">00168</a> <span class="keyword">class </span><a class="code" href="classeo_second_moment_stats.html">eoSecondMomentStats</a> : <span class="keyword">public</span> <a class="code" href="classeo_stat.html">eoStat</a>&lt;EOT, std::pair&lt;double, double&gt; &gt;
00169 {
00170 <span class="keyword">public</span> :
00171 
00172     <span class="keyword">using</span> <a class="code" href="classeo_stat.html">eoStat&lt;EOT, std::pair&lt;double, double&gt;</a> &gt;::value;
00173 
00174     <span class="keyword">typedef</span> <span class="keyword">typename</span> EOT::Fitness fitness_type;
00175 
00176     <span class="keyword">typedef</span> std::pair&lt;double, double&gt; SquarePair;
00177 
00178     <a class="code" href="classeo_second_moment_stats.html">eoSecondMomentStats</a>(std::string _description = <span class="stringliteral">"Average &amp; Stdev"</span>)
00179         : <a class="code" href="classeo_stat.html">eoStat&lt;EOT, SquarePair&gt;</a>(std::make_pair(0.0,0.0), _description)
00180         {}
00181 
00182     <span class="keyword">static</span> SquarePair sumOfSquares(SquarePair _sq, <span class="keyword">const</span> <a class="code" href="struct_dummy.html">EOT</a>&amp; _eo)
00183     {
00184         <span class="keywordtype">double</span> fitness = _eo.<a class="code" href="class_e_o.html#a2">fitness</a>();
00185 
00186         _sq.first += fitness;
00187         _sq.second += fitness * fitness;
00188         <span class="keywordflow">return</span> _sq;
00189     }
00190 
<a name="l00191"></a><a class="code" href="classeo_second_moment_stats.html#a1">00191</a>     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classeo_second_moment_stats.html#a1">operator()</a>(<span class="keyword">const</span> <a class="code" href="classeo_pop.html">eoPop&lt;EOT&gt;</a>&amp; _pop)
00192     {
00193         SquarePair result = std::accumulate(_pop.begin(), _pop.end(), std::make_pair(0.0, 0.0), eoSecondMomentStats::sumOfSquares);
00194 
00195         <span class="keywordtype">double</span> n = _pop.size();
00196         <a class="code" href="classeo_value_param.html#a2">value</a>().first = result.first / n; <span class="comment">// average</span>
00197         <a class="code" href="classeo_value_param.html#a2">value</a>().second = sqrt( (result.second - n * value().first * <a class="code" href="classeo_value_param.html#a2">value</a>().first) / (n - 1.0)); <span class="comment">// stdev</span>
00198     }
00199 
00200   <span class="keyword">virtual</span> std::string className(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">"eoSecondMomentStats"</span>; }
00201 };
00202 
00206 <span class="preprocessor">#ifdef _MSC_VER</span>
00207 <span class="preprocessor"></span><span class="keyword">template</span> &lt;<span class="keyword">class</span> EOT&gt;
00208 <span class="keyword">class </span><a class="code" href="classeo_nth_element_fitness_stat.html">eoNthElementFitnessStat</a> : <span class="keyword">public</span> <a class="code" href="classeo_sorted_stat.html">eoSortedStat</a>&lt;EOT, EOT::Fitness &gt;
00209 #else
00210 template &lt;class EOT&gt;
<a name="l00211"></a><a class="code" href="classeo_nth_element_fitness_stat.html">00211</a> class <a class="code" href="classeo_nth_element_fitness_stat.html">eoNthElementFitnessStat</a> : <span class="keyword">public</span> <a class="code" href="classeo_sorted_stat.html">eoSortedStat</a>&lt;EOT, typename EOT::Fitness &gt;
00212 #endif
00213 {
00214 <span class="keyword">public</span> :
00215     <span class="keyword">using</span> <a class="code" href="classeo_sorted_stat.html">eoSortedStat&lt;EOT, typename EOT::Fitness &gt;</a>::value;
00216 
00217     <span class="keyword">typedef</span> <span class="keyword">typename</span> EOT::Fitness Fitness;
00218 
00219     <a class="code" href="classeo_nth_element_fitness_stat.html">eoNthElementFitnessStat</a>(<span class="keywordtype">unsigned</span> _whichElement, std::string _description = <span class="stringliteral">"nth element fitness"</span>)
00220       : <a class="code" href="classeo_sorted_stat.html">eoSortedStat&lt;EOT, Fitness&gt;</a>(Fitness(), _description), whichElement(_whichElement) {}
00221 
<a name="l00222"></a><a class="code" href="classeo_nth_element_fitness_stat.html#a1">00222</a>     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classeo_nth_element_fitness_stat.html#a1">operator()</a>(<span class="keyword">const</span> std::vector&lt;const EOT*&gt;&amp; _pop)
00223     {
00224         <span class="keywordflow">if</span> (whichElement &gt; _pop.size())
00225             <span class="keywordflow">throw</span> std::logic_error(<span class="stringliteral">"fitness requested of element outside of pop"</span>);
00226 
00227         doit(_pop, Fitness());
00228     }
00229 
00230   <span class="keyword">virtual</span> std::string className(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">"eoNthElementFitnessStat"</span>; }
00231 <span class="keyword">private</span> :
00232 
00233     <span class="keyword">struct </span>CmpFitness
00234     {
00235       CmpFitness(<span class="keywordtype">unsigned</span> _whichElement, <span class="keywordtype">bool</span> _maxim) : whichElement(_whichElement), maxim(_maxim) {}
00236 
00237       <span class="keywordtype">bool</span> <a class="code" href="classeo_nth_element_fitness_stat.html#a1">operator()</a>(<span class="keyword">const</span> <a class="code" href="struct_dummy.html">EOT</a>* a, <span class="keyword">const</span> <a class="code" href="struct_dummy.html">EOT</a>* b)
00238       {
00239         <span class="keywordflow">if</span> (maxim)
00240           <span class="keywordflow">return</span> a-&gt;<a class="code" href="class_e_o.html#a2">fitness</a>()[whichElement] &gt; b-&gt;<a class="code" href="class_e_o.html#a2">fitness</a>()[whichElement];
00241 
00242         <span class="keywordflow">return</span> a-&gt;<a class="code" href="class_e_o.html#a2">fitness</a>()[whichElement] &lt; b-&gt;<a class="code" href="class_e_o.html#a2">fitness</a>()[whichElement];
00243       }
00244 
00245       <span class="keywordtype">unsigned</span> whichElement;
00246       <span class="keywordtype">bool</span> maxim;
00247     };
00248 
00249     <span class="comment">// Specialization for eoParetoFitness</span>
00250     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
00251     <span class="keywordtype">void</span> doit(<span class="keyword">const</span> <a class="code" href="classeo_pop.html">eoPop&lt;EOT&gt;</a>&amp; _pop, <a class="code" href="classeo_pareto_fitness.html">eoParetoFitness&lt;T&gt;</a>)
00252     {
00253       <span class="keyword">typedef</span> <span class="keyword">typename</span> EOT::Fitness::fitness_traits traits;
00254 
00255       <a class="code" href="classeo_value_param.html#a2">value</a>().resize(traits::nObjectives());
00256 
00257       <span class="comment">// copy of pointers, what the heck</span>
00258       std::vector&lt;const EOT*&gt; tmp_pop = _pop;
00259 
00260       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> o = 0; o &lt; <a class="code" href="classeo_value_param.html#a2">value</a>().size(); ++o)
00261       {
00262         <span class="keyword">typename</span> std::vector&lt;const EOT*&gt;::iterator nth = tmp_pop.begin() + whichElement;
00263         std::nth_element(tmp_pop.begin(), nth, tmp_pop.end(), CmpFitness(o, traits::maximizing(o)));
00264         <a class="code" href="classeo_value_param.html#a2">value</a>()[o] = (*nth)-&gt;fitness()[o];
00265       }
00266     }
00267 
00268     <span class="comment">// for everything else</span>
00269     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
00270     <span class="keywordtype">void</span> doit(<span class="keyword">const</span> std::vector&lt;const EOT*&gt;&amp; _pop, T)
00271     {
00272       <a class="code" href="classeo_value_param.html#a2">value</a>() = _pop[whichElement]-&gt;fitness();
00273     }
00274 
00275     <span class="keywordtype">unsigned</span> whichElement;
00276 };
00277 
00278 <span class="comment">/* Actually, you shouldn't need to sort the population to get the best fitness</span>
00279 <span class="comment">   MS - 17/11/00</span>
00280 <span class="comment"></span>
00281 <span class="comment">   But then again, if another stat needs sorted fitness anyway, getting the best</span>
00282 <span class="comment">   out would be very fast.</span>
00283 <span class="comment">   MK - 09/01/03</span>
00284 <span class="comment"></span>
00285 <span class="comment">template &lt;class EOT&gt;</span>
00286 <span class="comment">class eoBestFitnessStat : public eoStat&lt;EOT, typename EOT::Fitness &gt;</span>
00287 <span class="comment">{</span>
00288 <span class="comment">public :</span>
00289 <span class="comment">    typedef typename EOT::Fitness Fitness;</span>
00290 <span class="comment"></span>
00291 <span class="comment">    eoBestFitnessStat(std::string _description = "Best Fitness") :</span>
00292 <span class="comment">      eoStat&lt;EOT, Fitness&gt;(Fitness(), _description) {}</span>
00293 <span class="comment"></span>
00294 <span class="comment">    virtual void operator()(const eoPop&lt;EOT&gt;&amp; _pop)</span>
00295 <span class="comment">    {</span>
00296 <span class="comment">        value() = _pop.nth_element_fitness(0);</span>
00297 <span class="comment">    }</span>
00298 <span class="comment"></span>
00299 <span class="comment">};</span>
00300 <span class="comment">*/</span>
00301 
00311 <span class="preprocessor">#ifdef _MSC_VER</span>
00312 <span class="preprocessor"></span><span class="keyword">template</span> &lt;<span class="keyword">class</span> EOT&gt;
00313 <span class="keyword">class </span><a class="code" href="classeo_best_fitness_stat.html">eoBestFitnessStat</a> : <span class="keyword">public</span> <a class="code" href="classeo_stat.html">eoStat</a>&lt;EOT, EOT::Fitness&gt;
00314 #else
00315 template &lt;class EOT&gt;
<a name="l00316"></a><a class="code" href="classeo_best_fitness_stat.html">00316</a> class <a class="code" href="classeo_best_fitness_stat.html">eoBestFitnessStat</a> : <span class="keyword">public</span> <a class="code" href="classeo_stat.html">eoStat</a>&lt;EOT, typename EOT::Fitness&gt;
00317 #endif
00318 {
00319 <span class="keyword">public</span>:
00320 
00321     <span class="keyword">using</span> <a class="code" href="classeo_stat.html">eoStat&lt;EOT, typename EOT::Fitness&gt;</a>::value;
00322 
00323     <span class="keyword">typedef</span> <span class="keyword">typename</span> EOT::Fitness Fitness;
00324 
00325     <a class="code" href="classeo_best_fitness_stat.html">eoBestFitnessStat</a>(std::string _description = <span class="stringliteral">"Best "</span>)
00326         : <a class="code" href="classeo_stat.html">eoStat&lt;EOT, Fitness&gt;</a>(Fitness(), _description)
00327         {}
00328 
<a name="l00329"></a><a class="code" href="classeo_best_fitness_stat.html#a1">00329</a>     <span class="keywordtype">void</span> <a class="code" href="classeo_best_fitness_stat.html#a1">operator()</a>(<span class="keyword">const</span> <a class="code" href="classeo_pop.html">eoPop&lt;EOT&gt;</a>&amp; _pop) {
00330         doit(_pop, Fitness() ); <span class="comment">// specializations for scalar and std::vector</span>
00331     }
00332 
00333     <span class="keyword">virtual</span> std::string className(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">"eoBestFitnessStat"</span>; }
00334 
00335 
00336 <span class="keyword">private</span> :
00337 
00338     <span class="keyword">struct </span>CmpFitness
00339     {
00340       CmpFitness(<span class="keywordtype">unsigned</span> _which, <span class="keywordtype">bool</span> _maxim) : which(_which), maxim(_maxim) {}
00341 
00342       <span class="keywordtype">bool</span> <a class="code" href="classeo_best_fitness_stat.html#a1">operator()</a>(<span class="keyword">const</span> <a class="code" href="struct_dummy.html">EOT</a>&amp; a, <span class="keyword">const</span> <a class="code" href="struct_dummy.html">EOT</a>&amp; b)
00343       {
00344         <span class="keywordflow">if</span> (maxim)
00345           <span class="keywordflow">return</span> a.<a class="code" href="class_e_o.html#a2">fitness</a>()[which] &lt; b.<a class="code" href="class_e_o.html#a2">fitness</a>()[which];
00346 
00347         <span class="keywordflow">return</span> a.<a class="code" href="class_e_o.html#a2">fitness</a>()[which] &gt; b.<a class="code" href="class_e_o.html#a2">fitness</a>()[which];
00348       }
00349 
00350       <span class="keywordtype">unsigned</span> which;
00351       <span class="keywordtype">bool</span> maxim;
00352     };
00353 
00354     <span class="comment">// Specialization for pareto fitness</span>
00355     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
00356     <span class="keywordtype">void</span> doit(<span class="keyword">const</span> <a class="code" href="classeo_pop.html">eoPop&lt;EOT&gt;</a>&amp; _pop, <a class="code" href="classeo_pareto_fitness.html">eoParetoFitness&lt;T&gt;</a>)
00357     {
00358       <span class="keyword">typedef</span> <span class="keyword">typename</span> EOT::Fitness::fitness_traits traits;
00359       <a class="code" href="classeo_value_param.html#a2">value</a>().resize(traits::nObjectives());
00360 
00361       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> o = 0; o &lt; traits::nObjectives(); ++o)
00362       {
00363         <span class="keyword">typename</span> <a class="code" href="classeo_pop.html">eoPop&lt;EOT&gt;</a>::const_iterator it = std::max_element(_pop.begin(), _pop.end(), CmpFitness(o, traits::maximizing(o)));
00364         <a class="code" href="classeo_value_param.html#a2">value</a>()[o] = it-&gt;fitness()[o];
00365       }
00366     }
00367 
00368     <span class="comment">// default</span>
00369     <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
00370     <span class="keywordtype">void</span> doit(<span class="keyword">const</span> <a class="code" href="classeo_pop.html">eoPop&lt;EOT&gt;</a>&amp; _pop, T)
00371     { <span class="comment">// find the largest elements</span>
00372       <a class="code" href="classeo_value_param.html#a2">value</a>() = _pop.<a class="code" href="classeo_pop.html#a10">best_element</a>().<a class="code" href="class_e_o.html#a2">fitness</a>();
00373     }
00374 
00375 };
00376 
00377 <span class="keyword">template</span> &lt;<span class="keyword">class</span> EOT&gt;
00378 <span class="keyword">class </span>eoDistanceStat : <span class="keyword">public</span> <a class="code" href="classeo_stat.html">eoStat</a>&lt;EOT, double&gt;
00379 {
00380 <span class="keyword">public</span>:
00381 
00382     <span class="keyword">using</span> eoDistanceStat&lt; EOT &gt;::value;
00383 
00384     eoDistanceStat(std::string _name = <span class="stringliteral">"distance"</span>)
00385         : <a class="code" href="classeo_stat.html">eoStat</a>&lt;<a class="code" href="struct_dummy.html">EOT</a>, double&gt;(0.0, _name)
00386         {}
00387 
00388     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
00389     <span class="keywordtype">double</span> distance(T a, T b)
00390     {
00391         T res = a-b;
00392         <span class="keywordflow">return</span> res &lt; 0? -res : res;
00393     }
00394 
00395     <span class="keywordtype">double</span> distance(<span class="keywordtype">bool</span> a, <span class="keywordtype">bool</span> b)
00396     {
00397         <span class="keywordflow">return</span> (a==b)? 0 : 1;
00398     }
00399 
00400     <span class="keywordtype">void</span> <a class="code" href="classeo_u_f.html#a1">operator()</a>(<span class="keyword">const</span> <a class="code" href="classeo_pop.html">eoPop&lt;EOT&gt;</a>&amp; _pop)
00401     {
00402         <span class="keywordtype">double</span>&amp; v = <a class="code" href="classeo_value_param.html#a2">value</a>();
00403         v = 0.0;
00404 
00405         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; _pop.size(); ++i)
00406         {
00407             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j = 0; j &lt; _pop.size(); ++j)
00408             {
00409                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> k = 0; k &lt; _pop[i].size(); ++k)
00410                 {
00411                     v += distance(_pop[i][k], _pop[j][k]);
00412                 }
00413             }
00414         }
00415 
00416         <span class="keywordtype">double</span> sz = _pop.size();
00417         v /= sz * sz * _pop[0].size();
00418     }
00419   <span class="keyword">virtual</span> std::string className(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">"eoDistanceStat"</span>; }
00420 
00421 };
00422 
00423 
00424 
00425 <span class="comment">/*</span>
00426 <span class="comment">template &lt;class EOT&gt;</span>
00427 <span class="comment">class eoStdevStat : public eoStat&lt;EOT, double &gt;</span>
00428 <span class="comment">{</span>
00429 <span class="comment">public :</span>
00430 <span class="comment">    typedef typename eoSecondMomentStats&lt;EOT&gt;::SquarePair SquarePair;</span>
00431 <span class="comment"></span>
00432 <span class="comment">    eoStdevStat(std::string _description = "Stdev") : eoStat&lt;EOT, double&gt;(0.0, _description) {}</span>
00433 <span class="comment"></span>
00434 <span class="comment">    virtual void operator()(const eoPop&lt;EOT&gt;&amp; _pop)</span>
00435 <span class="comment">    {</span>
00436 <span class="comment">        SquarePair result = std::accumulate(pop.begin(), pop.end(), std::make_pair(0.0, 0.0), eoSecondMomentStats::sumOfSquares);</span>
00437 <span class="comment"></span>
00438 <span class="comment">        double n = pop.size();</span>
00439 <span class="comment">        value() = sqrt( (result.second - (result.first / n)) / (n - 1.0)); // stdev</span>
00440 <span class="comment">    }</span>
00441 <span class="comment">};</span>
00442 <span class="comment">*/</span>
00443 <span class="preprocessor">#endif</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Thu Oct 19 05:06:38 2006 for EO by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
