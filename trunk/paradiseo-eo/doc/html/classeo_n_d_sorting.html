<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>EO: eoNDSorting&lt; EOT &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1>eoNDSorting&lt; EOT &gt; Class Template Reference</h1>Non dominated sorting, it *is a* std::vector of doubles, the integer part is the rank (to which front it belongs), the fractional part the niching penalty or distance penalty or whatever penalty you want to squeeze into the bits.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="eo_n_d_sorting_8h-source.html">eoNDSorting.h</a>&gt;</code>
<p>
<p>Inheritance diagram for eoNDSorting&lt; EOT &gt;:
<p><center><img src="classeo_n_d_sorting.png" usemap="#eoNDSorting< EOT >_map" border="0" alt=""></center>
<map name="eoNDSorting< EOT >_map">
<area href="classeo_perf2_worth_cached.html" alt="eoPerf2WorthCached< EOT, double >" shape="rect" coords="372,168,660,192">
<area href="classeo_perf2_worth.html" alt="eoPerf2Worth< EOT, double >" shape="rect" coords="372,112,660,136">
<area href="classeo_u_f.html" alt="eoUF< const eoPop< EOT > &, void >" shape="rect" coords="149,56,437,80">
<area href="classeo_value_param.html" alt="eoValueParam< std::vector< double > >" shape="rect" coords="596,56,884,80">
<area href="classeo_functor_base.html" alt="eoFunctorBase" shape="rect" coords="0,0,288,24">
<area href="classeo_param.html" alt="eoParam" shape="rect" coords="596,0,884,24">
<area href="classeo_n_d_sorting___i.html" alt="eoNDSorting_I< EOT >" shape="rect" coords="223,280,511,304">
<area href="classeo_n_d_sorting___i_i.html" alt="eoNDSorting_II< EOT >" shape="rect" coords="521,280,809,304">
</map>
<a href="classeo_n_d_sorting-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a0" doxytag="eoNDSorting::eoNDSorting"></a>
&nbsp;</td><td class="memItemRight" valign="bottom"><b>eoNDSorting</b> (bool nasty_flag_=false)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual std::vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeo_n_d_sorting.html#a2">niche_penalty</a> (const std::vector&lt; unsigned &gt; &amp;current_front, const <a class="el" href="classeo_pop.html">eoPop</a>&lt; <a class="el" href="struct_dummy.html">EOT</a> &gt; &amp;_pop)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pure virtual function that calculates the 'distance' for each element in the current front Implement to create your own nondominated sorting algorithm.  <a href="#a2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a3" doxytag="eoNDSorting::calculate_worths"></a>
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeo_n_d_sorting.html#a3">calculate_worths</a> (const <a class="el" href="classeo_pop.html">eoPop</a>&lt; <a class="el" href="struct_dummy.html">EOT</a> &gt; &amp;_pop)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The actual virtual function the derived classes should implement. <br></td></tr>
<tr><td colspan="2"><br><h2>Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="o0" doxytag="eoNDSorting::nasty_declone_flag_that_only_is_implemented_for_two_objectives"></a>
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>nasty_declone_flag_that_only_is_implemented_for_two_objectives</b></td></tr>

<tr><td colspan="2"><br><h2>Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d0" doxytag="eoNDSorting::one_objective"></a>
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>one_objective</b> (const <a class="el" href="classeo_pop.html">eoPop</a>&lt; <a class="el" href="struct_dummy.html">EOT</a> &gt; &amp;_pop)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeo_n_d_sorting.html#d1">two_objectives</a> (const <a class="el" href="classeo_pop.html">eoPop</a>&lt; <a class="el" href="struct_dummy.html">EOT</a> &gt; &amp;_pop)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Optimization for two objectives.  <a href="#d1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d2" doxytag="eoNDSorting::m_objectives"></a>
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>m_objectives</b> (const <a class="el" href="classeo_pop.html">eoPop</a>&lt; <a class="el" href="struct_dummy.html">EOT</a> &gt; &amp;_pop)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d3" doxytag="eoNDSorting::rank_to_worth"></a>
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>rank_to_worth</b> ()</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class EOT&gt;<br>
 class eoNDSorting&lt; EOT &gt;</h3>

Non dominated sorting, it *is a* std::vector of doubles, the integer part is the rank (to which front it belongs), the fractional part the niching penalty or distance penalty or whatever penalty you want to squeeze into the bits. 
<p>

<p>
Definition at line <a class="el" href="eo_n_d_sorting_8h-source.html#l00042">42</a> of file <a class="el" href="eo_n_d_sorting_8h-source.html">eoNDSorting.h</a>.<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="a2" doxytag="eoNDSorting::niche_penalty"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class EOT&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">virtual std::vector&lt;double&gt; <a class="el" href="classeo_n_d_sorting.html">eoNDSorting</a>&lt; <a class="el" href="struct_dummy.html">EOT</a> &gt;::niche_penalty           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const std::vector&lt; unsigned &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>current_front</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classeo_pop.html">eoPop</a>&lt; <a class="el" href="struct_dummy.html">EOT</a> &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_pop</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Pure virtual function that calculates the 'distance' for each element in the current front Implement to create your own nondominated sorting algorithm. 
<p>
The size of the returned std::vector should be equal to the size of the current_front. 
<p>
Implemented in <a class="el" href="classeo_n_d_sorting___i.html#a1">eoNDSorting_I&lt; EOT &gt;</a>, and <a class="el" href="classeo_n_d_sorting___i_i.html#a1">eoNDSorting_II&lt; EOT &gt;</a>.
<p>
Referenced by <a class="el" href="eo_n_d_sorting_8h-source.html#l00140">eoNDSorting&lt; EOT &gt;::two_objectives()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="d1" doxytag="eoNDSorting::two_objectives"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class EOT&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="classeo_n_d_sorting.html">eoNDSorting</a>&lt; <a class="el" href="struct_dummy.html">EOT</a> &gt;::two_objectives           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classeo_pop.html">eoPop</a>&lt; <a class="el" href="struct_dummy.html">EOT</a> &gt; &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_pop</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline, private]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Optimization for two objectives. 
<p>
Makes the algorithm run in complexity O(n log n) where n is the population size<p>
This is the same complexity as for a single objective or truncation selection or sorting.<p>
It will perform a sort on the two objectives seperately, and from the information on the ranks of the individuals on these two objectives, the non-dominated sorting rank is determined. There are then three nlogn operations in place: one sort per objective, plus a binary search procedure to combine the information about the ranks.<p>
After that it is a simple exercise to calculate the distance penalty 
<p>
Definition at line <a class="el" href="eo_n_d_sorting_8h-source.html#l00140">140</a> of file <a class="el" href="eo_n_d_sorting_8h-source.html">eoNDSorting.h</a>.
<p>
References <a class="el" href="classeo_n_d_sorting.html#a2">eoNDSorting&lt; EOT &gt;::niche_penalty()</a>, and <a class="el" href="eo_param_8h-source.html#l00166">eoValueParam&lt; std::vector&lt; double &gt; &gt;::value()</a>.
<p>
Referenced by <a class="el" href="eo_n_d_sorting_8h-source.html#l00062">eoNDSorting&lt; EOT &gt;::calculate_worths()</a>.    </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="eo_n_d_sorting_8h-source.html">eoNDSorting.h</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Thu Oct 19 05:06:51 2006 for EO by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
