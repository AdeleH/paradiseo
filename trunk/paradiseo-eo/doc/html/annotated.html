<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>EO: Class List</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindexHL" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1>EO Class List</h1>Here are the classes, structs, unions and interfaces with brief descriptions:<table>
  <tr><td class="indexkey"><a class="el" href="classeo1_pt_bit_crossover.html">eo1PtBitCrossover</a></td><td class="indexvalue">Eo1PtBitXover --&gt; classic 1-point crossover </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_aged.html">eoAged&lt; Object &gt;</a></td><td class="indexvalue">EoAge is a template class that adds an age to an object.\ Requisites for template instantiation are that the object must admit a default ctor and a copy ctor </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_algo.html">eoAlgo&lt; EOT &gt;</a></td><td class="indexvalue">This is a generic class for population-transforming algorithms </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_arithmetic_crossover.html">eoArithmeticCrossover</a></td><td class="indexvalue">EoHypercubeCrossover --&gt; uniform choice in hypercube == arithmetical with different values for each coordinate </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_assembled_fitness_average_stat.html">eoAssembledFitnessAverageStat&lt; EOT &gt;</a></td><td class="indexvalue">Average fitness values of a population, where the fitness is of type eoScalarAssembledFitness </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_assembled_fitness_best_stat.html">eoAssembledFitnessBestStat&lt; EOT &gt;</a></td><td class="indexvalue">Fitness values of best individuum in a population, where the fitness is of type eoScalarAssembledFitness </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_atom_exchange.html">eoAtomExchange&lt; Atom &gt;</a></td><td class="indexvalue">A helper class for choosing which genes to exchange </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_average_stat.html">eoAverageStat&lt; EOT &gt;</a></td><td class="indexvalue">Average fitness of a population </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_best_fitness_stat.html">eoBestFitnessStat&lt; EOT &gt;</a></td><td class="indexvalue">Best fitness of a population </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_best_select.html">eoBestSelect&lt; EOT &gt;</a></td><td class="indexvalue">EoBestSelect: a selection method that always return the best (mainly for testing purposes) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_b_f.html">eoBF&lt; A1, A2, R &gt;</a></td><td class="indexvalue">Basic Binary Functor </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_biased_node_selector.html">BiasedNodeSelector</a></td><td class="indexvalue">A node selector that does a specified number of rounds ignoring terminals </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_binary_functor_counter.html">eoBinaryFunctorCounter&lt; BinaryFunctor &gt;</a></td><td class="indexvalue">Generic counter class that counts the number of times a binary function is used </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_bin_clone_op.html">eoBinCloneOp&lt; EOT &gt;</a></td><td class="indexvalue">Binary clone: two operands, only the first could be modified </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_bin_gen_op.html">eoBinGenOp&lt; EOT &gt;</a></td><td class="indexvalue">Wrapper for binop: here we use select method of <a class="el" href="classeo_populator.html">eoPopulator</a> but we could also have an embedded selector to select the second parent </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_bin_op.html">eoBinOp&lt; EOType &gt;</a></td><td class="indexvalue">Binary genetic operator: subclasses <a class="el" href="classeo_op.html">eoOp</a>, and defines basically the operator() with two operands, only the first one can be modified When defining your own, make sure that you return a boolean value indicating that you have changed the content </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_bit.html">eoBit&lt; FitT &gt;</a></td><td class="indexvalue">Implementation of bitstring chromosome </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_bit_bit_flip.html">eoBitBitFlip</a></td><td class="indexvalue">EoBitFlip --&gt; changes 1 bit </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_bit_gx_over.html">eoBitGxOver&lt; Chrom &gt;</a></td><td class="indexvalue">EoBitGxOver --&gt; Npts crossover when bistd::string considered as a std::string of binary-encoded genes (exchanges genes) Is anybody still using it apart from historians ??? :-) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_bit_inversion.html">eoBitInversion&lt; Chrom &gt;</a></td><td class="indexvalue">EoBitInversion: inverts the bits of the chromosome between an interval </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_bit_mutation.html">eoBitMutation&lt; Chrom &gt;</a></td><td class="indexvalue">EoBitMutation --&gt; classical mutation </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_bit_next.html">eoBitNext&lt; Chrom &gt;</a></td><td class="indexvalue">EoBitNext --&gt; next value when bitstring considered as binary value </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_bit_op_factory.html">eoBitOpFactory&lt; EOT &gt;</a></td><td class="indexvalue"><a class="el" href="class_e_o.html">EO</a> Factory </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_bit_prev.html">eoBitPrev&lt; Chrom &gt;</a></td><td class="indexvalue">EoBitPrev --&gt; previous value when bitstring treated as binary value </td></tr>
  <tr><td class="indexkey"><a class="el" href="classboolean__generator.html">boolean_generator</a></td><td class="indexvalue">The class boolean_generator can be used in the STL generate function to easily generate random booleans with a specified bias </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_boolean_generator.html">eoBooleanGenerator</a></td><td class="indexvalue">The class eoBooleanGenerator can be used in the STL generate function to easily generate random booleans with a specified bias </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_boolean_init.html">eoBooleanInit</a></td><td class="indexvalue">The class eoBooleanInit can be used in the STL apply function to easily generate random booleans with a specified bias </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_bool_flip.html">eoBoolFlip</a></td><td class="indexvalue">Simple boolean mutation - to be used in generic eoOp's </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_branch_mutation.html">eoBranchMutation&lt; FType, Node &gt;</a></td><td class="indexvalue">EoBranchMutation --&gt; replace a subtree with a randomly created subtree </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_breed.html">eoBreed&lt; EOT &gt;</a></td><td class="indexvalue">Breeding: combination of selecting and transforming a population </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_cellular_easy_e_a.html">eoCellularEasyEA&lt; EOT &gt;</a></td><td class="indexvalue">The abstract cellular easy algorithm </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_check_point.html">eoCheckPoint&lt; EOT &gt;</a></td><td class="indexvalue">EoCheckPoint is a container class </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_c_m_a_breed.html">eoCMABreed&lt; FitT &gt;</a></td><td class="indexvalue">TODO, handle bounds </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_c_m_a_init.html">eoCMAInit&lt; FitT &gt;</a></td><td class="indexvalue">TODO, handle bounds </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_collapse_subtree_mutation.html">eoCollapseSubtreeMutation&lt; FType, Node &gt;</a></td><td class="indexvalue">EoCollapseSubtree --&gt; replace a subtree with a randomly chosen terminal </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_combined_continue.html">eoCombinedContinue&lt; EOT &gt;</a></td><td class="indexvalue">Combined continuators - logical AND: Continues until one of the embedded continuators says halt! </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_combined_init.html">eoCombinedInit&lt; EOT &gt;</a></td><td class="indexvalue">Combined INIT: a proportional recombination of <a class="el" href="classeo_init.html">eoInit</a> objects </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_comma_replacement.html">eoCommaReplacement&lt; EOT &gt;</a></td><td class="indexvalue">ES type of replacement strategy: ignore parents, truncate offspring </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_continue.html">eoContinue&lt; EOT &gt;</a></td><td class="indexvalue">Termination condition for the genetic algorithm Takes the population as input, returns true for continue, false for termination </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_counted_dyn_update.html">eoCountedDynUpdate</a></td><td class="indexvalue">An <a class="el" href="classeo_updater.html">eoUpdater</a> to update an <a class="el" href="classeo_updatable.html">eoUpdatable</a> object every given tic </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_counted_state_saver.html">eoCountedStateSaver</a></td><td class="indexvalue">EoUpdater that saves a state every given generations </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_cov.html">Cov</a></td><td class="indexvalue">Single covariance between two variates </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_ctrl_c_continue.html">eoCtrlCContinue&lt; EOT &gt;</a></td><td class="indexvalue">Ctrl C handling: this <a class="el" href="classeo_continue.html">eoContinue</a> tells whether the user pressed Ctrl C </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_det_bit_flip.html">eoDetBitFlip&lt; Chrom &gt;</a></td><td class="indexvalue">EoDetBitFlip --&gt; changes exactly k bits </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_deterministic_sa_d_replacement.html">eoDeterministicSaDReplacement&lt; EOT &gt;</a></td><td class="indexvalue">EoDeterministicSaDReplacement: replacement strategy that is just, in sequence saves best and kill worse from parents + saves best and kill worse from offspring + merge remaining (neither save nor killed) parents and offspring + reduce that merged population = returns reduced pop + best parents + best offspring </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_deterministic_survive_and_die.html">eoDeterministicSurviveAndDie&lt; EOT &gt;</a></td><td class="indexvalue">An instance (theonly one as of today, Dec </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_det_select.html">eoDetSelect&lt; EOT &gt;</a></td><td class="indexvalue">EoDetSelect selects many individuals determinisctically </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_det_tournament_select.html">eoDetTournamentSelect&lt; EOT &gt;</a></td><td class="indexvalue">EoDetTournamentSelect: a selection method that selects ONE individual by deterministic tournament -MS- 24/10/99 </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_det_tournament_truncate.html">eoDetTournamentTruncate&lt; EOT &gt;</a></td><td class="indexvalue">Truncate class based on a repeated deterministic (reverse!) tournament To be used in SSGA-like replacements (e.g </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_det_tournament_truncate_split.html">eoDetTournamentTruncateSplit&lt; EOT &gt;</a></td><td class="indexvalue">ReduceSplit class based on a repeated deterministic (reverse!) tournament To be used in SSGA-like replacements (e.g </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_det_tournament_worth_select.html">eoDetTournamentWorthSelect&lt; EOT, WorthT &gt;</a></td><td class="indexvalue">An instance of eoSelectPerf2Worth that does selection from the Worthes using a .. </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_det_uniform_mutation.html">eoDetUniformMutation&lt; EOT &gt;</a></td><td class="indexvalue">EoDetUniformMutation --&gt; changes exactly k values of the std::vector by uniform choice with range epsilon </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_distance.html">eoDistance&lt; EOT &gt;</a></td><td class="indexvalue">This is a generic class for distance functors: takes 2 things ane returns a double </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_distrib_updater.html">eoDistribUpdater&lt; EOT &gt;</a></td><td class="indexvalue">Base class for Distribution Evolution Algorithms within <a class="el" href="class_e_o.html">EO</a>: the update rule of distribution </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_distribution.html">eoDistribution&lt; EOT &gt;</a></td><td class="indexvalue">Abstract class for Distribution Evolution Algorithms within <a class="el" href="class_e_o.html">EO</a>: the distribution itself </td></tr>
  <tr><td class="indexkey"><a class="el" href="classd_matrix.html">dMatrix</a></td><td class="indexvalue">A helper class for Sharing - to hold distances </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_dominance_map.html">eoDominanceMap&lt; EoType &gt;</a></td><td class="indexvalue">EoDominanceMap, utility class to calculate and maintain a map (std::vector&lt;std::vector&lt;bool&gt; &gt;) of pareto dominance statistics </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_double_exchange.html">eoDoubleExchange</a></td><td class="indexvalue">Discrete crossover == exchange of values </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_double_intermediate.html">eoDoubleIntermediate</a></td><td class="indexvalue">Intermediate crossover == linear combination </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_drawable.html">eoDrawable&lt; Object &gt;</a></td><td class="indexvalue">EoDrawable is a template class that adds a drawing interface to an object.\ Requisites for template instantiation are that the object must admit a default ctor and a copy ctor </td></tr>
  <tr><td class="indexkey"><a class="el" href="struct_dummy.html">Dummy</a></td><td class="indexvalue">Test program for the general operator - millenium version! uses dummy individuals </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_dyn_s_g_a_transform.html">eoDynSGATransform&lt; EOT &gt;</a></td><td class="indexvalue">EoDynSGATransform: transforms a population using genetic operators </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_dyn_updater.html">eoDynUpdater</a></td><td class="indexvalue">A base class to actually update an <a class="el" href="classeo_updatable.html">eoUpdatable</a> object </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_easy_e_a.html">eoEasyEA&lt; EOT &gt;</a></td><td class="indexvalue">An easy-to-use evolutionary algorithm; you can use any chromosome, and any selection transformation, merging and evaluation algorithms; you can even change in runtime parameters of those sub-algorithms </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_e_d_a.html">eoEDA&lt; EOT &gt;</a></td><td class="indexvalue">EoEDA: Estimation of Distribution Algorithm within <a class="el" href="class_e_o.html">EO</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_elite_sequential_select.html">eoEliteSequentialSelect&lt; EOT &gt;</a></td><td class="indexvalue">All Individuals in order </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_elitism.html">eoElitism&lt; EOT &gt;</a></td><td class="indexvalue">Straightforward elitism class, specify the number of individuals to copy into new geneneration or the rate w.r.t </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_e_o.html">EO&lt; F &gt;</a></td><td class="indexvalue">EO is a base class for evolvable objects, that is, the subjects of evolution </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_e_p_reduce.html">eoEPReduce&lt; EOT &gt;</a></td><td class="indexvalue">EP truncation method (some global stochastic tournament + sort) Softer selective pressure than pure truncate </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_e_p_replacement.html">eoEPReplacement&lt; EOT &gt;</a></td><td class="indexvalue">EP type of replacement strategy: first add parents to population, then truncate using EP tournament </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_es_chrom_init.html">eoEsChromInit&lt; EOT &gt;</a></td><td class="indexvalue">Random Es-chromosome initializer (therefore derived from <a class="el" href="classeo_init.html">eoInit</a>) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_es_full.html">eoEsFull&lt; Fit &gt;</a></td><td class="indexvalue">The most complex evolutionary strategy representation </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_es_global_xover.html">eoEsGlobalXover&lt; EOT &gt;</a></td><td class="indexvalue">Gloabl crossover operator for ES genotypes </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_es_mutate.html">eoEsMutate&lt; EOT &gt;</a></td><td class="indexvalue">ES-style mutation in the large </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_es_mutation_init.html">eoEsMutationInit</a></td><td class="indexvalue">Initialize Mutation operator </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_es_simple.html">eoEsSimple&lt; Fit &gt;</a></td><td class="indexvalue">Simple Evolution Strategy </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_es_standard_xover.html">eoEsStandardXover&lt; EOT &gt;</a></td><td class="indexvalue">Standard (i.e </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_es_stdev.html">eoEsStdev&lt; Fit &gt;</a></td><td class="indexvalue">Evolutionary Strategy with a standard deviation per parameter </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_eval_continue.html">eoEvalContinue&lt; EOT &gt;</a></td><td class="indexvalue">Continues until a number of evaluations has been made </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_eval_func.html">eoEvalFunc&lt; EOT &gt;</a></td><td class="indexvalue">Evaluate: takes one <a class="el" href="class_e_o.html">EO</a> and sets its "fitness" property returning this fitness also </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_eval_func_counter.html">eoEvalFuncCounter&lt; EOT &gt;</a></td><td class="indexvalue">Counts the number of evaluations actually performed, thus checks first if it has to evaluate. </td></tr>
  <tr><td class="indexkey"><a class="el" href="structeo_eval_func_ptr.html">eoEvalFuncPtr&lt; EOT, FitT, FunctionArg &gt;</a></td><td class="indexvalue">EOEvalFuncPtr: This class takes an existing function pointer and converts it into a evaluation function class </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_expansion_mutation.html">eoExpansionMutation&lt; FType, Node &gt;</a></td><td class="indexvalue">EoExpansionMutation --&gt; replace a terminal with a randomly created subtree </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_external_bin_op.html">eoExternalBinOp&lt; F, External, ExternalEO &gt;</a></td><td class="indexvalue">Crossover of external struct, ctor expects a function of the following signature: </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_external_e_o.html">eoExternalEO&lt; Fit, External &gt;</a></td><td class="indexvalue">Definition of an object that allows an external struct to be inserted in <a class="el" href="class_e_o.html">EO</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_external_eval_func.html">eoExternalEvalFunc&lt; F, External, ExternalEO &gt;</a></td><td class="indexvalue">Evaluation of external struct, ctor expects a function of the following signature: </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_external_init.html">eoExternalInit&lt; F, External, ExternalEO &gt;</a></td><td class="indexvalue">Initialization of external struct, ctor expects a function of the following signature: </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_external_mon_op.html">eoExternalMonOp&lt; F, External, ExternalEO &gt;</a></td><td class="indexvalue">Mutation of external struct, ctor expects a function of the following signature: </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_external_quad_op.html">eoExternalQuadOp&lt; F, External, ExternalEO &gt;</a></td><td class="indexvalue">Crossover of external struct, ctor expects a function of the following signature: </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_f.html">eoF&lt; R &gt;</a></td><td class="indexvalue">Basic Function </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_factory.html">eoFactory&lt; EOClass &gt;</a></td><td class="indexvalue"><a class="el" href="class_e_o.html">EO</a> Factory </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_f_d_c_file_snapshot.html">eoFDCFileSnapshot&lt; EOT &gt;</a></td><td class="indexvalue">Specific class for FDCStat monitoring: As I failed to have FDC stat as an <a class="el" href="classeo_stat.html">eoStat</a>, this is the trick to put the 2 <a class="el" href="classeo_param.html">eoParam</a>&lt;std::vector&lt;double&gt; &gt; into a monitor This class does nothing else </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_f_d_c_stat.html">eoFDCStat&lt; EOT &gt;</a></td><td class="indexvalue">The FDC computation - stores the values into eoValueParam&lt;EOT,double&gt; so they can be snapshot by some eoGnuplotSnapshot .. </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_file_monitor.html">eoFileMonitor</a></td><td class="indexvalue">Prints statistics to file </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_file_snapshot.html">eoFileSnapshot</a></td><td class="indexvalue">Prints snapshots of fitnesses to a (new) file every N generations </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_fit_continue.html">eoFitContinue&lt; EOT &gt;</a></td><td class="indexvalue">Fitness continuation: </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_fitness_scaling_select.html">eoFitnessScalingSelect&lt; EOT &gt;</a></td><td class="indexvalue">EoFitnessScalingSelect: select an individual proportional to the linearly scaled fitness that is computed by the private <a class="el" href="classeo_linear_fit_scaling.html">eoLinearFitScaling</a> object </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_fitness_stat.html">eoFitnessStat&lt; EOT, FitT &gt;</a></td><td class="indexvalue">The fitnesses of a whole population, as a vector </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_fl_or1pt_bin_op.html">eoFlOr1ptBinOp&lt; EOT &gt;</a></td><td class="indexvalue">The 1pt crossover (just in case someone wants it some day!) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_fl_or1pt_quad_op.html">eoFlOr1ptQuadOp&lt; EOT &gt;</a></td><td class="indexvalue">The 1pt crossover (just in case someone wants it some day!) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_fl_or_all_atom_bin_op.html">eoFlOrAllAtomBinOp&lt; EOT &gt;</a></td><td class="indexvalue">Bin Crossover using an Atom Crossover that is applied to a ALL components with given rate </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_fl_or_all_atom_quad_op.html">eoFlOrAllAtomQuadOp&lt; EOT &gt;</a></td><td class="indexvalue">Quad Crossover using an Atom Crossover </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_fl_or_all_mutation.html">eoFlOrAllMutation&lt; EOT &gt;</a></td><td class="indexvalue">Applies an atomic mutation to all the components with a given rate </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_fl_or_k_atom_bin_op.html">eoFlOrKAtomBinOp&lt; EOT &gt;</a></td><td class="indexvalue">Bin Crossover using an Atom Crossover that is applied to a FIXED NB of components </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_fl_or_k_atom_quad_op.html">eoFlOrKAtomQuadOp&lt; EOT &gt;</a></td><td class="indexvalue">Quad Crossover using an Atom Crossover that is applied to a FIXED NB of components </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_fl_or_k_mutation.html">eoFlOrKMutation&lt; EOT &gt;</a></td><td class="indexvalue">Applies an atomic mutation to a fixed number of components (1 by default) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_fl_or_uniform_bin_op.html">eoFlOrUniformBinOp&lt; EOT &gt;</a></td><td class="indexvalue">The uniform crossover - exchanges atoms uniformly ! </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_fl_or_uniform_quad_op.html">eoFlOrUniformQuadOp&lt; EOT &gt;</a></td><td class="indexvalue">The uniform crossover - exchanges atoms uniformly ! </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_functor_base.html">eoFunctorBase</a></td><td class="indexvalue">Base class for functors to get a nice hierarchy diagram </td></tr>
  <tr><td class="indexkey"><a class="el" href="structeo_functor_base_1_1binary__function__tag.html">eoFunctorBase::binary_function_tag</a></td><td class="indexvalue">Tag to identify a binary function in compile time function selection functor_category </td></tr>
  <tr><td class="indexkey"><a class="el" href="structeo_functor_base_1_1procedure__tag.html">eoFunctorBase::procedure_tag</a></td><td class="indexvalue">Tag to identify a procedure in compile time function selection functor_category </td></tr>
  <tr><td class="indexkey"><a class="el" href="structeo_functor_base_1_1unary__function__tag.html">eoFunctorBase::unary_function_tag</a></td><td class="indexvalue">Tag to identify a unary function in compile time function selection functor_category </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_functor_store.html">eoFunctorStore</a></td><td class="indexvalue">EoFunctorStore is a class that stores functors that are allocated on the heap </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_g3_replacement.html">eoG3Replacement&lt; EOT &gt;</a></td><td class="indexvalue">EoG3Replacement is an <a class="el" href="classeo_replacement.html">eoReplacement</a>: - no strong elitism (is suppposed to be within a steady-state engine) - choose N (2) parents RANDOMLY - remove them from the parent population - merge offspring and the N removed parents - select best N of this merged population - put them back into parent population </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_gen_continue.html">eoGenContinue&lt; EOT &gt;</a></td><td class="indexvalue">Generational continuator: continues until a number of generations is reached </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_gene_del_chooser.html">eoGeneDelChooser&lt; EOT &gt;</a></td><td class="indexvalue">A helper class for choosing which site to delete </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_general_breeder.html">eoGeneralBreeder&lt; EOT &gt;</a></td><td class="indexvalue">Base class for breeders using generalized operators </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_general_int_bounds.html">eoGeneralIntBounds</a></td><td class="indexvalue">A class that encapsulate all possible <a class="el" href="classeo_int_bounds.html">eoIntBounds</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_general_real_bounds.html">eoGeneralRealBounds</a></td><td class="indexvalue">A class that encapsulate all possible <a class="el" href="classeo_int_bounds.html">eoIntBounds</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_generational_replacement.html">eoGenerationalReplacement&lt; EOT &gt;</a></td><td class="indexvalue">Generational replacement == swap populations </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_gen_op.html">eoGenOp&lt; EOT &gt;</a></td><td class="indexvalue">The base class for General Operators Subclass this operator is you want to define an operator that falls outside of the <a class="el" href="classeo_mon_op.html">eoMonOp</a>, <a class="el" href="classeo_bin_op.html">eoBinOp</a>, <a class="el" href="classeo_quad_op.html">eoQuadOp</a> classification </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_gnuplot.html">eoGnuplot</a></td><td class="indexvalue">Base class for calls to gnuplot </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_gnuplot1_d_monitor.html">eoGnuplot1DMonitor</a></td><td class="indexvalue">Plot <a class="el" href="classeo_stat.html">eoStat</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_gnuplot1_d_snapshot.html">eoGnuplot1DSnapshot</a></td><td class="indexvalue">Plot stats through gnuplot </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_hamming_distance.html">eoHammingDistance&lt; EOT &gt;</a></td><td class="indexvalue">This is a generic class for L1 distance computation: assumes the 2 things are std::vectors of something that is double-castable For bitstrings, this is the Hamming distance </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_hoist_mutation.html">eoHoistMutation&lt; FType, Node &gt;</a></td><td class="indexvalue">EoHoistMutation --&gt; replace the individual with one of its subtree's </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_how_many.html">eoHowMany</a></td><td class="indexvalue">A helper class, to determine a number of individuals from another one Typically, is used in selection / replacement procedures, e.g </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_incrementor.html">eoIncrementor&lt; T &gt;</a></td><td class="indexvalue">EoUpdater that simply increments a counter </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_incrementor_param.html">eoIncrementorParam&lt; T &gt;</a></td><td class="indexvalue">EoUpdater that is an <a class="el" href="classeo_value_param.html">eoValueParam</a> (and thus OWNS its counter) Mandatory for generation counter in make_checkpoint </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_init.html">eoInit&lt; EOT &gt;</a></td><td class="indexvalue">Base (name) class for Initialization of chromosomes, used in a population contructor </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_init_adaptor.html">eoInitAdaptor&lt; EOT &gt;</a></td><td class="indexvalue">EoInitAdaptor changes the place in the hierarchy from <a class="el" href="classeo_init.html">eoInit</a> to <a class="el" href="classeo_mon_op.html">eoMonOp</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_init_fixed_length.html">eoInitFixedLength&lt; EOT &gt;</a></td><td class="indexvalue">Initializer for fixed length representations with a single type </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_init_generator.html">eoInitGenerator&lt; EOT &gt;</a></td><td class="indexvalue">Turning an <a class="el" href="classeo_init.html">eoInit</a> into a generator probably we should only use genrators - and suppress <a class="el" href="classeo_init.html">eoInit</a> ??? MS - July 2001 </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_init_variable_length.html">eoInitVariableLength&lt; EOT &gt;</a></td><td class="indexvalue">Initializer for variable length representations with a single type </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_init_virus.html">eoInitVirus&lt; FitT &gt;</a></td><td class="indexvalue">Initializer for binary chromosome with MGE </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_init_virus1bit.html">eoInitVirus1bit&lt; FitT &gt;</a></td><td class="indexvalue">Inits the virus with one bit to the left set to one </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_inner_exchange_quad_op.html">eoInnerExchangeQuadOp&lt; EOT &gt;</a></td><td class="indexvalue">Crossover using an AtomCrossover </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_int_above_bound.html">eoIntAboveBound</a></td><td class="indexvalue">An eoIntBound bounded from above only </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_int_below_bound.html">eoIntBelowBound</a></td><td class="indexvalue">EoIntBound bounded from below only </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_int_bounds.html">eoIntBounds</a></td><td class="indexvalue">Defines bound classes for real numbers </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_int_interval.html">eoIntInterval</a></td><td class="indexvalue">Fully bounded eoIntBound == interval </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_int_no_bounds.html">eoIntNoBounds</a></td><td class="indexvalue">A default class for unbounded variables </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_invalidate_bin_op.html">eoInvalidateBinOp&lt; EOT &gt;</a></td><td class="indexvalue">One of the invalidator operators </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_invalidate_mon_op.html">eoInvalidateMonOp&lt; EOT &gt;</a></td><td class="indexvalue">One of the invalidator operators </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_invalidate_quad_op.html">eoInvalidateQuadOp&lt; EOT &gt;</a></td><td class="indexvalue">One of the invalidator operators </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_linear_fit_scaling.html">eoLinearFitScaling&lt; EOT &gt;</a></td><td class="indexvalue">An instance of <a class="el" href="classeo_perf2_worth.html">eoPerf2Worth</a> COmputes the linearly scaled fitnesses with given selective pressure Pselect(Best) == pressure/sizePop Pselect(average) == 1.0/sizePop truncate negative values to 0 - </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_linear_random_split.html">eoLinearRandomSplit&lt; EOT &gt;</a></td><td class="indexvalue">Random truncation - linear version </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_linear_truncate.html">eoLinearTruncate&lt; EOT &gt;</a></td><td class="indexvalue">Truncate class that does not sort, but repeatidely kills the worse </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_linear_truncate_split.html">eoLinearTruncateSplit&lt; EOT &gt;</a></td><td class="indexvalue">ReduceSplit class that does not sort, but repeatidely kills the worse </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_mem_pool.html">MemPool</a></td><td class="indexvalue">Pool allocator for the subtree and parse tree classes (homebrew and not compliant to ANSI allocator requirements) (c) copyright Maarten Keijzer 1999, 2000 </td></tr>
  <tr><td class="indexkey"><a class="el" href="classgp__parse__tree_1_1_mem_pool.html">gp_parse_tree::MemPool</a></td><td class="indexvalue">Pool allocator for the subtree and parse tree classes (homebrew and not compliant to ANSI allocator requirements) (c) copyright Maarten Keijzer 1999, 2000 </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_merge.html">eoMerge&lt; Chrom &gt;</a></td><td class="indexvalue">EoMerge: Base class for elitist replacement algorithms </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_merge_reduce.html">eoMergeReduce&lt; EOT &gt;</a></td><td class="indexvalue">EoMergeReduce: abstract replacement strategy that is just an application of an embedded merge, followed by an embedded reduce </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_m_g_g_replacement.html">eoMGGReplacement&lt; EOT &gt;</a></td><td class="indexvalue">EoMGGReplacement is an <a class="el" href="classeo_replacement.html">eoReplacement</a>: - choose N (2) parents RANDOMLY - remove them from the parent population - select best offspring, add to parents - merge (other?) offspring and the N removed parents - select best N-1 of this merged population (detTournament only at the moment) - put them back into parent population </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_minimizing_traits.html">MinimizingTraits</a></td><td class="indexvalue">Test program for Pareto Fitness </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_m_o_fitness_stat.html">eoMOFitnessStat&lt; EOT, PartFitT &gt;</a></td><td class="indexvalue">For multi-objective fitness, we need to translate a stat&lt;vector&lt;double&gt; &gt; into a vector&lt;stat&gt;, so each objective gets a seperate stat </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_mon_clone_op.html">eoMonCloneOp&lt; EOT &gt;</a></td><td class="indexvalue">Mon clone: one argument </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_mon_gen_op.html">eoMonGenOp&lt; EOT &gt;</a></td><td class="indexvalue">Wrapper for <a class="el" href="classeo_mon_op.html">eoMonOp</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_monitor.html">eoMonitor</a></td><td class="indexvalue">The abstract monitor class is a std::vector of parameter pointers </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_mon_op.html">eoMonOp&lt; EOType &gt;</a></td><td class="indexvalue">EoMonOp is the monary operator: genetic operator that takes only one <a class="el" href="class_e_o.html">EO</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_n_d_plus_replacement.html">eoNDPlusReplacement&lt; EOT, WorthT &gt;</a></td><td class="indexvalue">An elitist non-dominated sorted replacement scheme </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_n_d_sorting.html">eoNDSorting&lt; EOT &gt;</a></td><td class="indexvalue">Non dominated sorting, it *is a* std::vector of doubles, the integer part is the rank (to which front it belongs), the fractional part the niching penalty or distance penalty or whatever penalty you want to squeeze into the bits </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_n_d_sorting_1_1_dummy_e_o.html">eoNDSorting&lt; EOT &gt;::DummyEO</a></td><td class="indexvalue">Used in fast nondominated sorting <a class="el" href="classeo_n_d_sorting_1_1_dummy_e_o.html">DummyEO</a> is just a storage place for fitnesses and to store the original index </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_n_d_sorting___i.html">eoNDSorting_I&lt; EOT &gt;</a></td><td class="indexvalue">The original Non Dominated Sorting algorithm from Srinivas and Deb </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_n_d_sorting___i_i.html">eoNDSorting_II&lt; EOT &gt;</a></td><td class="indexvalue">Fast Elitist Non-Dominant Sorting Genetic Algorithm </td></tr>
  <tr><td class="indexkey"><a class="el" href="classnegexp__generator.html">negexp_generator&lt; T &gt;</a></td><td class="indexvalue">The class negexp_generator can be used in the STL generate function to easily generate negative exponential distributed floats and doubles </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_neg_exp_generator.html">eoNegExpGenerator&lt; T &gt;</a></td><td class="indexvalue">The class <a class="el" href="classnegexp__generator.html">negexp_generator</a> can be used in the STL generate function to easily generate negative exponential distributed floats and doubles </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_neg_exp_init.html">eoNegExpInit&lt; T &gt;</a></td><td class="indexvalue">The class <a class="el" href="classnegexp__generator.html">negexp_generator</a> can be used in the STL generate function to easily generate negative exponential distributed floats and doubles </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_node_selector.html">NodeSelector</a></td><td class="indexvalue">Base class for selecting nodes </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_no_elitism.html">eoNoElitism&lt; EOT &gt;</a></td><td class="indexvalue">No elite </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_no_perf2_worth.html">eoNoPerf2Worth&lt; EOT &gt;</a></td><td class="indexvalue">A dummy perf2worth, just in case you need it </td></tr>
  <tr><td class="indexkey"><a class="el" href="classnormal__generator.html">normal_generator&lt; T &gt;</a></td><td class="indexvalue">The class normal_generator can be used in the STL generate function to easily generate gaussian distributed floats and doubles </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_normal_generator.html">eoNormalGenerator&lt; T &gt;</a></td><td class="indexvalue">The class <a class="el" href="classnormal__generator.html">normal_generator</a> can be used in the STL generate function to easily generate gaussian distributed floats and doubles </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_normal_init.html">eoNormalInit&lt; T &gt;</a></td><td class="indexvalue">The class <a class="el" href="classnormal__generator.html">normal_generator</a> can be used in the STL generate function to easily generate gaussian distributed floats and doubles </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_normal_mutation.html">eoNormalMutation&lt; EOT &gt;</a></td><td class="indexvalue">Simple normal mutation of a std::vector of real values </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_normal_vec_mutation.html">eoNormalVecMutation&lt; EOT &gt;</a></td><td class="indexvalue">Simple normal mutation of a std::vector of real values </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_no_select.html">eoNoSelect&lt; EOT &gt;</a></td><td class="indexvalue">EoNoSelect: returns all individual in order WITHOUT USING FITNESS!!! looping back to the beginning when exhasuted </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_n_pts_bit_xover.html">eoNPtsBitXover&lt; Chrom &gt;</a></td><td class="indexvalue">EoNPtsBitXover --&gt; n-point crossover </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_nth_element_fitness_stat.html">eoNthElementFitnessStat&lt; EOT &gt;</a></td><td class="indexvalue">The n_th element fitness in the population (see <a class="el" href="classeo_best_fitness_stat.html">eoBestFitnessStat</a>) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_object.html">eoObject</a></td><td class="indexvalue">EoObject used to be the base class for the whole hierarchy, but this has changed </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_one_fifth_mutation.html">eoOneFifthMutation&lt; EOT &gt;</a></td><td class="indexvalue">Dynamic version: just say it is updatable - and write the <a class="el" href="classeo_one_fifth_mutation.html#a3">update()</a> method! here the 1 fifth rule: count the proportion of successful mutations, and increase sigma if more than threshold (1/5 !) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_one_max.html">eoOneMax&lt; FitT &gt;</a></td><td class="indexvalue">Always write a comment in this format before class definition if you want the class to be documented by Doxygen </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_one_max_eval_func.html">eoOneMaxEvalFunc&lt; EOT &gt;</a></td><td class="indexvalue">Always write a comment in this format before class definition if you want the class to be documented by Doxygen </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_one_max_init.html">eoOneMaxInit&lt; GenotypeT &gt;</a></td><td class="indexvalue">Always write a comment in this format before class definition if you want the class to be documented by Doxygen </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_one_max_mutation.html">eoOneMaxMutation&lt; GenotypeT &gt;</a></td><td class="indexvalue">Always write a comment in this format before class definition if you want the class to be documented by Doxygen </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_one_max_quad_crossover.html">eoOneMaxQuadCrossover&lt; GenotypeT &gt;</a></td><td class="indexvalue">Always write a comment in this format before class definition if you want the class to be documented by Doxygen </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_op.html">eoOp&lt; EOType &gt;</a></td><td class="indexvalue">Abstract data types for <a class="el" href="class_e_o.html">EO</a> operators </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_op_container.html">eoOpContainer&lt; EOT &gt;</a></td><td class="indexvalue">EoOpContainer is a base class for the sequential and proportional selectors It takes care of wrapping the other operators, and deleting stuff that it has allocated </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_op_sel_mason.html">eoOpSelMason&lt; eoClass &gt;</a></td><td class="indexvalue"><a class="el" href="class_e_o.html">EO</a> Mason, or builder, for operator selectors </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_param.html">eoParam</a></td><td class="indexvalue">EoParam: Base class for monitoring and parsing parameters </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_parameter_loader.html">eoParameterLoader</a></td><td class="indexvalue">Parameter saving and loading </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_param_param_type.html">eoParamParamType</a></td><td class="indexvalue">Another helper class for parsing parameters like Keyword(arg1, arg2, ...) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_pareto_fitness.html">eoParetoFitness&lt; FitnessTraits &gt;</a></td><td class="indexvalue">EoParetoFitness class: std::vector of doubles with overloaded comparison operators </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_pareto_fitness_traits.html">eoParetoFitnessTraits</a></td><td class="indexvalue">EoFitnessTraits: a traits class to specify the number of objectives and which one are maximizing or not See test/t-eoParetoFitness for its use </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_pareto_one_constraint_fitness.html">eoParetoOneConstraintFitness&lt; FitnessTraits &gt;</a></td><td class="indexvalue">EoParetoOneConstraintFitness class: std::vector of doubles + constraint value </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_pareto_ranking.html">eoParetoRanking&lt; EOT &gt;</a></td><td class="indexvalue">Straightforward pareto ranking </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_parser.html">eoParser</a></td><td class="indexvalue">EoParser: command line parser and configuration file reader This class is persistent, so it can be stored and reloaded to restore parameter settings </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_parse_tree.html">eoParseTree&lt; FType, Node &gt;</a></td><td class="indexvalue">Implementation of parse-tree for genetic programming </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_parse_tree_depth_init.html">eoParseTreeDepthInit&lt; FType, Node &gt;</a></td><td class="indexvalue">EoParseTreeDepthInit : the initializer class for <a class="el" href="classeo_parse_tree.html">eoParseTree</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_p_b_i_l_additive.html">eoPBILAdditive&lt; EOT &gt;</a></td><td class="indexvalue">Distribution Class for PBIL algorithm (Population-Based Incremental Learning, Baluja and Caruana 96) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_p_b_i_l_distrib.html">eoPBILDistrib&lt; EOT &gt;</a></td><td class="indexvalue">Distribution Class for PBIL algorithm (Population-Based Incremental Learning, Baluja and Caruana 96) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_p_b_i_l_org.html">eoPBILOrg&lt; EOT &gt;</a></td><td class="indexvalue">Distribution Class for PBIL algorithm (Population-Based Incremental Learning, Baluja and Caruana 95) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_perf2_worth.html">eoPerf2Worth&lt; EOT, WorthT &gt;</a></td><td class="indexvalue">Base class to transform raw fitnesses into fitness for selection </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_perf2_worth_1_1compare__worth.html">eoPerf2Worth&lt; EOT, WorthT &gt;::compare_worth</a></td><td class="indexvalue">Helper class used to sort indices into populations/worths </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_perf2_worth_cached.html">eoPerf2WorthCached&lt; EOT, WorthT &gt;</a></td><td class="indexvalue">Perf2Worth with fitness cache </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_perf2_worth_cached_1_1compare__worth.html">eoPerf2WorthCached&lt; EOT, WorthT &gt;::compare_worth</a></td><td class="indexvalue">Helper class used to sort indices into populations/worths </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_persistent.html">eoPersistent</a></td><td class="indexvalue">An persistent object that knows how to write (through functions inherited from <a class="el" href="classeo_printable.html">eoPrintable</a>#) and read itself </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_plus.html">eoPlus&lt; EOT &gt;</a></td><td class="indexvalue">Very elitist class, copies entire population into next gen </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_plus_replacement.html">eoPlusReplacement&lt; EOT &gt;</a></td><td class="indexvalue">ES type of replacement strategy: first add parents to population, then truncate </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_point_mutation.html">eoPointMutation&lt; FType, Node &gt;</a></td><td class="indexvalue">EoPointMutation --&gt; replace a Node with a Node of the same arity </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_pop.html">eoPop&lt; EOT &gt;</a></td><td class="indexvalue">A std::vector of <a class="el" href="class_e_o.html">EO</a> object, to be used in all algorithms (selectors, operators, replacements, ...) </td></tr>
  <tr><td class="indexkey"><a class="el" href="structeo_pop_1_1_cmp.html">eoPop&lt; EOT &gt;::Cmp</a></td><td class="indexvalue">Helper struct for comparing on pointers </td></tr>
  <tr><td class="indexkey"><a class="el" href="structeo_pop_1_1_ref.html">eoPop&lt; EOT &gt;::Ref</a></td><td class="indexvalue">Helper struct for getting a pointer </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_pop_algo.html">eoPopAlgo&lt; EOT &gt;</a></td><td class="indexvalue">For all "population transforming" algos .. </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_pop_eval_func.html">eoPopEvalFunc&lt; EOT &gt;</a></td><td class="indexvalue">EoPopEvalFunc: This abstract class is for GLOBAL evaluators of a population after variation </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_pop_loop_eval.html">eoPopLoopEval&lt; EOT &gt;</a></td><td class="indexvalue">EoPopLoopEval: an instance of <a class="el" href="classeo_pop_eval_func.html">eoPopEvalFunc</a> that simply applies a private <a class="el" href="classeo_eval_func.html">eoEvalFunc</a> to all offspring </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_pop_stat.html">eoPopStat&lt; EOT &gt;</a></td><td class="indexvalue">Thanks to MS/VC++, <a class="el" href="classeo_param.html">eoParam</a> mechanism is unable to handle std::vectors of stats </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_populator.html">eoPopulator&lt; EOT &gt;</a></td><td class="indexvalue">EoPopulator is a helper class for general operators <a class="el" href="classeo_gen_op.html">eoGenOp</a> It is an <a class="el" href="classeo_pop.html">eoPop</a> but also behaves like an eoPop::iterator as far as operator* and operator++ are concerned </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_printable.html">eoPrintable</a></td><td class="indexvalue">Base class for objects that can print themselves (<a class="el" href="classeo_printable.html#a1">printOn</a>#) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_procedure_counter.html">eoProcedureCounter&lt; Procedure &gt;</a></td><td class="indexvalue">Generic counter class that counts the number of times a procedure is used </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_prop_combined_bin_op.html">eoPropCombinedBinOp&lt; EOT &gt;</a></td><td class="indexvalue">COmbined Binary genetic operator: operator() has two operands, only the first one can be modified </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_prop_combined_mon_op.html">eoPropCombinedMonOp&lt; EOT &gt;</a></td><td class="indexvalue">EoMonOp is the monary operator: genetic operator that takes only one <a class="el" href="class_e_o.html">EO</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_prop_combined_quad_op.html">eoPropCombinedQuadOp&lt; EOT &gt;</a></td><td class="indexvalue">Combined quad genetic operator: operator() has two operands, both can be modified </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_prop_g_a_gen_op.html">eoPropGAGenOp&lt; EOT &gt;</a></td><td class="indexvalue">*************************************************************************** eoPropGAGenOp (for Simple GA, but Proportional) choice between Crossover, mutation or cloining with respect to given relatve weights </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_proportional_op.html">eoProportionalOp&lt; EOT &gt;</a></td><td class="indexvalue">The proportional versions: easy! </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_proportional_select.html">eoProportionalSelect&lt; EOT &gt;</a></td><td class="indexvalue">EoProportionalSelect: select an individual proportional to her stored fitness value </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_quad2_bin_op.html">eoQuad2BinOp&lt; EOT &gt;</a></td><td class="indexvalue">Turning an <a class="el" href="classeo_quad_op.html">eoQuadOp</a> into an <a class="el" href="classeo_bin_op.html">eoBinOp</a>: simply don't touch the second arg! </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_quad_clone_op.html">eoQuadCloneOp&lt; EOT &gt;</a></td><td class="indexvalue">Quad clone: two operands, both could be modified - but are not! </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_quad_distance.html">eoQuadDistance&lt; EOT &gt;</a></td><td class="indexvalue">This is a generic class for Euclidain distance (L2 norm) computation: assumes the 2 things are std::vectors of something that is double-castable </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_quad_gen_op.html">eoQuadGenOp&lt; EOT &gt;</a></td><td class="indexvalue">Wrapper for quadop: easy as pie </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_quad_op.html">eoQuadOp&lt; EOType &gt;</a></td><td class="indexvalue">Quad genetic operator: subclasses <a class="el" href="classeo_op.html">eoOp</a>, and defines basically the operator() with two operands, both can be modified </td></tr>
  <tr><td class="indexkey"><a class="el" href="classrandom__generator.html">random_generator&lt; T &gt;</a></td><td class="indexvalue">The class random_generator can be used in the STL generate function to easily generate random ints either between [0, _max) if only one value (_max) is given to the ctor or in [_min,_max) if 2 values are given (_min, _max) </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_random_node_selector.html">RandomNodeSelector</a></td><td class="indexvalue">Select nodes uniformly </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_random_reduce.html">eoRandomReduce&lt; EOT &gt;</a></td><td class="indexvalue">Random truncation </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_random_select.html">eoRandomSelect&lt; EOT &gt;</a></td><td class="indexvalue">EoRandomSelect: a selection method that selects ONE individual randomly </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_random_split.html">eoRandomSplit&lt; EOT &gt;</a></td><td class="indexvalue">Random truncation - batch version </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_ranking.html">eoRanking&lt; EOT &gt;</a></td><td class="indexvalue">An instance of eoPerfFromWorth COmputes the ranked fitness: fitnesses range in [m,M] with m=2-pressure/popSize and M=pressure/popSize </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_ranking_select.html">eoRankingSelect&lt; EOT &gt;</a></td><td class="indexvalue">EoRankingSelect: select an individual by roulette wheel on its rank is an <a class="el" href="classeo_roulette_worth_select.html">eoRouletteWorthSelect</a>, i.e </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_real.html">eoReal&lt; FitT &gt;</a></td><td class="indexvalue">EoReal: implementation of simple real-valued chromosome </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_real_above_bound.html">eoRealAboveBound</a></td><td class="indexvalue">An eoRealBound bounded from above only </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_real_base_vector_bounds.html">eoRealBaseVectorBounds</a></td><td class="indexvalue">Vector type for bounds (see <a class="el" href="eo_real_bounds_8h.html">eoRealBounds.h</a> for scalar types) ------------ Class <a class="el" href="classeo_real_vector_bounds.html">eoRealVectorBounds</a> implements the std::vectorized version: it is basically a std::vector of <a class="el" href="classeo_real_bounds.html">eoRealBounds</a> * and forwards all request to the elements of the std::vector </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_real_below_bound.html">eoRealBelowBound</a></td><td class="indexvalue">EoRealBound bounded from below only </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_real_bounds.html">eoRealBounds</a></td><td class="indexvalue">Defines bound classes for real numbers </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_real_init_bounded.html">eoRealInitBounded&lt; EOT &gt;</a></td><td class="indexvalue">Simple initialization for any EOT that derives from std::vector&lt;double&gt; uniformly in some bounds </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_real_interval.html">eoRealInterval</a></td><td class="indexvalue">Fully bounded eoRealBound == interval </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_real_no_bounds.html">eoRealNoBounds</a></td><td class="indexvalue">A default class for unbounded variables </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_real_ux_over.html">eoRealUxOver</a></td><td class="indexvalue">EoRealUxOver --&gt; Uniform crossover, also termed intermediate crossover </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_real_vector_bounds.html">eoRealVectorBounds</a></td><td class="indexvalue">Now a derived class, for parser reading It holds some of the bounds (and destroy them when dying) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_real_vector_no_bounds.html">eoRealVectorNoBounds</a></td><td class="indexvalue"><a class="el" href="struct_dummy.html">Dummy</a> unbounded <a class="el" href="classeo_real_vector_bounds.html">eoRealVectorBounds</a>: usefull if you don't need bounds! everything is inlined </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_reduce.html">eoReduce&lt; EOT &gt;</a></td><td class="indexvalue">EoReduce: .reduce the new generation to the specified size At the moment, limited to truncation - with 2 different methods, one that sorts the whole population, and one that repeatidely kills the worst </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_reduce_merge.html">eoReduceMerge&lt; EOT &gt;</a></td><td class="indexvalue">EoReduceMerge: Replacement strategies that start by reducing the parents, then merge with the offspring </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_reduce_merge_reduce.html">eoReduceMergeReduce&lt; EOT &gt;</a></td><td class="indexvalue">EoReduceMergeReduce is an <a class="el" href="classeo_replacement.html">eoReplacement</a>: - saves possible elite parents - reduces rest of parents - reduces offspring - merges reduced populations - reduces resulting merged pop if necessary </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_reduce_split.html">eoReduceSplit&lt; EOT &gt;</a></td><td class="indexvalue">EoReduceSplit: reduce the pop to the specified size AND eventually returns the eliminated guys </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_replacement.html">eoReplacement&lt; EOT &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_rnd_generator.html">eoRndGenerator&lt; T &gt;</a></td><td class="indexvalue">By popular demand re-introducing a base class for a family of random number generators </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_rng.html">eoRng</a></td><td class="indexvalue">Random Number Generator </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_roulette_worth_select.html">eoRouletteWorthSelect&lt; EOT, WorthT &gt;</a></td><td class="indexvalue">An instance of eoSelectPerf2Worth that does selection from the Worthes using a .. </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_scalar_fitness.html">eoScalarFitness&lt; ScalarType, Compare &gt;</a></td><td class="indexvalue">EoScalarFitness&lt;ScalarType, Compare = less&lt;ScalarType&gt; &gt;: Wraps a scalar fitness values such as a double or int, with the option of maximizing (using less&lt;ScalarType&gt;) or minimizing (using greater&lt;ScalarType&gt;) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_scalar_fitness_assembled.html">eoScalarFitnessAssembled&lt; ScalarType, Compare, FitnessTraits &gt;</a></td><td class="indexvalue">Implements fitness as std::vector, storing all values that might occur during fitness assembly </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_scalar_fitness_assembled_traits.html">eoScalarFitnessAssembledTraits</a></td><td class="indexvalue">Defines properties of <a class="el" href="classeo_scalar_fitness_assembled.html">eoScalarFitnessAssembled</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_scalar_fitness_stat.html">eoScalarFitnessStat&lt; EOT, FitT &gt;</a></td><td class="indexvalue">The fitnesses of a whole population, as a std::vector </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_second_moment_stats.html">eoSecondMomentStats&lt; EOT &gt;</a></td><td class="indexvalue">Average fitness + Std </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_segment_crossover.html">eoSegmentCrossover&lt; EOT &gt;</a></td><td class="indexvalue">EoSegmentCrossover --&gt; uniform choice in segment == arithmetical with same value along all coordinates </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_sel_bin_gen_op.html">eoSelBinGenOp&lt; EOT &gt;</a></td><td class="indexvalue">Wrapper for <a class="el" href="classeo_bin_op.html">eoBinOp</a> with a selector </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_select.html">eoSelect&lt; EOT &gt;</a></td><td class="indexvalue">EoSelect selects a number of individuals from the first argument and puts it in the second </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_select_factory.html">eoSelectFactory&lt; EOT &gt;</a></td><td class="indexvalue"><a class="el" href="class_e_o.html">EO</a> Factory.An instance of the factory class to create selectors, that is, <a class="el" href="classeo_select.html">eoSelect</a> objects </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_select_from_worth.html">eoSelectFromWorth&lt; EOT, WorthType &gt;</a></td><td class="indexvalue">Selects one element from a population (is an <a class="el" href="classeo_select_one.html">eoSelectOne</a>) but the selection is based on a std::vector of Worth that is different from the fitnesses (e.g </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_selective_populator.html">eoSelectivePopulator&lt; EOT &gt;</a></td><td class="indexvalue">SelectivePopulator an eoPoplator that uses an <a class="el" href="classeo_select_one.html">eoSelectOne</a> to select guys </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_select_many.html">eoSelectMany&lt; EOT &gt;</a></td><td class="indexvalue">EoSelectMany selects many individuals using <a class="el" href="classeo_select_one.html">eoSelectOne</a> as it's mechanism </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_select_number.html">eoSelectNumber&lt; EOT &gt;</a></td><td class="indexvalue">EoSelectNumber selects many individuals using <a class="el" href="classeo_select_one.html">eoSelectOne</a> as it's mechanism </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_select_one.html">eoSelectOne&lt; EOT, WorthT &gt;</a></td><td class="indexvalue">EoSelectOne selects only one element from a whole population </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_select_perc.html">eoSelectPerc&lt; EOT &gt;</a></td><td class="indexvalue">EoSelectPerc selects many individuals using <a class="el" href="classeo_select_one.html">eoSelectOne</a> as it's mechanism </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_select_transform.html">eoSelectTransform&lt; EOT &gt;</a></td><td class="indexvalue">Embedded select, followed by an embedded transform </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_seq_populator.html">eoSeqPopulator&lt; EOT &gt;</a></td><td class="indexvalue">SeqPopulator: an <a class="el" href="classeo_populator.html">eoPopulator</a> that sequentially goes through the population is supposed to be used after a batch select of a whole bunch or genitors </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_sequential_op.html">eoSequentialOp&lt; EOT &gt;</a></td><td class="indexvalue">Sequential selection: note the mark, rewind, unmark cycle here operators are repeatedly applied on the same individual(s) not all too elegant, but it sort of works.. </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_sequential_select.html">eoSequentialSelect&lt; EOT &gt;</a></td><td class="indexvalue">All Individuals in order </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_s_g_a.html">eoSGA&lt; EOT &gt;</a></td><td class="indexvalue">The Simple Genetic Algorithm, following Holland and Goldberg </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_s_g_a_gen_op.html">eoSGAGenOp&lt; EOT &gt;</a></td><td class="indexvalue">*************************************************************************** eoSGAGenOp (for Simple GA) mimicks the usual crossover with proba pCross + mutation with proba pMut inside an eoGeneralOp It does it exactly as class <a class="el" href="classeo_s_g_a_transform.html">eoSGATransform</a>, i.e </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_s_g_a_transform.html">eoSGATransform&lt; EOT &gt;</a></td><td class="indexvalue">EoSGATransform: transforms a population using genetic operators </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_sharing.html">eoSharing&lt; EOT &gt;</a></td><td class="indexvalue">Sharing is a perf2worth class that implements Goldberg and Richardson's basic sharing see <a class="el" href="classeo_sharing_select.html">eoSharingSelect</a> for how to use it and test/t-eoSharing.cpp for a sample use of both </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_sharing_select.html">eoSharingSelect&lt; EOT &gt;</a></td><td class="indexvalue">EoSharingSelect: select an individual by roulette wheel on its SHARED fitness </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_simple_e_d_a.html">eoSimpleEDA&lt; EOT &gt;</a></td><td class="indexvalue">EoSimpleEDA: a very simple Estimation of Distribution Algorithm </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_sorted_pop_stat.html">eoSortedPopStat&lt; EOT &gt;</a></td><td class="indexvalue">Thanks to MS/VC++, <a class="el" href="classeo_param.html">eoParam</a> mechanism is unable to handle std::vectors of stats </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_sorted_stat.html">eoSortedStat&lt; EOT, ParamType &gt;</a></td><td class="indexvalue">The actual class that will be used as base for all statistics that need to be calculated over the sorted population It's an <a class="el" href="classeo_sorted_stat_base.html">eoSortedStatBase</a> AND an <a class="el" href="classeo_value_param.html">eoValueParam</a> so it can be used in Monitors </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_sorted_stat_base.html">eoSortedStatBase&lt; EOT &gt;</a></td><td class="indexvalue">Base class for statistics calculated over a sorted snapshot of the population </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_s_s_g_a_det_tournament_replacement.html">eoSSGADetTournamentReplacement&lt; EOT &gt;</a></td><td class="indexvalue">SSGA deterministic tournament replacement </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_s_s_g_a_stoch_tournament_replacement.html">eoSSGAStochTournamentReplacement&lt; EOT &gt;</a></td><td class="indexvalue">SSGA stochastic tournament replacement </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_s_s_g_a_worse_replacement.html">eoSSGAWorseReplacement&lt; EOT &gt;</a></td><td class="indexvalue">SSGA replace worst </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_stat.html">eoStat&lt; EOT, T &gt;</a></td><td class="indexvalue">The actual class that will be used as base for all statistics that need to be calculated over the (unsorted) population It is an <a class="el" href="classeo_stat_base.html">eoStatBase</a> AND an <a class="el" href="classeo_value_param.html">eoValueParam</a> so it can be used in Monitors </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_stat_base.html">eoStatBase&lt; EOT &gt;</a></td><td class="indexvalue">Base class for all statistics that need to be calculated over the (unsorted) population (I guess it is not really necessary? MS </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_state.html">eoState</a></td><td class="indexvalue">EoState can be used to register derivants of <a class="el" href="classeo_persistent.html">eoPersistent</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="structeo_state_1_1loading__error.html">eoState::loading_error</a></td><td class="indexvalue">Loading error thrown when nothing seems to work </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_st_branch_mutation.html">eoStBranchMutation&lt; FType, Node &gt;</a></td><td class="indexvalue">EoStBranchMutation --&gt; replace a strongly typed subtree with a randomly created strongly typed subtree </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_stdout_monitor.html">eoStdoutMonitor</a></td><td class="indexvalue">Prints statistics to stdout </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_steady_fit_continue.html">eoSteadyFitContinue&lt; EOT &gt;</a></td><td class="indexvalue">A continuator: does a minimum number of generations, then stops whenever a given number of generations takes place without improvement </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_st_hoist_mutation.html">eoStHoistMutation&lt; FType, Node &gt;</a></td><td class="indexvalue">EoStHoistMutation --&gt; replace the individual with one of its strongly typed subtree's </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_s_t_l_b_f.html">eoSTLBF&lt; A1, A2, R &gt;</a></td><td class="indexvalue">Generic set of classes that wrap an <a class="el" href="classeo_f.html">eoF</a>, <a class="el" href="classeo_u_f.html">eoUF</a> or <a class="el" href="classeo_b_f.html">eoBF</a> so that they have the copy semantics the STL functions usually require (i.e </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_s_t_l_f.html">eoSTLF&lt; R &gt;</a></td><td class="indexvalue">Generic set of classes that wrap an <a class="el" href="classeo_f.html">eoF</a>, <a class="el" href="classeo_u_f.html">eoUF</a> or <a class="el" href="classeo_b_f.html">eoBF</a> so that they have the copy semantics the STL functions usually require (i.e </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_s_t_l_u_f.html">eoSTLUF&lt; A1, R &gt;</a></td><td class="indexvalue">Generic set of classes that wrap an <a class="el" href="classeo_f.html">eoF</a>, <a class="el" href="classeo_u_f.html">eoUF</a> or <a class="el" href="classeo_b_f.html">eoBF</a> so that they have the copy semantics the STL functions usually require (i.e </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_stochastic_universal_select.html">eoStochasticUniversalSelect&lt; EOT &gt;</a></td><td class="indexvalue">EoStochasticUniversalSelect: select an individual proportional to her stored fitness value, but in contrast with eoStochasticUniversalSelect, get rid of most finite sampling effects by doing all selections in one go, using a single random number </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_stoch_tournament_select.html">eoStochTournamentSelect&lt; EOT &gt;</a></td><td class="indexvalue">EoStochTournamentSelect: a selection method that selects ONE individual by binary stochastic tournament -MS- 24/10/99 </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_stoch_tournament_truncate.html">eoStochTournamentTruncate&lt; EOT &gt;</a></td><td class="indexvalue">Truncate class based on a repeated deterministic (reverse!) tournament To be used in SSGA-like replacements (e.g </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_stoch_tournament_truncate_split.html">eoStochTournamentTruncateSplit&lt; EOT &gt;</a></td><td class="indexvalue">ReduceSplit class based on a repeated deterministic (reverse!) tournament To be used in SSGA-like replacements (e.g </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_stoch_tournament_worth_select.html">eoStochTournamentWorthSelect&lt; EOT, WorthT &gt;</a></td><td class="indexvalue">An instance of eoSelectPerf2Worth that does selection from the Worthes using a .. </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_st_parse_tree_depth_init.html">eoStParseTreeDepthInit&lt; FType, Node &gt;</a></td><td class="indexvalue">EoStParseTreeDepthInit : the initializer class for strongly typed tree-based genetic programming </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_st_point_mutation.html">eoStPointMutation&lt; FType, Node &gt;</a></td><td class="indexvalue">EoStPointMutation --&gt; replace a Node with a Node of the same arity and type </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_string.html">eoString&lt; fitnessT &gt;</a></td><td class="indexvalue">Adaptor that turns an STL std::string into an <a class="el" href="class_e_o.html">EO</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_st_subtree_x_over.html">eoStSubtreeXOver&lt; FType, Node &gt;</a></td><td class="indexvalue">EoStSubtreeXOver --&gt; subtree xover for strongly typed tree-based genetic programming </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_subtree_x_over.html">eoSubtreeXOver&lt; FType, Node &gt;</a></td><td class="indexvalue">EoSubtreeXOver --&gt; subtree xover </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_survive_and_die.html">eoSurviveAndDie&lt; EOT &gt;</a></td><td class="indexvalue">EoSurviveAndDie A pure abstract class, to store the howmany's </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_sym_init.html">eoSymInit&lt; EoType &gt;</a></td><td class="indexvalue">Default initializer, Koza style </td></tr>
  <tr><td class="indexkey"><a class="el" href="struct_t__pickle__suite.html">T_pickle_suite&lt; T &gt;</a></td><td class="indexvalue">Implements pickle support for <a class="el" href="classeo_persistent.html">eoPersistent</a> derivatives </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_time_counter.html">eoTimeCounter</a></td><td class="indexvalue">An <a class="el" href="classeo_stat.html">eoStat</a> that simply gives the user time since first generation It has to be tempatized by EOT because it must be an <a class="el" href="classeo_stat.html">eoStat</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_timed_dyn_update.html">eoTimedDynUpdate</a></td><td class="indexvalue">An <a class="el" href="classeo_updater.html">eoUpdater</a> to update an <a class="el" href="classeo_updatable.html">eoUpdatable</a> object every given time interval </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_timed_monitor.html">eoTimedMonitor</a></td><td class="indexvalue">Holds a collection of monitors and only fires them when a time limit has been reached </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_timed_state_saver.html">eoTimedStateSaver</a></td><td class="indexvalue">EoUpdater that saves a state every given time interval </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_time_varying_loop_eval.html">eoTimeVaryingLoopEval&lt; EOT &gt;</a></td><td class="indexvalue">EoPopLoopEval: an instance of <a class="el" href="classeo_pop_eval_func.html">eoPopEvalFunc</a> that simply applies a private <a class="el" href="classeo_eval_func.html">eoEvalFunc</a> to all offspring AND ALL PARENTS as the fitness is supposed here to vary </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_transform.html">eoTransform&lt; EOT &gt;</a></td><td class="indexvalue">EoTransform transforms a population by applying genetic operators on it </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_truncate.html">eoTruncate&lt; EOT &gt;</a></td><td class="indexvalue">Truncation method using sort </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_truncated_select_many.html">eoTruncatedSelectMany&lt; EOT &gt;</a></td><td class="indexvalue">EoTruncatedSelectMany selects many individuals using <a class="el" href="classeo_select_one.html">eoSelectOne</a> as it's mechanism </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_truncated_select_one.html">eoTruncatedSelectOne&lt; EOT &gt;</a></td><td class="indexvalue">EoTruncatedSelectOne selects one individual using <a class="el" href="classeo_select_one.html">eoSelectOne</a> as it's mechanism </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_truncate_split.html">eoTruncateSplit&lt; EOT &gt;</a></td><td class="indexvalue">Deterministic truncation method using sort </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_trunc_select.html">eoTruncSelect&lt; EOT &gt;</a></td><td class="indexvalue">EoTruncSelect selects individuals after truncating the population using <a class="el" href="classeo_select_one.html">eoSelectOne</a> as it's mechanism </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_u_bit_xover.html">eoUBitXover&lt; Chrom &gt;</a></td><td class="indexvalue">EoUBitXover --&gt; classic Uniform crossover </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_u_f.html">eoUF&lt; A1, R &gt;</a></td><td class="indexvalue">Basic Unary Functor </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_u_f__random__generator.html">UF_random_generator&lt; T &gt;</a></td><td class="indexvalue">Another class <a class="el" href="classrandom__generator.html">random_generator</a> that can be used in the STL random_shuffle function (see <a class="el" href="classeo_pop.html#a7">eoPop::shuffle</a>): its operator() takes an unsigned argument m and must return an unsigned uniformly distributed in [0,m} </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_unary_functor_counter.html">eoUnaryFunctorCounter&lt; UnaryFunctor &gt;</a></td><td class="indexvalue">Generic counter class that counts the number of times a unary function is used </td></tr>
  <tr><td class="indexkey"><a class="el" href="classuniform__generator.html">uniform_generator&lt; T &gt;</a></td><td class="indexvalue">The class uniform_generator can be used in the STL generate function to easily generate random floats and doubles either in [0, _max) if only 1 value (_max) is given (or none, as _max defaults to 1.0) or in [_min,_max) if 2 values are given (_min, _max) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_uniform_atom_exchange.html">eoUniformAtomExchange&lt; Atom &gt;</a></td><td class="indexvalue">Uniform crossover - well, not really, efficient for FixedLength </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_uniform_gene_chooser.html">eoUniformGeneChooser&lt; EOT &gt;</a></td><td class="indexvalue">Uniform choice of gene to delete </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_uniform_generator.html">eoUniformGenerator&lt; T &gt;</a></td><td class="indexvalue">The class eoUniform can be used in the STL generate function to easily generate random floats and doubles </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_uniform_init.html">eoUniformInit&lt; T &gt;</a></td><td class="indexvalue">The class eoUniformInit can be used in the STL apply function to easily randomize floats and doubles </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_uniform_mutation.html">eoUniformMutation&lt; EOT &gt;</a></td><td class="indexvalue">EoUniformMutation --&gt; changes all values of the std::vector by uniform choice with range epsilon with probability p_change per variable </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_updatable.html">eoUpdatable</a></td><td class="indexvalue">EoUpdatable is a generic class for adding updatation to an existing class Just says it has an update() method </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_updater.html">eoUpdater</a></td><td class="indexvalue">EoUpdater is a generic procudere for updating whatever you want </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_value_param.html">eoValueParam&lt; ValueType &gt;</a></td><td class="indexvalue">EoValueParam&lt;ValueType&gt;: templatized derivation of <a class="el" href="classeo_param.html">eoParam</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_variable_pareto_traits.html">eoVariableParetoTraits</a></td><td class="indexvalue">EoVariableParetoTraits : an <a class="el" href="classeo_pareto_fitness_traits.html">eoParetoFitnessTraits</a> whose characteristics can be set at run-time (nb objectives and min/max's) Why bother? For didactical purposes (and EASEA implementation :-) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_vector.html">eoVector&lt; FitT, GeneType &gt;</a></td><td class="indexvalue">Base class for fixed length chromosomes, just derives from <a class="el" href="class_e_o.html">EO</a> and std::vector and redirects the smaller than operator to EO (fitness based comparison) </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_virus_bit_flip.html">VirusBitFlip&lt; FitT &gt;</a></td><td class="indexvalue">VirusBitFlip --&gt; changes 1 bit </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_virus_shift_mutation.html">VirusShiftMutation&lt; FitT &gt;</a></td><td class="indexvalue">Works for 1-bit virus; shifts the one to the right or left </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_vl_add_mutation.html">eoVlAddMutation&lt; EOT &gt;</a></td><td class="indexvalue">Addition of a gene Is inserted at a random position - so can be applied to both order-dependent and order-independent </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_vl_atom_exchange_quad_op.html">eoVlAtomExchangeQuadOp&lt; EOT &gt;</a></td><td class="indexvalue">Exchange Crossover using an AtomExchange </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_vl_del_mutation.html">eoVlDelMutation&lt; EOT &gt;</a></td><td class="indexvalue">Deletion of a gene By default at a random position, but a "chooser" can be specified can of course be applied to both order-dependent and order-independent </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_vl_uniform_bin_op.html">eoVlUniformBinOp&lt; EOT &gt;</a></td><td class="indexvalue">Direct Uniform Exchange of genes for Variable Length, BINARY version </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_vl_uniform_quad_op.html">eoVlUniformQuadOp&lt; EOT &gt;</a></td><td class="indexvalue">Direct Uniform Exchange of genes (obsolete, already :-) stays there for historical reasons </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeo_weak_elitist_replacement.html">eoWeakElitistReplacement&lt; EOT &gt;</a></td><td class="indexvalue">EoWeakElitistReplacement: a wrapper for other replacement procedures </td></tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Thu Oct 19 05:06:44 2006 for EO by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
