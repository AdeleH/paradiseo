<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>EO: PyEO.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<div class="nav">
<a class="el" href="dir_000000.html">src</a>&nbsp;/&nbsp;<a class="el" href="dir_000001.html">pyeo</a></div>
<h1>PyEO.h</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment">    PyEO</span>
00003 <span class="comment">    </span>
00004 <span class="comment">    Copyright (C) 2003 Maarten Keijzer</span>
00005 <span class="comment"></span>
00006 <span class="comment">    This program is free software; you can redistribute it and/or modify</span>
00007 <span class="comment">    it under the terms of the GNU General Public License as published by</span>
00008 <span class="comment">    the Free Software Foundation; either version 2 of the License, or</span>
00009 <span class="comment">    (at your option) any later version.</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This program is distributed in the hope that it will be useful,</span>
00012 <span class="comment">    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00013 <span class="comment">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00014 <span class="comment">    GNU General Public License for more details.</span>
00015 <span class="comment"></span>
00016 <span class="comment">    You should have received a copy of the GNU General Public License</span>
00017 <span class="comment">    along with this program; if not, write to the Free Software</span>
00018 <span class="comment">    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
00019 <span class="comment">*/</span>
00020 
00021 <span class="preprocessor">#ifndef PYEO_H</span>
00022 <span class="preprocessor"></span><span class="preprocessor">#define PYEO_H</span>
00023 <span class="preprocessor"></span>
00024 
00025 <span class="preprocessor">#include &lt;string&gt;</span>
00026 <span class="preprocessor">#include &lt;vector&gt;</span>
00027 <span class="preprocessor">#include &lt;exception&gt;</span>
00028 <span class="preprocessor">#include &lt;boost/python.hpp&gt;</span>
00029 
00030 <span class="preprocessor">#include &lt;EO.h&gt;</span>
00031 <span class="keyword">struct </span>index_error : <span class="keyword">public</span> std::exception { 
00032     index_error(std::string w) : what(w) {}; 
00033     <span class="keyword">virtual</span> ~index_error() throw() {}
00034     std::string what; 
00035 };
00036 
00037 <span class="keyword">class </span>PyFitness : <span class="keyword">public</span> boost::python::object
00038 {
00039     <span class="keyword">public</span> :
00040     
00041     <span class="keyword">typedef</span> PyFitness fitness_traits; <span class="comment">// it's its own traits class :-)</span>
00042         
00043     PyFitness() : boost::python::object() {}
00044     
00045     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
00046     PyFitness(<span class="keyword">const</span> T&amp; o) : boost::python::object(o) {}
00047     
00048     <span class="keyword">static</span> <span class="keywordtype">unsigned</span> nObjectives() { <span class="keywordflow">return</span> objective_info.size(); }
00049     <span class="keyword">static</span> <span class="keywordtype">double</span> tol() { <span class="keywordflow">return</span> 1e-6; }
00050     <span class="keyword">static</span> <span class="keywordtype">bool</span> maximizing(<span class="keywordtype">int</span> which) { <span class="keywordflow">return</span> objective_info[which] &gt; 0; }
00051     
00052     <span class="keyword">static</span> <span class="keywordtype">void</span> setObjectivesSize(<span class="keywordtype">int</span> sz) { objective_info.resize(sz, 0); }
00053     <span class="keyword">static</span> <span class="keywordtype">void</span> setObjectivesValue(<span class="keywordtype">unsigned</span> which, <span class="keywordtype">int</span> value)
00054     {
00055         <span class="keywordflow">if</span> (which &gt;= objective_info.size())
00056         {
00057             <span class="keywordflow">throw</span> index_error(<span class="stringliteral">"Too few elements allocated, resize objectives first"</span>);
00058         }
00059 
00060         objective_info[which] = value;
00061     }
00062     
00063     <span class="keyword">static</span> std::vector&lt;int&gt; objective_info;
00064     
00065     <span class="keywordtype">bool</span> dominates(<span class="keyword">const</span> PyFitness&amp; oth) <span class="keyword">const</span>;
00066     
00067     <span class="keywordtype">double</span> operator[](<span class="keywordtype">int</span> i)<span class="keyword"> const </span>
00068 <span class="keyword">    </span>{ 
00069         boost::python::extract&lt;double&gt; x(object::operator[](i)); 
00070     
00071         <span class="keywordflow">if</span> (!x.check())
00072             <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">"PyFitness: does not contain doubles"</span>);
00073         <span class="keywordflow">return</span> x();
00074     }
00075  
00076     <span class="keywordtype">bool</span> operator&lt;(<span class="keyword">const</span> PyFitness&amp; other)<span class="keyword"> const </span>
00077 <span class="keyword">    </span>{ 
00078         <span class="keywordflow">if</span> (objective_info.size() == 0)
00079         {
00080             <span class="keyword">const</span> object&amp; <span class="keyword">self</span> = *<span class="keyword">this</span>;
00081             <span class="keyword">const</span> object&amp; oth = other;
00082             <span class="keywordflow">return</span> <span class="keyword">self</span> &lt; oth;
00083         }
00084         <span class="comment">// otherwise use objective_info</span>
00085     
00086         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; objective_info.size(); ++i)
00087         {
00088             <span class="keywordtype">double</span> a = objective_info[i] * operator[](i);
00089             <span class="keywordtype">double</span> b = objective_info[i] * other[i];
00090 
00091             <span class="keywordflow">if</span> ( fabs(a - b) &gt; tol())
00092             {
00093                 <span class="keywordflow">if</span> (a &lt; b)
00094                     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00095                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
00096             }
00097         }
00098 
00099         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00100     }
00101     
00102     <span class="keywordtype">bool</span> operator&gt;(<span class="keyword">const</span> PyFitness&amp; other)<span class="keyword"> const </span>
00103 <span class="keyword">    </span>{ 
00104         <span class="keywordflow">return</span> other.operator&lt;(*this);
00105     }
00106     
00107     <span class="keywordtype">void</span> printOn(std::ostream&amp; os)<span class="keyword"> const </span>{ <span class="keyword">const</span> boost::python::object&amp; o = *<span class="keyword">this</span>; boost::python::api::operator&lt;&lt;(os,o); }
00108     <span class="keyword">friend</span> std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, <span class="keyword">const</span> PyFitness&amp; p) { p.printOn(os); <span class="keywordflow">return</span> os;  }
00109     <span class="keyword">friend</span> std::istream&amp; operator&gt;&gt;(std::istream&amp; is, PyFitness&amp; p) { boost::python::object o; is &gt;&gt; o; p = o; <span class="keywordflow">return</span> is; }
00110 };
00111 
00112 <span class="keyword">struct </span>PyEO : <span class="keyword">public</span> <a class="code" href="class_e_o.html">EO</a>&lt; PyFitness  &gt;
00113 {  
00114     <span class="keyword">typedef</span> PyFitness Fitness;
00115     
00116     boost::python::object getFitness()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="class_e_o.html#a5">invalid</a>()? Fitness(): <a class="code" href="class_e_o.html#a2">fitness</a>(); }
00117     <span class="keywordtype">void</span> setFitness(boost::python::object f) { <span class="keywordflow">if</span> (f == Fitness()) invalidate(); <span class="keywordflow">else</span> <a class="code" href="class_e_o.html#a2">fitness</a>(f); }
00118 
00119     boost::python::object getGenome()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> genome; }
00120     <span class="keywordtype">void</span> setGenome(boost::python::object g) { genome = g; }
00121     boost::python::object genome;
00122     
00123     std::string to_string()<span class="keyword"> const</span>
00124 <span class="keyword">    </span>{
00125         std::string result;
00126         result += boost::python::extract&lt;const char*&gt;(boost::python::str(getFitness()));
00127         result += <span class="charliteral">' '</span>;
00128         result += boost::python::extract&lt;const char*&gt;(boost::python::str(genome));
00129         <span class="keywordflow">return</span> result;
00130     }
00131 
00132     <span class="keywordtype">bool</span> <a class="code" href="class_e_o.html#a6">operator&lt;</a>(<span class="keyword">const</span> PyEO&amp; other)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="class_e_o.html#a6">EO&lt;Fitness&gt;::operator&lt;</a>(other); }
00133     <span class="keywordtype">bool</span> operator&gt;(<span class="keyword">const</span> PyEO&amp; other)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="class_e_o.html">EO&lt;Fitness&gt;::operator&gt;</a>(other); }
00134 
00135 };
00136 
00137 std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, <span class="keyword">const</span> PyEO&amp; _eo);
00138 
00139 <span class="keyword">struct </span>PyEO_pickle_suite : boost::python::pickle_suite
00140 {
00141     <span class="keyword">typedef</span> PyEO::Fitness Fitness;
00142     
00143     <span class="keyword">static</span>
00144     boost::python::tuple getstate(<span class="keyword">const</span> PyEO&amp; _eo)
00145     {
00146         <span class="keywordflow">return</span> boost::python::make_tuple(_eo.getFitness(), _eo.genome);
00147     }
00148     <span class="keyword">static</span>
00149     <span class="keywordtype">void</span> setstate(PyEO&amp; _eo, boost::python::tuple pickled)
00150     {
00151         _eo.setFitness( Fitness(pickled[0]) );
00152         _eo.genome = pickled[1];
00153     }
00154 };
00155 
00156 <span class="preprocessor">#endif</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Thu Oct 19 05:06:42 2006 for EO by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
