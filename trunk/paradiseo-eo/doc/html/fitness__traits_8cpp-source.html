<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>EO: fitness_traits.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<div class="nav">
<a class="el" href="dir_000002.html">test</a></div>
<h1>fitness_traits.cpp</h1><div class="fragment"><pre class="fragment">00001 <span class="preprocessor">#include &lt;map&gt;</span> <span class="comment">// for pair</span>
00002 <span class="preprocessor">#include &lt;iostream&gt;</span>
00003 <span class="preprocessor">#include &lt;stdexcept&gt;</span>
00004 <span class="preprocessor">#include &lt;vector&gt;</span>
00005 <span class="preprocessor">#include &lt;algorithm&gt;</span>
00006 <span class="preprocessor">#include &lt;math.h&gt;</span> <span class="comment">// for exp</span>
00007 
00008 <span class="keyword">using</span> <span class="keyword">namespace </span>std;
00009 
00010 <span class="comment">/* fitness_traits.h */</span>
00011 
00012 <span class="comment">// default traits: defaults to a double that needs to be maximized</span>
00013 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T = <span class="keywordtype">double</span>&gt;
00014 <span class="keyword">struct </span>fitness_traits
00015 {
00016   <span class="comment">// Needs mapping can be used to figure out whether you need to do fitness scaling (or not)</span>
00017   <span class="keyword">const</span> <span class="keyword">static</span> <span class="keywordtype">bool</span> needs_mapping               = <span class="keyword">false</span>;
00018 
00019   <span class="comment">// storage_type: what to store next to the genotype</span>
00020   <span class="keyword">typedef</span> T storage_type;
00021 
00022   <span class="comment">// performance_type: what the eoEvalFunc calculates</span>
00023   <span class="keyword">typedef</span> T performance_type;
00024 
00025   <span class="comment">// worth_type: what the scaling function does</span>
00026   <span class="keyword">typedef</span> T worth_type;
00027 
00028   <span class="comment">// access_performance: how to get from what is stored to a mutable performance</span>
00029   <span class="keyword">static</span> performance_type&amp; access_performance(storage_type&amp; a) { <span class="keywordflow">return</span> a; }
00030 
00031   <span class="comment">// access_worth: how to get from what is stored to a mutable worth</span>
00032   <span class="keyword">static</span> worth_type&amp;       access_worth(storage_type&amp; a)       { <span class="keywordflow">return</span> a; }
00033 
00034   <span class="comment">// get_performance: from storage_type to a performance figure</span>
00035   <span class="keyword">static</span> performance_type  get_performance(storage_type a) { <span class="keywordflow">return</span> a; }
00036 
00037   <span class="comment">// get_worth: from storage_type to a worth figure</span>
00038   <span class="keyword">static</span> worth_type        get_worth(storage_type a)       { <span class="keywordflow">return</span> a; }
00039 
00040   <span class="comment">// get the fitness out of the individual</span>
00041   <span class="keyword">template</span> &lt;<span class="keyword">class</span> EOT&gt;
00042   <span class="keyword">static</span> worth_type    get_fitness(<span class="keyword">const</span> <a class="code" href="struct_dummy.html">EOT</a>&amp; _eo)       { <span class="keywordflow">return</span> _eo.<a class="code" href="class_e_o.html#a10">performance</a>(); }
00043 
00044   <span class="comment">// compare the two individuals</span>
00045   <span class="keyword">template</span> &lt;<span class="keyword">class</span> EOT&gt;
00046   <span class="keyword">static</span> <span class="keywordtype">bool</span> is_better(<span class="keyword">const</span> <a class="code" href="struct_dummy.html">EOT</a>&amp; _eo1, <span class="keyword">const</span> <a class="code" href="struct_dummy.html">EOT</a>&amp; _eo2)
00047   {
00048     <span class="keywordflow">return</span> _eo1.<a class="code" href="class_e_o.html#a10">performance</a>() &gt; _eo2.<a class="code" href="class_e_o.html#a10">performance</a>();
00049   }
00050 };
00051 
00052 <span class="keyword">struct </span>minimization {};
00053 <span class="keyword">struct </span>maximization {};
00054 
00055 <span class="keyword">struct </span>fitness_traits&lt;minimization&gt; : <span class="keyword">public</span> fitness_traits&lt;double&gt;
00056 {
00057   <span class="comment">// for minimization, invert the is_better</span>
00058   <span class="keyword">template</span> &lt;<span class="keyword">class</span> EOT&gt;
00059   <span class="keyword">static</span> <span class="keywordtype">bool</span> is_better(<span class="keyword">const</span> <a class="code" href="struct_dummy.html">EOT</a>&amp; _eo1, <span class="keyword">const</span> <a class="code" href="struct_dummy.html">EOT</a>&amp; _eo2)
00060   {
00061     <span class="keywordflow">return</span> _eo1.<a class="code" href="class_e_o.html#a10">performance</a>() &lt; _eo2.<a class="code" href="class_e_o.html#a10">performance</a>();
00062   }
00063 };
00064 
00065 <span class="comment">// for maximization, just take the default behaviour</span>
00066 <span class="keyword">struct </span>fitness_traits&lt;maximization&gt; : <span class="keyword">public</span> fitness_traits&lt;double&gt; {};
00067 
00068 <span class="comment">// forward declaration</span>
00069 <span class="comment">//template &lt;class EOT&gt; class eoPop;</span>
00070 <span class="comment">//template &lt;class Fitness, class Traits&gt; class EO;</span>
00071 
00072 <span class="comment">// unfortunately, partial template specialization is not approved by Microsoft (though ANSI says it's ok)</span>
00073 <span class="comment">// Probably need some macro-magic to make this work (MicroSoft == MacroHard)</span>
00074 <span class="comment">// A pair class: first == performance, second == worth, redefine all types, data and functions</span>
00075 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Performance, <span class="keyword">class</span> Worth&gt;
00076 <span class="keyword">struct </span>fitness_traits&lt; pair&lt;Performance, Worth&gt; &gt;
00077 {
00078   <span class="keyword">typedef</span> pair&lt;Performance, Worth&gt; storage_type;
00079   <span class="keyword">typedef</span> Performance performance_type;
00080   <span class="keyword">typedef</span> Worth       worth_type;
00081 
00082   <span class="keyword">const</span> <span class="keyword">static</span> <span class="keywordtype">bool</span> needs_mapping = <span class="keyword">true</span>;
00083 
00084   <span class="keyword">static</span> performance_type&amp; access_performance(storage_type&amp; a)     { <span class="keywordflow">return</span> a.first; }
00085   <span class="keyword">static</span> worth_type&amp;       access_worth(storage_type&amp; a)           { <span class="keywordflow">return</span> a.second; }
00086 
00087   <span class="keyword">static</span> performance_type get_performance(<span class="keyword">const</span> storage_type&amp; a)     { <span class="keywordflow">return</span> a.first; }
00088   <span class="keyword">static</span> worth_type       get_worth(<span class="keyword">const</span> storage_type&amp; a)           { <span class="keywordflow">return</span> a.second; }
00089 
00090   <span class="comment">// This function calls _eo.worth() which in turn checks the fitness flag and calls get_worth above</span>
00091   <span class="comment">// The compiler should be able to inline all these calls and come up with a very compact solution</span>
00092   <span class="keyword">template</span> &lt;<span class="keyword">class</span> EOT&gt;
00093   <span class="keyword">static</span> worth_type    get_fitness(<span class="keyword">const</span> <a class="code" href="struct_dummy.html">EOT</a>&amp; _eo) { <span class="keywordflow">return</span> _eo.<a class="code" href="class_e_o.html#a12">worth</a>(); }
00094 
00095   <span class="keyword">template</span> &lt;<span class="keyword">class</span> EOT&gt;
00096   <span class="keyword">static</span> <span class="keywordtype">bool</span> is_better(<span class="keyword">const</span> <a class="code" href="struct_dummy.html">EOT</a>&amp; _eo1, <span class="keyword">const</span> <a class="code" href="struct_dummy.html">EOT</a>&amp; _eo2)
00097   {
00098     <span class="keywordflow">return</span> _eo1.<a class="code" href="class_e_o.html#a12">worth</a>() &gt; _eo2.<a class="code" href="class_e_o.html#a12">worth</a>();
00099   }
00100 };
00101 
00102 <span class="comment">/* end fitness_traits.h */</span>
00103 
00104 <span class="comment">/* EO.h </span>
00105 <span class="comment"></span>
00106 <span class="comment">The Fitness template argument is there for backward compatibility reasons</span>
00107 <span class="comment"></span>
00108 <span class="comment">*/</span>
00109 
00110 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Fitness, <span class="keyword">class</span> Traits = fitness_traits&lt;Fitness&gt; &gt;
00111 <span class="keyword">class </span>EO
00112 {
00113 <span class="keyword">public</span> :
00114 
00115   <span class="keyword">typedef</span> Traits                            fitness_traits;
00116   <span class="keyword">typedef</span> <span class="keyword">typename</span> Traits::storage_type     storage_type;
00117   <span class="keyword">typedef</span> <span class="keyword">typename</span> Traits::performance_type performance_type;
00118   <span class="keyword">typedef</span> <span class="keyword">typename</span> Traits::worth_type       worth_type;
00119 
00120   EO() : valid_performance(false), valid_worth(false), rep_fitness() {}
00121 
00122   <span class="comment">// for backwards compatibility</span>
00123   <span class="keywordtype">void</span> fitness(performance_type perf)
00124   {
00125     performance(perf);
00126   }
00127 
00128   <span class="keywordtype">void</span> performance(performance_type perf)
00129   {
00130     valid_performance = <span class="keyword">true</span>;
00131     Traits::access_performance(rep_fitness) = perf;
00132   }
00133 
00134   performance_type performance(<span class="keywordtype">void</span>)<span class="keyword"> const</span>
00135 <span class="keyword">  </span>{
00136     <span class="keywordflow">if</span>(!valid_performance) <span class="keywordflow">throw</span> runtime_error(<span class="stringliteral">"no performance"</span>);
00137     <span class="keywordflow">return</span> Traits::get_performance(rep_fitness);
00138   }
00139 
00140   <span class="keywordtype">void</span> worth(worth_type worth)
00141   {
00142     valid_worth = <span class="keyword">true</span>;
00143     Traits::access_worth(rep_fitness) = worth;
00144   }
00145 
00146   worth_type worth(<span class="keywordtype">void</span>)<span class="keyword"> const</span>
00147 <span class="keyword">  </span>{
00148     <span class="keywordflow">if</span>(!valid_worth)  <span class="keywordflow">throw</span> runtime_error(<span class="stringliteral">"no worth"</span>);
00149     <span class="keywordflow">if</span>(!Traits::needs_mapping)  <span class="keywordflow">throw</span> runtime_error(<span class="stringliteral">"no mapping"</span>);
00150     <span class="keywordflow">return</span> Traits::get_worth(rep_fitness);
00151   }
00152 
00153   worth_type fitness(<span class="keywordtype">void</span>)<span class="keyword"> const</span>
00154 <span class="keyword">  </span>{
00155     <span class="keywordflow">return</span> Traits::get_fitness(*<span class="keyword">this</span>);
00156   }
00157 
00158   <span class="keywordtype">void</span> invalidate(<span class="keywordtype">void</span>)
00159   {
00160     valid_performance = <span class="keyword">false</span>;
00161     valid_worth = <span class="keyword">false</span>;
00162   }
00163 
00164   <span class="keywordtype">void</span> invalidate_worth(<span class="keywordtype">void</span>)
00165   {
00166     valid_worth = <span class="keyword">false</span>;
00167   }
00168 
00169   <span class="keywordtype">bool</span> operator&lt;(const EO&lt;Fitness, Traits&gt;&amp; other) <span class="keyword">const</span>
00170   {
00171     <span class="keywordflow">return</span> !Traits::is_better(other, *<span class="keyword">this</span>);
00172   }
00173 
00174   <span class="keywordtype">bool</span> operator&gt;(<span class="keyword">const</span> EO&lt;Fitness, Traits&gt;&amp; other)<span class="keyword"> const</span>
00175 <span class="keyword">  </span>{
00176     <span class="keywordflow">return</span> Traits::is_better(other, *<span class="keyword">this</span>);
00177   }
00178 
00179   <span class="keyword">private</span> :
00180 
00181   <span class="keywordtype">bool</span> valid_performance;
00182   <span class="keywordtype">bool</span> valid_worth;
00183   storage_type rep_fitness;
00184 };
00185 
00186 <span class="comment">/* end EO.h */</span>
00187 
00188 <span class="comment">/* eoPerf2Worth.h */</span>
00189 
00190 <span class="comment">// get the name known</span>
00191 <span class="keyword">template</span> &lt;<span class="keyword">class</span> EOT&gt; <span class="keyword">class </span><a class="code" href="classeo_pop.html">eoPop</a>;
00192 
00193 <span class="keyword">template</span> &lt;<span class="keyword">class</span> EOT&gt;
00194 <span class="keywordtype">void</span> exponential_scaling(<a class="code" href="classeo_pop.html">eoPop&lt;EOT&gt;</a>&amp; _pop)
00195 {
00196     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; _pop.size(); ++i)
00197     { <span class="comment">// change minimimization into maximization</span>
00198       _pop[i].worth(exp(-_pop[i].performance()));
00199     }
00200 }
00201 
00202 <span class="keyword">template</span> &lt;<span class="keyword">class</span> EOT&gt;
00203 <span class="keyword">class </span><a class="code" href="classeo_perf2_worth.html">eoPerf2Worth</a> <span class="comment">/* : public eoUF&lt;eoPop&lt;EOT&gt;&amp;, void&gt; */</span>
00204 {
00205 <span class="keyword">public</span> :
00206   <span class="keyword">virtual</span> <span class="keywordtype">void</span> operator()(<a class="code" href="classeo_pop.html">eoPop&lt;EOT&gt;</a>&amp; _pop)
00207   {
00208     <span class="keywordflow">return</span> exponential_scaling(_pop);
00209   }
00210 };
00211 
00212 <span class="comment">/* end eoPerf2Worth.h */</span>
00213 
00214 
00215 <span class="comment">/* eoPop.h */</span>
00216 
00217 <span class="keyword">template</span> &lt;<span class="keyword">class</span> EOT&gt;
00218 <span class="keyword">class </span><a class="code" href="classeo_pop.html">eoPop</a> : <span class="keyword">public</span> vector&lt;EOT&gt;
00219 {
00220 <span class="keyword">public</span> :
00221 
00222   <span class="keyword">typedef</span> <span class="keyword">typename</span> EOT::fitness_traits fitness_traits;
00223 
00224   <a class="code" href="classeo_pop.html#a0">eoPop</a>(<span class="keywordtype">void</span>) : p2w(0) {}
00225 
00226   <span class="keywordtype">void</span> <a class="code" href="classeo_pop.html#a5">sort</a>()
00227   {
00228     scale(); <span class="comment">// get the worths up to date</span>
00229 
00230     std::sort(begin(), end(), greater&lt;EOT&gt;());
00231   }
00232 
00233   <span class="keywordtype">void</span> scale()
00234   {
00235     <span class="keywordflow">if</span> (p2w)
00236     {
00237       <span class="keywordflow">if</span> (!fitness_traits::needs_mapping)
00238       {
00239         <span class="keywordflow">throw</span> runtime_error(<span class="stringliteral">"eoPop: no scaling needed, yet a scaling function is defined"</span>);
00240       }
00241 
00242       (*p2w)(*this);
00243     }
00244     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (fitness_traits::needs_mapping)
00245     {
00246       <span class="keywordflow">throw</span> runtime_error(<span class="stringliteral">"eoPop: no scaling function attached to the population, while one was certainly called for"</span>);
00247     }
00248   }
00249 
00250   <span class="keywordtype">void</span> setPerf2Worth(<a class="code" href="classeo_perf2_worth.html">eoPerf2Worth&lt;EOT&gt;</a>&amp; _p2w)
00251   {
00252     p2w = &amp;_p2w;
00253   }
00254 
00255   <span class="keywordtype">void</span> setPerf2Worth(<a class="code" href="classeo_perf2_worth.html">eoPerf2Worth&lt;EOT&gt;</a>* _p2w)
00256   {
00257     p2w = _p2w;
00258   }
00259 
00260   <a class="code" href="classeo_perf2_worth.html">eoPerf2Worth&lt;EOT&gt;</a>* getPerf2Worth() { <span class="keywordflow">return</span> p2w; }
00261 
00262   <span class="keywordtype">void</span> <a class="code" href="classeo_pop.html#a16">swap</a>(<a class="code" href="classeo_pop.html">eoPop&lt;EOT&gt;</a>&amp; other)
00263   {
00264     vector&lt;EOT&gt;::swap(other);
00265     <a class="code" href="classeo_perf2_worth.html">eoPerf2Worth&lt;EOT&gt;</a>* tmp = p2w;
00266     p2w = other.<a class="code" href="classeo_pop.html#r0">p2w</a>;
00267     other.<a class="code" href="classeo_pop.html#r0">p2w</a> = tmp;
00268   }
00269 
00270 <span class="keyword">private</span> :
00271 
00272   <span class="comment">// a pointer as it can be emtpy</span>
00273   <a class="code" href="classeo_perf2_worth.html">eoPerf2Worth&lt;EOT&gt;</a>* p2w;
00274 };
00275 
00276 <span class="comment">// need this one to be able to swap the members as well...</span>
00277 <span class="keyword">template</span> &lt;<span class="keyword">class</span> EOT&gt;
00278 <span class="keywordtype">void</span> swap(<a class="code" href="classeo_pop.html">eoPop&lt;EOT&gt;</a>&amp; _p1, <a class="code" href="classeo_pop.html">eoPop&lt;EOT&gt;</a>&amp; _p2)
00279 {
00280   _p1.<a class="code" href="classeo_pop.html#a16">swap</a>(_p2);
00281 }
00282 
00283 <span class="comment">/* end eoPop.h */</span>
00284 
00285 <span class="comment">/* main and test */</span>
00286 
00287 <span class="keyword">template</span> &lt;<span class="keyword">class</span> EOT&gt;
00288 <span class="keywordtype">void</span> algo(<a class="code" href="classeo_pop.html">eoPop&lt;EOT&gt;</a>&amp; _pop)
00289 {
00290   <a class="code" href="classeo_pop.html">eoPop&lt;EOT&gt;</a> offspring;                          <span class="comment">// how to get the scaling info into this guy??</span>
00291   offspring.<a class="code" href="classeo_pop.html#a23">setPerf2Worth</a>(_pop.<a class="code" href="classeo_pop.html#a25">getPerf2Worth</a>()); <span class="comment">// like this!</span>
00292 
00293   std::copy(_pop.begin(), _pop.end(), back_inserter(offspring));
00294 
00295   offspring.<a class="code" href="classeo_pop.html#a5">sort</a>(); <span class="comment">// should call scale</span>
00296 
00297   swap(_pop, offspring);
00298 }
00299 
00300 <span class="keywordtype">void</span> minimization_test()
00301 {
00302   <span class="keyword">typedef</span> EO&lt;minimization&gt; eo_type;
00303 
00304   eo_type eo1;
00305   eo_type eo2;
00306 
00307   eo1.performance(1.0);
00308   eo2.performance(2.0);
00309 
00310   std::cout &lt;&lt; <span class="stringliteral">"With minimizing fitness"</span> &lt;&lt; std::endl;
00311   std::cout &lt;&lt; eo1.fitness() &lt;&lt; <span class="stringliteral">" &lt; "</span> &lt;&lt; eo2.fitness() &lt;&lt; <span class="stringliteral">" returns "</span> &lt;&lt; (eo1 &lt; eo2) &lt;&lt; std::endl;
00312   std::cout &lt;&lt; eo2.fitness() &lt;&lt; <span class="stringliteral">" &lt; "</span> &lt;&lt; eo1.fitness() &lt;&lt; <span class="stringliteral">" returns "</span> &lt;&lt; (eo2 &lt; eo1) &lt;&lt; std::endl;
00313 }
00314 
00315 <span class="keywordtype">void</span> the_main()
00316 {
00317   <span class="keyword">typedef</span> EO&lt;double&gt; simple_eo;
00318   <span class="keyword">typedef</span> EO&lt;pair&lt;double, double&gt; &gt; scaled_eo;
00319 
00320   simple_eo eo1;
00321   simple_eo eo3;
00322 
00323 <span class="comment">/* First test some simple comparisons */</span>
00324 
00325   eo1.fitness(10); <span class="comment">// could also use performance()</span>
00326   eo3.fitness(5);
00327 
00328   std::cout &lt;&lt; eo1.fitness() &lt;&lt; std::endl;
00329   std::cout &lt;&lt; eo3.fitness() &lt;&lt; std::endl;
00330 
00331   std::cout &lt;&lt; <span class="stringliteral">"eo1 &lt; eo3 = "</span> &lt;&lt; (eo1 &lt; eo3) &lt;&lt; std::endl;
00332 
00333 
00334   scaled_eo eo2;
00335   scaled_eo eo4;
00336   eo2.performance(10);
00337   eo4.performance(8);
00338 
00339 <span class="comment">/* Now test if the worth gets accessed and if the flag protects it */</span>
00340 
00341   <span class="keywordflow">try</span>
00342   {
00343     std::cout &lt;&lt; eo2.fitness() &lt;&lt; std::endl;
00344     std::cout &lt;&lt; <span class="stringliteral">"did not throw"</span> &lt;&lt; std::endl;
00345     assert(<span class="keyword">false</span>); <span class="comment">// should throw</span>
00346   }
00347   <span class="keywordflow">catch</span>(std::exception&amp; e)
00348   {
00349     std::cout &lt;&lt; <span class="stringliteral">"Fitness threw exception, as it should"</span> &lt;&lt; std::endl;
00350     std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
00351   }
00352 
00353 <span class="comment">/* Set the worth and all is well (this is normally done by some perf2worth functor */</span>
00354 
00355   eo2.worth(3);
00356   eo4.worth(5);
00357 
00358   std::cout &lt;&lt; <span class="stringliteral">"with maximization "</span> &lt;&lt; std::endl;
00359   std::cout &lt;&lt; eo2.fitness() &lt;&lt; std::endl;
00360   std::cout &lt;&lt; eo4.fitness() &lt;&lt; std::endl;
00361   std::cout &lt;&lt; eo2.fitness() &lt;&lt; <span class="stringliteral">" &lt; "</span> &lt;&lt; eo4.fitness() &lt;&lt; <span class="stringliteral">" returns "</span> &lt;&lt; (eo2 &lt; eo4) &lt;&lt; std::endl;
00362 
00363 <span class="comment">/* Test the minimization of fitness */</span>
00364   minimization_test();
00365 
00366 
00367 <span class="comment">/* Populations */</span>
00368 
00369 <span class="comment">// test pop without scaling, should have no overhead save for a single empty pointer in pop</span>
00370   <a class="code" href="classeo_pop.html">eoPop&lt;simple_eo&gt;</a> pop0;
00371   pop0.resize(1);
00372   pop0[0].fitness(1);
00373 
00374   algo(pop0);
00375 
00376   std::cout &lt;&lt; pop0[0].fitness() &lt;&lt; std::endl;
00377 
00378   assert(pop0[0].fitness() == 1);
00379 
00380 <span class="comment">/* test pop with scaling */</span>
00381 
00382   <a class="code" href="classeo_perf2_worth.html">eoPerf2Worth&lt;scaled_eo&gt;</a> perf2worth;
00383   <a class="code" href="classeo_pop.html">eoPop&lt;scaled_eo&gt;</a> pop1;
00384 
00385   pop1.resize(1);
00386 
00387   pop1[0].fitness(1.0); <span class="comment">// emulate evaluation</span>
00388 
00389     <span class="comment">// at this point getting the fitness should throw</span>
00390   <span class="keywordflow">try</span>
00391   {
00392     std::cout &lt;&lt; pop1[0].fitness() &lt;&lt; std::endl;
00393     std::cout &lt;&lt; <span class="stringliteral">"did not throw"</span> &lt;&lt; std::endl;
00394     assert(<span class="keyword">false</span>); <span class="comment">// should throw</span>
00395   }
00396   <span class="keywordflow">catch</span>(std::exception&amp; e)
00397   {
00398     std::cout &lt;&lt; <span class="stringliteral">"Fitness threw exception, as it should"</span> &lt;&lt; std::endl;
00399     std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
00400   }
00401 
00402   <span class="comment">// at this point trying to scale should throw</span>
00403   <span class="keywordflow">try</span>
00404   {
00405     algo(pop1); <span class="comment">// should complain that it cannot scale</span>
00406     assert(<span class="keyword">false</span>); <span class="comment">// so it would never get here</span>
00407   }
00408   <span class="keywordflow">catch</span>(std::exception&amp; e)
00409   { <span class="comment">// but rather ends here</span>
00410     std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
00411   }
00412 
00413   <span class="comment">// ok, now set the scaling</span>
00414   pop1.<a class="code" href="classeo_pop.html#a23">setPerf2Worth</a>(perf2worth);
00415 
00416   algo(pop1);
00417 
00418   std::cout &lt;&lt; <span class="stringliteral">"the fitness has been transformed from "</span> &lt;&lt; pop1[0].performance() &lt;&lt; <span class="stringliteral">" to exp(-1) = "</span> &lt;&lt; pop1[0].fitness() &lt;&lt; std::endl;
00419 }
00420 
00421 <span class="keywordtype">int</span> main()
00422 {
00423   <span class="keywordflow">try</span>
00424   {
00425     the_main();
00426   }
00427   <span class="keywordflow">catch</span>(std::exception&amp; e)
00428   {
00429     std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
00430   }
00431 }
00432 
00433 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Thu Oct 19 05:06:39 2006 for EO by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
