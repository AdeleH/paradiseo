// -*- mode: c++; c-indent-level: 4; c++-member-init-indent: 8; comment-column: 35; -*-

// "sched_thread.cpp"

// (c) OPAC Team, LIFL, August 2005

/* This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2 of the License, or (at your option) any later version.
   
   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.
   
   You should have received a copy of the GNU Lesser General Public
   License along with this library; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
   
   Contact: cahon@lifl.fr
*/

#include "scheduler.h"
#include "tags.h"
#include "send.h"
#include "../../mess.h"
#include "../../runner.h"

typedef std :: pair <RANK_ID, WORKER_ID> SCHED_RESOURCE;

typedef std :: pair <RANK_ID, SERVICE_ID> SCHED_REQUEST;

std :: queue <SCHED_RESOURCE> Scheduler :: free_res; /* Free resources */

std :: queue <SCHED_RESOURCE> Scheduler :: tmp_free_res; /* Temp. free resources */

std :: queue <SCHED_REQUEST> Scheduler :: requests; /* Requests */

std :: queue <SCHED_REQUEST> Scheduler :: tmp_requests; /* Temp. requests */

static Scheduler * the_thread;

static sem_t sem_sched;

void wakeUpScheduler () {

  the_thread -> wakeUp ();
}

Scheduler :: Scheduler () {

  the_thread = this;
  sem_init (& sem_sched, 0, 1);

  /* Init */
  sem_wait (& sem_sched);
  for (unsigned i = 0; i < the_schema.size (); i ++) {
    
    const Node & node = the_schema [i];
    
    if (node.rk_sched == my_node -> rk) {

      for (unsigned j = 0; j < node.num_workers; j ++)
	free_res.push (std :: pair <RANK_ID, WORKER_ID> (i, j + 1));
    }
  }  
  sem_post (& sem_sched);
}

void Scheduler :: notifySendingResource () {

  if (tmp_requests.empty ())
    deactivate ();
}
  
void Scheduler :: notifyReceiptRequest () {

  if (! free_res.empty ())
    activate ();
}

void Scheduler :: unpackResourceRequest () {

  sem_wait (& sem_sched);
  SCHED_REQUEST req;
  unpack (req);
  requests.push (req);
  sem_post (& sem_sched);
}

void Scheduler :: unpackTaskTermination () {

  sem_wait (& sem_sched);
  SCHED_RESOURCE res;
  unpack (res);
  free_res.push (res);
  sem_post (& sem_sched);
}

void Scheduler :: packResource () {

  sem_wait (& sem_sched);
  SCHED_REQUEST req = tmp_requests.front ();
  tmp_requests.pop ();
  
  SCHED_RESOURCE res = tmp_free_res.front ();
  tmp_free_res.pop ();
  
  pack (req.second);
  pack (res);
  sem_post (& sem_sched);
  //  printf ("j'envoie la resource %d %d\n", res.first, res.second);
}

void Scheduler :: start () {

  while (true) {
    
    sleep ();

    if (! atLeastOneActiveRunner ())     
      break;
    
    sem_wait (& sem_sched);    
    /* Requests */
    unsigned num_alloc = std :: min (free_res.size (), requests.size ());

    for (unsigned i = 0; i < num_alloc; i ++) {
      
      SCHED_REQUEST req = requests.front ();
      requests.pop ();
      tmp_requests.push (req);
      
      SCHED_RESOURCE res = free_res.front ();
      free_res.pop ();
      tmp_free_res.push (res);
      
      send (this, req.first, SCHED_RESULT_TAG);
    }
    sem_post (& sem_sched);
  }
}
