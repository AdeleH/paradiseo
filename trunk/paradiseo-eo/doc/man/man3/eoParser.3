.TH "eoParser" 3 "19 Oct 2006" "Version 0.9.4-cvs" "EO" \" -*- nroff -*-
.ad l
.nh
.SH NAME
eoParser \- eoParser: command line parser and configuration file reader This class is persistent, so it can be stored and reloaded to restore parameter settings.  

.PP
.SH SYNOPSIS
.br
.PP
\fC#include <eoParser.h>\fP
.PP
Inherits \fBeoParameterLoader\fP, \fBeoObject\fP, and \fBeoPersistent\fP.
.PP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBeoParser\fP (unsigned _argc, char **_argv, std::string _programDescription='', std::string _lFileParamName='param-file', char _shortHand= 'p')"
.br
.RI "\fIConstructor a complete constructor that reads the command line an optionally reads a configuration file. \fP"
.ti -1c
.RI "void \fBprocessParam\fP (\fBeoParam\fP &param, std::string section='')"
.br
.RI "\fIProcesses the parameter and puts it in the appropriate section for readability. \fP"
.ti -1c
.RI "void \fBreadFrom\fP (std::istream &is)"
.br
.RI "\fIRead object. \fP"
.ti -1c
.RI "void \fBprintOn\fP (std::ostream &os) const "
.br
.RI "\fIWrite object. \fP"
.ti -1c
.RI "std::string \fBclassName\fP (void) const "
.br
.RI "\fIclassName for readibility \fP"
.ti -1c
.RI "bool \fBuserNeedsHelp\fP (void)"
.br
.RI "\fItrue if the user made an error or asked for help \fP"
.ti -1c
.RI "void \fBprintHelp\fP (std::ostream &os)"
.br
.RI "\fIPrints an automatic help in the specified output using the information provided by parameters. \fP"
.ti -1c
.RI "std::string \fBProgramName\fP ()"
.br
.ti -1c
.RI "virtual bool \fBisItThere\fP (\fBeoParam\fP &_param) const "
.br
.RI "\fIHas param been entered by user? \fP"
.ti -1c
.RI "\fBeoParam\fP * \fBgetParamWithLongName\fP (const std::string &_name) const "
.br
.RI "\fIget a handle on a param from its longName \fP"
.ti -1c
.RI "template<class ValueType> \fBeoValueParam\fP< ValueType > & \fBgetORcreateParam\fP (ValueType _defaultValue, std::string _longName, std::string _description, char _shortHand=0, std::string _section='', bool _required=false)"
.br
.RI "\fIGet or create parameter. \fP"
.ti -1c
.RI "template<class ValueType> \fBeoValueParam\fP< ValueType > & \fBsetORcreateParam\fP (ValueType _defaultValue, std::string _longName, std::string _description, char _shortHand=0, std::string _section='', bool _required=false)"
.br
.RI "\fISet parameter value or create parameter. \fP"
.ti -1c
.RI "void \fBsetStopOnUnknownParam\fP (bool _b)"
.br
.RI "\fIaccessors to the stopOnUnknownParam value \fP"
.ti -1c
.RI "bool \fBgetStopOnUnknownParam\fP ()"
.br
.ti -1c
.RI "void \fBsetPrefix\fP (const std::string &_prefix)"
.br
.RI "\fIPrefix handling. \fP"
.ti -1c
.RI "void \fBresetPrefix\fP ()"
.br
.ti -1c
.RI "std::string \fBgetPrefix\fP ()"
.br
.in -1c
.SS "Private Types"

.in +1c
.ti -1c
.RI "typedef std::multimap< std::string, \fBeoParam\fP * > \fBMultiMapType\fP"
.br
.ti -1c
.RI "typedef std::map< char, std::string > \fBShortNameMapType\fP"
.br
.ti -1c
.RI "typedef std::map< std::string, std::string > \fBLongNameMapType\fP"
.br
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "void \fBdoRegisterParam\fP (\fBeoParam\fP &param) const "
.br
.ti -1c
.RI "std::pair< bool, std::string > \fBgetValue\fP (\fBeoParam\fP &_param) const "
.br
.ti -1c
.RI "void \fBupdateParameters\fP () const "
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "MultiMapType \fBparams\fP"
.br
.ti -1c
.RI "std::string \fBprogramName\fP"
.br
.ti -1c
.RI "std::string \fBprogramDescription\fP"
.br
.ti -1c
.RI "ShortNameMapType \fBshortNameMap\fP"
.br
.ti -1c
.RI "LongNameMapType \fBlongNameMap\fP"
.br
.ti -1c
.RI "\fBeoValueParam\fP< bool > \fBneedHelp\fP"
.br
.ti -1c
.RI "\fBeoValueParam\fP< bool > \fBstopOnUnknownParam\fP"
.br
.ti -1c
.RI "std::vector< std::string > \fBmessages\fP"
.br
.ti -1c
.RI "std::string \fBprefix\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
eoParser: command line parser and configuration file reader This class is persistent, so it can be stored and reloaded to restore parameter settings. 
.PP
Definition at line 100 of file eoParser.h.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "eoParser::eoParser (unsigned _argc, char ** _argv, std::string _programDescription = \fC''\fP, std::string _lFileParamName = \fC'param-file'\fP, char _shortHand = \fC'p'\fP)"
.PP
Constructor a complete constructor that reads the command line an optionally reads a configuration file. 
.PP
myEo --param-file=param.rc will then load using the parameter file param.rc
.PP
\fBParameters:\fP
.RS 4
\fI_argc\fP command line arguments count 
.br
\fI_argv\fP command line parameters 
.br
\fI_programDescription\fP Description of the work the program does 
.br
\fI_lFileParamName\fP Name of the parameter specifying the configuration file (--param-file) 
.br
\fI_shortHand\fP Single charachter shorthand for specifying the configuration file 
.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "void eoParser::readFrom (std::istream & is)\fC [virtual]\fP"
.PP
Read object. 
.PP
\fBParameters:\fP
.RS 4
\fI_is\fP A std::istream. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIruntime_std::exception\fP If a valid object can't be read. 
.RE
.PP

.PP
Implements \fBeoPersistent\fP.
.SS "void eoParser::printOn (std::ostream & os) const\fC [virtual]\fP"
.PP
Write object. 
.PP
It's called printOn since it prints the object on a stream. 
.PP
\fBParameters:\fP
.RS 4
\fI_os\fP A std::ostream. 
.RE
.PP

.PP
Implements \fBeoPrintable\fP.
.SS "virtual bool eoParser::isItThere (\fBeoParam\fP & _param) const\fC [inline, virtual]\fP"
.PP
Has param been entered by user? 
.PP
Checks if _param has been actually entered by the user 
.PP
Implements \fBeoParameterLoader\fP.
.PP
Definition at line 148 of file eoParser.h.
.PP
Referenced by setORcreateParam().
.SS "\fBeoParam\fP* eoParser::getParamWithLongName (const std::string & _name) const"
.PP
get a handle on a param from its longName 
.PP
if not found, returns 0 (null pointer :-)
.PP
Not very clean (requires hard-coding of the long name twice!) but very useful in many occasions... 
.PP
Referenced by getORcreateParam().
.SS "template<class ValueType> \fBeoValueParam\fP<ValueType>& eoParser::getORcreateParam (ValueType _defaultValue, std::string _longName, std::string _description, char _shortHand = \fC0\fP, std::string _section = \fC''\fP, bool _required = \fCfalse\fP)\fC [inline]\fP"
.PP
Get or create parameter. 
.PP
It seems finally that the easiest use of the above method is through the following, whose interface is similar to that of the widely-used createParam.
.PP
For some (probably very stupid) reason, I failed to put it in the .cpp. Any hint??? 
.PP
Definition at line 173 of file eoParser.h.
.PP
References eoParameterLoader::createParam(), and getParamWithLongName().
.SS "template<class ValueType> \fBeoValueParam\fP<ValueType>& eoParser::setORcreateParam (ValueType _defaultValue, std::string _longName, std::string _description, char _shortHand = \fC0\fP, std::string _section = \fC''\fP, bool _required = \fCfalse\fP)\fC [inline]\fP"
.PP
Set parameter value or create parameter. 
.PP
This makes sure that the specified parameter has the given value. If the parameter does not exist yet, it is created.
.PP
This requires that operator<< is defined for ValueType.
.PP
\fBParameters:\fP
.RS 4
\fI_defaultValue\fP Default value. 
.br
\fI_longName\fP Long name of the argument. 
.br
\fI_description\fP Description of the parameter. 
.br
\fI_shortName\fP Short name of the argument (Optional) 
.br
\fI_section\fP Name of the section where the parameter belongs. 
.br
\fI_required\fP Is the parameter mandatory? 
.RE
.PP
\fBReturns:\fP
.RS 4
Corresponding parameter. 
.RE
.PP

.PP
Definition at line 211 of file eoParser.h.
.PP
References eoParameterLoader::createParam(), isItThere(), and eoValueParam< ValueType >::setValue().

.SH "Author"
.PP 
Generated automatically by Doxygen for EO from the source code.
