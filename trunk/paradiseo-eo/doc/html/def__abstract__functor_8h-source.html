<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>EO: def_abstract_functor.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<div class="nav">
<a class="el" href="dir_000000.html">src</a>&nbsp;/&nbsp;<a class="el" href="dir_000001.html">pyeo</a></div>
<h1>def_abstract_functor.h</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment">    PyEO</span>
00003 <span class="comment">    </span>
00004 <span class="comment">    Copyright (C) 2003 Maarten Keijzer</span>
00005 <span class="comment"></span>
00006 <span class="comment">    This program is free software; you can redistribute it and/or modify</span>
00007 <span class="comment">    it under the terms of the GNU General Public License as published by</span>
00008 <span class="comment">    the Free Software Foundation; either version 2 of the License, or</span>
00009 <span class="comment">    (at your option) any later version.</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This program is distributed in the hope that it will be useful,</span>
00012 <span class="comment">    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00013 <span class="comment">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00014 <span class="comment">    GNU General Public License for more details.</span>
00015 <span class="comment"></span>
00016 <span class="comment">    You should have received a copy of the GNU General Public License</span>
00017 <span class="comment">    along with this program; if not, write to the Free Software</span>
00018 <span class="comment">    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
00019 <span class="comment">*/</span>
00020 
00021 <span class="preprocessor">#ifndef MAKE_ABSTRACT_FUNCTOR_H</span>
00022 <span class="preprocessor"></span><span class="preprocessor">#define MAKE_ABSTRACT_FUNCTOR_H</span>
00023 <span class="preprocessor"></span>
00024 <span class="preprocessor">#include &lt;eoFunctor.h&gt;</span>
00025 
00026 <span class="comment">// DEFINES for call </span>
00027 <span class="preprocessor">#define WC1 boost::python::with_custodian_and_ward&lt;1,2&gt;()</span>
00028 <span class="preprocessor"></span><span class="preprocessor">#define WC2 boost::python::with_custodian_and_ward&lt;1,2, with_custodian_and_ward&lt;1,3&gt; &gt;()</span>
00029 <span class="preprocessor"></span>
00030 <span class="keyword">namespace </span>eoutils {
00031 
00032 <span class="keyword">using</span> <span class="keyword">namespace </span>boost::python;
00033     
00034 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Proc&gt;
00035 <span class="keyword">class </span>ProcWrapper : <span class="keyword">public</span> Proc
00036 {
00037     <span class="keyword">public</span>:
00038     PyObject* <span class="keyword">self</span>;
00039     ProcWrapper(PyObject* s) : self(s) {}
00040 
00041     <span class="keyword">typename</span> Proc::result_type operator()(<span class="keywordtype">void</span>)
00042     {
00043         <span class="keywordflow">return</span> boost::python::call_method&lt;typename Proc::result_type&gt;(<span class="keyword">self</span>, <span class="stringliteral">"__call__"</span>);
00044     }
00045 };
00046 
00047 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Proc&gt;
00048 <span class="keywordtype">void</span> make_abstract_functor(std::string name, <span class="keyword">typename</span> <a class="code" href="structeo_functor_base_1_1procedure__tag.html">eoFunctorBase::procedure_tag</a>)
00049 {
00050     <span class="keyword">typedef</span> ProcWrapper&lt;Proc&gt; Wrapper;
00051     boost::python::class_&lt;Proc, Wrapper,boost::noncopyable&gt;(name.c_str(), boost::python::init&lt;&gt;() )
00052         .def(<span class="stringliteral">"__call__"</span>, &amp;Wrapper::operator());
00053 }
00054 
00055 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Proc&gt;
00056 <span class="keywordtype">void</span> make_abstract_functor_ref(std::string name, <span class="keyword">typename</span> eoFunctorBase::procedure_tag)
00057 {
00058     <span class="keyword">typedef</span> ProcWrapper&lt;Proc&gt; Wrapper;
00059     boost::python::class_&lt;Proc, Wrapper,boost::noncopyable&gt;(name.c_str(), boost::python::init&lt;&gt;() )
00060         .def(<span class="stringliteral">"__call__"</span>, &amp;Wrapper::operator(), boost::python::return_internal_reference&lt;&gt;());
00061 }
00062 
00063 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Unary&gt;
00064 <span class="keyword">class </span>UnaryWrapper : <span class="keyword">public</span> Unary
00065 {
00066     <span class="keyword">public</span>:
00067     PyObject* <span class="keyword">self</span>;
00068     UnaryWrapper(PyObject* s) : self(s) {}
00069 
00070     <span class="keyword">typename</span> Unary::result_type operator()(<span class="keyword">typename</span> Unary::argument_type a) 
00071     { 
00072         <span class="keywordflow">return</span> boost::python::call_method&lt;typename Unary::result_type&gt;(<span class="keyword">self</span>, <span class="stringliteral">"__call__"</span>, boost::ref(a) ); 
00073     }
00074 };
00075 
00076 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Unary&gt;
00077 <span class="keywordtype">void</span> make_abstract_functor(std::string name, <span class="keyword">typename</span> <a class="code" href="structeo_functor_base_1_1unary__function__tag.html">eoFunctorBase::unary_function_tag</a>)
00078 {
00079     <span class="keyword">typedef</span> UnaryWrapper&lt;Unary&gt; Wrapper;
00080 
00081     boost::python::class_&lt;Unary, Wrapper, boost::noncopyable&gt;(name.c_str(), boost::python::init&lt;&gt;() )
00082         .def(<span class="stringliteral">"__call__"</span>, &amp;Wrapper::operator())
00083         ;
00084 }
00085 
00086 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Unary&gt;
00087 <span class="keywordtype">void</span> make_abstract_functor_ref(std::string name, <span class="keyword">typename</span> eoFunctorBase::unary_function_tag)
00088 {
00089     <span class="keyword">typedef</span> UnaryWrapper&lt;Unary&gt; Wrapper;
00090 
00091     boost::python::class_&lt;Unary, Wrapper, boost::noncopyable&gt;(name.c_str(), boost::python::init&lt;&gt;() )
00092         .def(<span class="stringliteral">"__call__"</span>, &amp;Wrapper::operator(), boost::python::return_internal_reference&lt;&gt;() )
00093         ;
00094 }
00095 
00096 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Binary&gt;
00097 <span class="keyword">class </span>BinaryWrapper : <span class="keyword">public</span> Binary
00098 {
00099     <span class="keyword">public</span>:
00100     PyObject* <span class="keyword">self</span>;
00101     BinaryWrapper(PyObject* s) : self(s) {}
00102     <span class="keyword">typename</span> Binary::result_type operator()(<span class="keyword">typename</span> Binary::first_argument_type a1, <span class="keyword">typename</span> Binary::second_argument_type a2)
00103     {
00104         <span class="keywordflow">return</span> boost::python::call_method&lt;
00105             <span class="keyword">typename</span> Binary::result_type&gt;(<span class="keyword">self</span>, <span class="stringliteral">"__call__"</span>, boost::ref(a1), boost::ref(a2) );
00106     }
00107 };
00108 
00109 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Binary&gt;
00110 <span class="keywordtype">void</span> make_abstract_functor(std::string name, <span class="keyword">typename</span> <a class="code" href="structeo_functor_base_1_1binary__function__tag.html">eoFunctorBase::binary_function_tag</a>)
00111 {
00112     <span class="keyword">typedef</span> BinaryWrapper&lt;Binary&gt; Wrapper;
00113     boost::python::class_&lt;Binary, Wrapper, boost::noncopyable&gt;(name.c_str(), boost::python::init&lt;&gt;() )
00114         .def(<span class="stringliteral">"__call__"</span>, &amp;Wrapper::operator());
00115 }
00116 
00117 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Binary&gt;
00118 <span class="keywordtype">void</span> make_abstract_functor_ref(std::string name, <span class="keyword">typename</span> eoFunctorBase::binary_function_tag)
00119 {
00120     <span class="keyword">typedef</span> BinaryWrapper&lt;Binary&gt; Wrapper;
00121     boost::python::class_&lt;Binary, Wrapper, boost::noncopyable&gt;(name.c_str(), boost::python::init&lt;&gt;() )
00122         .def(<span class="stringliteral">"__call__"</span>, &amp;Wrapper::operator(), boost::python::return_internal_reference&lt;&gt;() );
00123 }
00124 
00125 }<span class="comment">// namespace eoutils</span>
00126 
00127 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Functor&gt;
00128 <span class="keywordtype">void</span> def_abstract_functor(std::string name)
00129 {
00130     eoutils::make_abstract_functor&lt;Functor&gt;(name, Functor::functor_category());
00131 }
00132 
00133 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Functor&gt;
00134 <span class="keywordtype">void</span> def_abstract_functor_ref(std::string name)
00135 {
00136     eoutils::make_abstract_functor_ref&lt;Functor&gt;(name, Functor::functor_category());
00137 }
00138 
00139 <span class="preprocessor">#endif</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Thu Oct 19 05:06:34 2006 for EO by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
