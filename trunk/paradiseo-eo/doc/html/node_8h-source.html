<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>EO: node.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<div class="nav">
<a class="el" href="dir_000020.html">app</a>&nbsp;/&nbsp;<a class="el" href="dir_000021.html">gpsymreg</a></div>
<h1>node.h</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment">    This library is free software; you can redistribute it and/or modify</span>
00003 <span class="comment">    it under the terms of the GNU General Public License as published by</span>
00004 <span class="comment">    the Free Software Foundation; either version 2 of the License, or</span>
00005 <span class="comment">    (at your option) any later version.</span>
00006 <span class="comment">    </span>
00007 <span class="comment">    This library is distributed in the hope that it will be useful,</span>
00008 <span class="comment">    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00009 <span class="comment">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
00010 <span class="comment">    Lesser General Public License for more details.</span>
00011 <span class="comment"> </span>
00012 <span class="comment">    You should have received a copy of the GNU General Public License</span>
00013 <span class="comment">    along with this library; if not, write to the Free Software</span>
00014 <span class="comment">    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
00015 <span class="comment"> </span>
00016 <span class="comment">    Contact: todos@geneura.ugr.es, http://geneura.ugr.es</span>
00017 <span class="comment">             jeggermo@liacs.nl</span>
00018 <span class="comment">*/</span>
00019 
00020 <span class="preprocessor">#ifndef _NODE_H</span>
00021 <span class="preprocessor"></span><span class="preprocessor">#define _NODE_H</span>
00022 <span class="preprocessor"></span>
00023 
00024 
00025 <span class="preprocessor">#include &lt;iostream&gt;</span>
00026 <span class="preprocessor">#include &lt;string&gt;</span>
00027 <span class="preprocessor">#include &lt;cmath&gt;</span> <span class="comment">// for finite(double) function</span>
00028 
00029 <span class="keyword">using</span> <span class="keyword">namespace </span>gp_parse_tree;
00030 <span class="keyword">using</span> <span class="keyword">namespace </span>std;
00031 
00032 
00033 <span class="comment">/* A new Operation and Node class for even more flexibility.</span>
00034 <span class="comment"></span>
00035 <span class="comment">   Improvements over the t-eoSymreg code are:</span>
00036 <span class="comment">   </span>
00037 <span class="comment">   * No hardcoded functions or operators. The Operation and Node class below</span>
00038 <span class="comment">     allow you to specify your own unary and binary functions as well as</span>
00039 <span class="comment">     binary operators (like +,-,*,/). Moreover you can detemine if you want</span>
00040 <span class="comment">     to allow primitve subroutines with either one or two arguments.</span>
00041 <span class="comment">     </span>
00042 <span class="comment">     If a Node has a subroutine Operation it will take evaluate the first </span>
00043 <span class="comment">     (and possible second) child branch and use them as input variables for</span>
00044 <span class="comment">     the remaining second (or third) child branch.</span>
00045 <span class="comment">*/</span>
00046 
00047 
00048 <span class="keyword">typedef</span> <span class="keyword">enum</span> {Variable, UFunction, BFunction, BOperator, Const} Type;
00049 
00050 <span class="keyword">typedef</span> double (*BinaryFunction)(<span class="keyword">const</span> double,<span class="keyword">const</span> double); 
00051 <span class="keyword">typedef</span> double (*UnaryFunction)(<span class="keyword">const</span> double);
00052 
00053 <span class="keyword">struct </span>Operation
00054 {
00055         <span class="keyword">public</span>:
00056                 
00057                 <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> VariableID;
00058                 <span class="keyword">typedef</span> string Label;
00059 
00060         
00061                 <span class="comment">// if your compiler allows you to have nameless unions you can make this a</span>
00062                 <span class="comment">// union by removing the //'s below</span>
00063                 
00064                 <span class="comment">//union</span>
00065                 <span class="comment">//{</span>
00066                         UnaryFunction uFunction;
00067                         BinaryFunction bFunction;
00068                         VariableID id;
00069                         <span class="keywordtype">double</span> constant;
00070                 <span class="comment">//};</span>
00071         
00072                 
00073         
00074                 Label label;
00075                 Type type;
00076         
00077                 <span class="comment">// the default constructor results in a constant with value 0</span>
00078                 Operation() : constant(0),  label(<span class="stringliteral">"0"</span>), type(Const){};
00079                 <span class="comment">// two possible constructors for Unary Functions</span>
00080                 Operation(UnaryFunction _uf, Label _label): uFunction(_uf), label(_label), type(UFunction) {};
00081                 Operation(Label _label, UnaryFunction _uf): uFunction(_uf), label(_label), type(UFunction) {};
00082                 
00083                 <span class="comment">// Watch out there are two constructors using pointers two binary functions:</span>
00084                 <span class="comment">// Binary Function (printed as label(subtree0,subtree1)  (e.g. pow(x,y))</span>
00085                 <span class="comment">// Binary Operator (printed as (subtree0 label subtree1) (e.g. x^y)</span>
00086                 <span class="comment">// The difference is purely cosmetic.</span>
00087                 
00088                 <span class="comment">// If you specify the label before the function pointer -&gt; Binary Function</span>
00089                 Operation(Label _label, BinaryFunction _bf): bFunction(_bf), label(_label), type(BFunction) {};
00090                 <span class="comment">// If you specify the function pointer before the label -&gt; Binary Operator</span>
00091                 Operation(BinaryFunction _bf, Label _label): bFunction(_bf), label(_label), type(BOperator) {};
00092                 
00093                 <span class="comment">// A constructor for variables</span>
00094                 Operation(VariableID _id, Label _label): id(_id), label(_label), type(Variable) {};
00095                 <span class="comment">// A constructor for constants</span>
00096                 Operation(<span class="keywordtype">double</span> _constant, Label _label): constant(_constant), label(_label), type(Const) {};
00097                 
00098                 
00099                 Operation(<span class="keyword">const</span> Operation &amp;_op)
00100                 {
00101                         <span class="keywordflow">switch</span>(_op.type)
00102                         {
00103                                 <span class="keywordflow">case</span> Variable: <span class="keywordtype">id</span> = _op.id; <span class="keywordflow">break</span>;
00104                                 <span class="keywordflow">case</span> UFunction: uFunction = _op.uFunction;  <span class="keywordflow">break</span>;
00105                                 <span class="keywordflow">case</span> BFunction: bFunction = _op.bFunction; <span class="keywordflow">break</span>;
00106                                 <span class="keywordflow">case</span> BOperator: bFunction = _op.bFunction; <span class="keywordflow">break</span>;
00107                                 <span class="keywordflow">case</span> Const: constant = _op.constant;  <span class="keywordflow">break</span>;
00108                         }
00109                         type = _op.type;
00110                         label = _op.label;
00111                 };
00112                 <span class="keyword">virtual</span> ~Operation(){};
00113         
00114 };
00115 
00116 
00117 <span class="keyword">class </span>Node
00118 {
00119         <span class="keyword">private</span>:
00120                 Operation op;
00121                 
00122         <span class="keyword">public</span>:
00123         
00124                 Node(<span class="keywordtype">void</span>): op(Operation()){};
00125                 Node(Operation &amp;_op) : op(_op){};
00126                 <span class="keyword">virtual</span> ~Node(<span class="keywordtype">void</span>) {}
00127                 
00128                 <span class="keywordtype">int</span> arity(<span class="keywordtype">void</span>)<span class="keyword"> const </span>
00129 <span class="keyword">                </span>{
00130                         <span class="keywordflow">switch</span>(op.type)
00131                         {
00132                                 <span class="keywordflow">case</span> Variable: <span class="keywordflow">return</span> 0;
00133                                 <span class="keywordflow">case</span> UFunction: <span class="keywordflow">return</span> 1;
00134                                 <span class="keywordflow">case</span> BFunction: <span class="keywordflow">return</span> 2;
00135                                 <span class="keywordflow">case</span> BOperator: <span class="keywordflow">return</span> 2;
00136                                 <span class="keywordflow">case</span> Const: <span class="keywordflow">return</span> 0;
00137                         }                       
00138                         <span class="keywordflow">return</span> 0;       
00139                 }
00140                 
00141                 <span class="keywordtype">void</span> randomize(<span class="keywordtype">void</span>) {}
00142                 
00143                 <span class="keyword">template</span>&lt;<span class="keyword">class</span> Children&gt;
00144                 <span class="keywordtype">void</span> operator()(<span class="keywordtype">double</span>&amp; result, Children args, vector&lt;double&gt; &amp;var)<span class="keyword"> const</span>
00145 <span class="keyword">                </span>{
00146                         <span class="keywordtype">double</span> result0;
00147                         <span class="keywordtype">double</span> result1;
00148                         
00149                         
00150                         <span class="keywordflow">switch</span>(op.type)
00151                         {
00152                                 <span class="keywordflow">case</span> Variable:  result = var[op.id%var.size()]; <span class="comment">//%var.size() used in the case of Subroutines and as a security measure</span>
00153                                                 <span class="keywordflow">break</span>;
00154                                 <span class="keywordflow">case</span> UFunction: args[0].apply(result0, var);
00155                                                 result = op.uFunction(result0); 
00156                                                 <span class="keywordflow">break</span>;
00157                                 <span class="keywordflow">case</span> BFunction: 
00158                                 <span class="keywordflow">case</span> BOperator: args[0].apply(result0, var);
00159                                                 args[1].apply(result1, var);    
00160                                                 result = op.bFunction(result0,result1);
00161                                                 <span class="keywordflow">break</span>;
00162                                 <span class="keywordflow">case</span> Const:     result = op.constant;
00163                                                 <span class="keywordflow">break</span>;  
00164                                 
00165                         }
00166                         
00167                 }
00168                 
00169                 <span class="keyword">template</span>&lt;<span class="keyword">class</span> Children&gt;
00170                 <span class="keywordtype">void</span> operator()(string&amp; result, Children args)<span class="keyword"> const</span>
00171 <span class="keyword">                </span>{
00172                         
00173                         string subtree0;
00174                         string subtree1;
00175                         string subtree2;
00176                         
00177                         <span class="keywordflow">switch</span>(op.type)
00178                         {
00179                                 
00180                                 <span class="keywordflow">case</span> Variable:  
00181                                 <span class="keywordflow">case</span> Const:     result += op.label;
00182                                                 <span class="keywordflow">break</span>;
00183                                         
00184                                 <span class="keywordflow">case</span> UFunction: result += op.label;
00185                                                 result += <span class="stringliteral">"("</span>;
00186                                                 args[0].apply(subtree0);
00187                                                 result += subtree0;
00188                                                 result += <span class="stringliteral">")"</span>;
00189                                                 <span class="keywordflow">break</span>;
00190                                 <span class="keywordflow">case</span> BFunction: result += op.label;
00191                                                 result += <span class="stringliteral">"("</span>;
00192                                                 args[0].apply(subtree0);
00193                                                 result += subtree0;
00194                                                 result += <span class="stringliteral">","</span>;
00195                                                 args[1].apply(subtree1);
00196                                                 result += subtree1;
00197                                                 result += <span class="stringliteral">")"</span>;
00198                                                 <span class="keywordflow">break</span>;                                                          
00199                                 <span class="keywordflow">case</span> BOperator: result += <span class="stringliteral">"("</span>;
00200                                                 args[0].apply(subtree0);
00201                                                 result += subtree0;
00202                                                 result += op.label;
00203                                                 args[1].apply(subtree1);
00204                                                 result += subtree1;
00205                                                 result += <span class="stringliteral">")"</span>;
00206                                                 <span class="keywordflow">break</span>;
00207                                 <span class="keywordflow">default</span>: result += <span class="stringliteral">"ERROR in Node::operator(string,...) \n"</span>; <span class="keywordflow">break</span>;             
00208                         }
00209                 }
00210                 
00211                 Operation getOp(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{<span class="keywordflow">return</span> op;}
00212         
00213 };
00214 
00215                 
00216                 
00217 
00218 
00219 
00220 
00221 
00222 
00223 
00224 
00225 <span class="comment">//-----------------------------------------------------------</span>
00226 <span class="comment">// saving, loading LETS LEAVE IT OUT FOR NOW</span>
00227 
00228 
00229 
00230 std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, <span class="keyword">const</span> Node&amp; eot)
00231 {
00232     Operation op(eot.getOp());
00233     
00234     os &lt;&lt; (eot.getOp()).label;
00235     <span class="keywordflow">return</span> os;
00236 }
00237 
00238 
00239 <span class="comment">// we can't load because we are using function pointers. Instead we prevent a compiler warning by calling the arity() function.</span>
00240 std::istream&amp; operator&gt;&gt;(std::istream&amp; is, Node&amp; eot)
00241 {
00242     eot.arity();
00243     <span class="keywordflow">return</span> is;
00244 }
00245 
00246 
00247 
00248 <span class="preprocessor">#endif</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Thu Oct 19 05:06:41 2006 for EO by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
