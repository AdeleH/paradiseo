<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>EO: sym_compile.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<div class="nav">
<a class="el" href="dir_000007.html">contrib</a>&nbsp;/&nbsp;<a class="el" href="dir_000008.html">mathsym</a>&nbsp;/&nbsp;<a class="el" href="dir_000009.html">eval</a></div>
<h1>sym_compile.cpp</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">/*          </span>
00002 <span class="comment"> *             Copyright (C) 2005 Maarten Keijzer</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> *          This program is free software; you can redistribute it and/or modify</span>
00005 <span class="comment"> *          it under the terms of version 2 of the GNU General Public License as </span>
00006 <span class="comment"> *          published by the Free Software Foundation. </span>
00007 <span class="comment"> *</span>
00008 <span class="comment"> *          This program is distributed in the hope that it will be useful,</span>
00009 <span class="comment"> *          but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00010 <span class="comment"> *          MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00011 <span class="comment"> *          GNU General Public License for more details.</span>
00012 <span class="comment"> *</span>
00013 <span class="comment"> *          You should have received a copy of the GNU General Public License</span>
00014 <span class="comment"> *          along with this program; if not, write to the Free Software</span>
00015 <span class="comment"> *          Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
00016 <span class="comment"> */</span>
00017 
00018 
00019 <span class="preprocessor">#include "Sym.h"</span>
00020 <span class="preprocessor">#include "FunDef.h"</span>
00021 <span class="preprocessor">#include "sym_compile.h"</span>
00022 
00023 <span class="preprocessor">#include &lt;sstream&gt;</span>
00024 
00025 <span class="keyword">using</span> <span class="keyword">namespace </span>std;
00026 
00027 <span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
00028     <span class="keywordtype">void</span>  symc_init();
00029     <span class="keywordtype">int</span>  symc_compile(<span class="keyword">const</span> <span class="keywordtype">char</span>* func_str);
00030     <span class="keywordtype">int</span>  symc_link();
00031     <span class="keywordtype">void</span>* symc_get_fun(<span class="keyword">const</span> <span class="keywordtype">char</span>* func_name);
00032     <span class="keywordtype">void</span>* symc_make(<span class="keyword">const</span> <span class="keywordtype">char</span>* func_str, <span class="keyword">const</span> <span class="keywordtype">char</span>* func_name);
00033 }
00034 
00035 string make_prototypes() {
00036     string prot = get_prototypes();
00037     prot += <span class="stringliteral">"double sqr(double x) { return x*x; }"</span>;
00038     <span class="keywordflow">return</span> prot;
00039 }
00040 
00041 <span class="comment">// contains variable names, like 'a0', 'a1', etc. or regular code</span>
00042 
00043 <span class="preprocessor">#if USE_TR1 </span>
00044 <span class="preprocessor"></span><span class="keyword">typedef</span> std::tr1::unordered_map&lt;Sym, string, HashSym&gt; HashMap;
00045 <span class="preprocessor">#else</span>
00046 <span class="preprocessor"></span><span class="keyword">typedef</span> hash_map&lt;Sym, string, HashSym&gt; HashMap;
00047 <span class="preprocessor">#endif</span>
00048 <span class="preprocessor"></span>
00049 <span class="comment">// prints 'num' in reverse notation. Does not matter as it's a unique id</span>
00050 string make_var(<span class="keywordtype">unsigned</span> num) {
00051     string str = <span class="stringliteral">"a"</span>;
00052     <span class="keywordflow">do</span> {
00053         str += char(<span class="charliteral">'0'</span> + (num % 10));
00054         num /= 10;
00055     } <span class="keywordflow">while</span> (num);
00056     <span class="keywordflow">return</span> str;
00057 }
00058 
00059 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
00060 string to_string(T t) {
00061     ostringstream os;
00062     os &lt;&lt; t;
00063     <span class="keywordflow">return</span> os.str();
00064 }
00065 
00066 
00067 HashMap::iterator find_entry(<span class="keyword">const</span> Sym&amp; sym, string&amp; str, HashMap&amp; map) {
00068     HashMap::iterator result = map.find(sym);
00069 
00070     <span class="keywordflow">if</span> (result == map.end()) { <span class="comment">// new entry</span>
00071         <span class="keyword">const</span> SymVec&amp; args = sym.args();
00072         
00073         vector&lt;string&gt; argstr(args.size());
00074         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; args.size(); ++i) {
00075             argstr[i] = find_entry(args[i], str, map)-&gt;second;
00076         }
00077 
00078         string var = make_var(map.size()); <span class="comment">// map.size(): unique id</span>
00079         string code;    
00080         <span class="comment">// write out the code</span>
00081         <span class="keyword">const</span> FunDef&amp; fun = get_element(sym.token());
00082         code = fun.c_print(argstr, vector&lt;string&gt;() );
00083             
00084         str += <span class="stringliteral">"double "</span> + var + <span class="stringliteral">"="</span> + code + <span class="stringliteral">";\n"</span>;
00085         result = map.insert( make_pair(sym, var ) ).first; <span class="comment">// only want iterator</span>
00086     }
00087     
00088     <span class="keywordflow">return</span> result;
00089 }
00090 
00091 <span class="keywordtype">void</span> write_entry(<span class="keyword">const</span> Sym&amp; sym, string&amp; str, HashMap&amp; map, <span class="keywordtype">unsigned</span> out) {
00092     HashMap::iterator it = find_entry(sym, str, map);
00093     
00094     str += <span class="stringliteral">"y["</span> + to_string(out) + <span class="stringliteral">"]="</span> + it-&gt;second + <span class="stringliteral">";\n"</span>;
00095     <span class="comment">//cout &lt;&lt; "wrote " &lt;&lt; out &lt;&lt; '\n';</span>
00096 }
00097 
00098 <span class="preprocessor">#include &lt;fstream&gt;</span>
00099 multi_function compile(<span class="keyword">const</span> std::vector&lt;Sym&gt;&amp; syms) {
00100     
00101     <span class="comment">//cout &lt;&lt; "Multifunction " &lt;&lt; syms.size() &lt;&lt; endl;</span>
00102     <span class="comment">// static stream to avoid fragmentation of these LARGE strings</span>
00103     <span class="keyword">static</span> string str;
00104     str.clear();
00105     str += make_prototypes();
00106 
00107     str += <span class="stringliteral">"extern double func(const double* x, double* y) { \n "</span>;
00108    
00109     multi_function result;
00110     HashMap map(Sym::get_dag().size());
00111     
00112     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; syms.size(); ++i) {
00113         write_entry(syms[i], str, map, i);
00114     }
00115     
00116     str += <span class="stringliteral">";}"</span>;
00117 
00118     
00119     <span class="comment">/*static int counter = 0;</span>
00120 <span class="comment">    ostringstream nm;</span>
00121 <span class="comment">    nm &lt;&lt; "cmp/compiled" &lt;&lt; (counter++) &lt;&lt; ".c";</span>
00122 <span class="comment">    cout &lt;&lt; "Saving as " &lt;&lt; nm.str() &lt;&lt; endl;</span>
00123 <span class="comment">    ofstream cmp(nm.str().c_str());</span>
00124 <span class="comment">    cmp &lt;&lt; str;</span>
00125 <span class="comment">    cmp.close();</span>
00126 <span class="comment"></span>
00127 <span class="comment">    //cout &lt;&lt; "Multifunction " &lt;&lt; syms.size() &lt;&lt; endl;</span>
00128 <span class="comment">    cout &lt;&lt; "Size of map " &lt;&lt; map.size() &lt;&lt; endl;</span>
00129 <span class="comment">*/</span>
00130 
00131     result = (multi_function) symc_make(str.c_str(), <span class="stringliteral">"func"</span>); 
00132 
00133     <span class="keywordflow">if</span> (result==0) { <span class="comment">// error</span>
00134         cout &lt;&lt; <span class="stringliteral">"Error in compile "</span> &lt;&lt; endl;
00135     }
00136 
00137     <span class="keywordflow">return</span> result;
00138 }
00139 
00140 single_function compile(Sym sym) {
00141 
00142     ostringstream os;
00143 
00144     os &lt;&lt; make_prototypes();
00145     os &lt;&lt; <span class="stringliteral">"double func(const double* x) { return "</span>;
00146     
00147     string code = c_print(sym);
00148     os &lt;&lt; code;
00149     os &lt;&lt; <span class="stringliteral">";}"</span>;
00150     string func_str = os.str();
00151   
00152     <span class="comment">//cout &lt;&lt; "compiling " &lt;&lt; func_str &lt;&lt; endl;</span>
00153     
00154     <span class="keywordflow">return</span>  (single_function) symc_make(func_str.c_str(), <span class="stringliteral">"func"</span>); 
00155 }
00156 
00157 <span class="comment">/* finds and inserts the full code in a hashmap */</span>
00158 HashMap::iterator find_code(Sym sym, HashMap&amp; map) {
00159     HashMap::iterator result = map.find(sym);
00160 
00161     <span class="keywordflow">if</span> (result == map.end()) { <span class="comment">// new entry</span>
00162         <span class="keyword">const</span> SymVec&amp; args = sym.args();
00163         vector&lt;string&gt; argstr(args.size());
00164         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; args.size(); ++i) {
00165             argstr[i] = find_code(args[i], map)-&gt;second;
00166         }
00167 
00168         <span class="comment">// write out the code</span>
00169         <span class="keyword">const</span> FunDef&amp; fun = get_element(sym.token());
00170         string code = fun.c_print(argstr, vector&lt;string&gt;());
00171         result = map.insert( make_pair(sym, code) ).first; <span class="comment">// only want iterator</span>
00172     }
00173     
00174     <span class="keywordflow">return</span> result;
00175 }
00176 
00177 string print_code(Sym sym, HashMap&amp; map) {
00178     HashMap::iterator it = find_code(sym, map);
00179     <span class="keywordflow">return</span> it-&gt;second;
00180 }
00181 
00182 <span class="keywordtype">void</span> compile(<span class="keyword">const</span> std::vector&lt;Sym&gt;&amp; syms, std::vector&lt;single_function&gt;&amp; functions) {
00183     symc_init();
00184     
00185     <span class="keyword">static</span> ostringstream os;
00186     os.str(<span class="stringliteral">""</span>);
00187     
00188     os &lt;&lt; make_prototypes();
00189     HashMap map(Sym::get_dag().size());
00190     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; syms.size(); ++i) {
00191         
00192         os &lt;&lt; <span class="stringliteral">"double func"</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">"(const double* x) { return "</span>;
00193         os &lt;&lt; print_code(syms[i], map); <span class="comment">//c_print(syms[i]);</span>
00194         os &lt;&lt; <span class="stringliteral">";}\n"</span>;
00195 
00196         <span class="comment">//symc_compile(os.str().c_str());</span>
00197         <span class="comment">//cout &lt;&lt; "compiling " &lt;&lt; os.str() &lt;&lt; endl;     </span>
00198     }
00199 
00200     os &lt;&lt; ends;
00201 <span class="preprocessor">#ifdef INTERVAL_DEBUG</span>
00202 <span class="preprocessor"></span>    <span class="comment">//cout &lt;&lt; "Compiling " &lt;&lt; os.str() &lt;&lt; endl;</span>
00203 <span class="preprocessor">#endif</span>
00204 <span class="preprocessor"></span>    
00205     symc_compile(os.str().c_str()); 
00206     symc_link();
00207 
00208     functions.resize(syms.size());
00209     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; syms.size(); ++i) {
00210         ostringstream os2;
00211         os2 &lt;&lt; <span class="stringliteral">"func"</span> &lt;&lt; i;
00212         
00213         functions[i] = (single_function) symc_get_fun(os2.str().c_str());
00214     }
00215 
00216 }
00217 
00218 
00219 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Thu Oct 19 05:06:42 2006 for EO by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
