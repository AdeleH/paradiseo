<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>EO: Scaling.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<div class="nav">
<a class="el" href="dir_000007.html">contrib</a>&nbsp;/&nbsp;<a class="el" href="dir_000008.html">mathsym</a>&nbsp;/&nbsp;<a class="el" href="dir_000012.html">regression</a></div>
<h1>Scaling.cpp</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">/*          </span>
00002 <span class="comment"> *             Copyright (C) 2005 Maarten Keijzer</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> *          This program is free software; you can redistribute it and/or modify</span>
00005 <span class="comment"> *          it under the terms of version 2 of the GNU General Public License as </span>
00006 <span class="comment"> *          published by the Free Software Foundation. </span>
00007 <span class="comment"> *</span>
00008 <span class="comment"> *          This program is distributed in the hope that it will be useful,</span>
00009 <span class="comment"> *          but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00010 <span class="comment"> *          MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00011 <span class="comment"> *          GNU General Public License for more details.</span>
00012 <span class="comment"> *</span>
00013 <span class="comment"> *          You should have received a copy of the GNU General Public License</span>
00014 <span class="comment"> *          along with this program; if not, write to the Free Software</span>
00015 <span class="comment"> *          Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
00016 <span class="comment"> */</span>
00017 
00018 <span class="preprocessor">#include "Scaling.h"</span>
00019 <span class="preprocessor">#include "TargetInfo.h"</span>
00020 
00021 <span class="keyword">using</span> <span class="keyword">namespace </span>std;
00022 
00023 Scaling slope(<span class="keyword">const</span> std::valarray&lt;double&gt;&amp; x, <span class="keyword">const</span> TargetInfo&amp; targets) {
00024     
00025     <span class="keywordtype">double</span> xx = 0.0;
00026     <span class="keywordtype">double</span> xy = 0.0;
00027     
00028     <span class="keyword">const</span> valarray&lt;double&gt;&amp; y = targets.targets();
00029     
00030     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; x.size(); ++i) {
00031         xx += x[i] * x[i];
00032         xy += x[i] * y[i];
00033     }
00034     
00035     <span class="keywordflow">if</span> (xx &lt; 1e-7) <span class="keywordflow">return</span> Scaling(<span class="keyword">new</span> LinearScaling(0.0,0.0));
00036     
00037     <span class="keywordtype">double</span> b = xy / xx;
00038    
00039     <span class="keywordflow">return</span> Scaling(<span class="keyword">new</span> LinearScaling(0.0, b));
00040     
00041 }
00042 
00043 <span class="comment">// Still needs proper testing with non-trivial lambda</span>
00044 Scaling regularized_least_squares(<span class="keyword">const</span> std::valarray&lt;double&gt;&amp; inputs, <span class="keyword">const</span> TargetInfo&amp; targets, <span class="keywordtype">double</span> lambda) {
00045     
00046     <span class="keywordtype">double</span> n = inputs.size();
00047     
00048     valarray&lt;double&gt; x = inputs;
00049 
00050     <span class="keywordtype">double</span> a,b,d;
00051     a=b=d=0;
00052 
00053     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; n; ++i) {
00054         a += 1 + lambda;
00055         b += x[i];
00056         d += x[i] * x[i] + lambda;
00057     }
00058     
00059     <span class="comment">//invert</span>
00060     
00061     <span class="keywordtype">double</span> ad_bc = a*d - b * b;
00062     <span class="comment">// if ad_bc equals zero there's a problem</span>
00063    
00064     <span class="keywordflow">if</span> (ad_bc &lt; 1e-17) <span class="keywordflow">return</span> Scaling(<span class="keyword">new</span> LinearScaling);
00065     
00066     <span class="keywordtype">double</span> ai = d/ad_bc;
00067     <span class="keywordtype">double</span> bi = -b/ad_bc;
00068     <span class="keywordtype">double</span> di = a/ad_bc;
00069     <span class="keywordtype">double</span> ci = bi;
00070     
00071     <span class="comment">// Now multiply this inverted covariance matrix (C^-1) with x' * t</span>
00072     
00073     std::valarray&lt;double&gt; ones = x;
00074     
00075     <span class="comment">// calculate C^-1 * x' )</span>
00076     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; n; ++i) 
00077     {
00078         ones[i] = (ai + bi * x[i]);
00079         x[i]    = (ci + di * x[i]);
00080     }
00081 
00082     <span class="comment">// results are in [ones, x], now multiply with y</span>
00083 
00084     a = 0.0; <span class="comment">// intercept</span>
00085     b = 0.0; <span class="comment">// slope</span>
00086     
00087     <span class="keyword">const</span> valarray&lt;double&gt;&amp; t = targets.targets();
00088     
00089     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; n; ++i)
00090     {
00091         a += ones[i] * t[i];
00092         b += x[i] * t[i];
00093     }
00094     
00095     <span class="keywordflow">return</span> Scaling(<span class="keyword">new</span> LinearScaling(a,b));
00096 }
00097 
00098 Scaling ols(<span class="keyword">const</span> std::valarray&lt;double&gt;&amp; y, <span class="keyword">const</span> std::valarray&lt;double&gt;&amp; t) {
00099     <span class="keywordtype">double</span> n = y.size();
00100     
00101     <span class="keywordtype">double</span> y_mean = y.sum() / n;
00102     <span class="keywordtype">double</span> t_mean = t.sum() / n;
00103    
00104     std::valarray&lt;double&gt; y_var = (y - y_mean);
00105     std::valarray&lt;double&gt; t_var = (t - t_mean);
00106     std::valarray&lt;double&gt; cov = t_var * y_var;
00107     
00108     y_var *= y_var;
00109     t_var *= t_var;
00110     
00111     <span class="keywordtype">double</span> sumvar = y_var.sum();
00112     
00113     <span class="keywordflow">if</span> (sumvar == 0. || sumvar/n &lt; 1e-7 || sumvar/n &gt; 1e+7) <span class="comment">// breakout when numerical problems are likely</span>
00114         <span class="keywordflow">return</span> Scaling(<span class="keyword">new</span> LinearScaling(t_mean,0.));
00115 
00116     
00117     <span class="keywordtype">double</span> b = cov.sum() / sumvar;
00118     <span class="keywordtype">double</span> a = t_mean - b * y_mean;
00119     
00120     Scaling s = Scaling(<span class="keyword">new</span> LinearScaling(a,b));
00121 
00122     <span class="keywordflow">return</span> s;
00123 }
00124 
00125 Scaling ols(<span class="keyword">const</span> std::valarray&lt;double&gt;&amp; y, <span class="keyword">const</span> TargetInfo&amp; targets) {
00126     <span class="keywordtype">double</span> n = y.size();
00127     
00128     <span class="keywordtype">double</span> y_mean = y.sum() / n;
00129     
00130     std::valarray&lt;double&gt; y_var = (y - y_mean);
00131     std::valarray&lt;double&gt; cov = targets.tcov_part() * y_var;
00132     
00133     y_var *= y_var;
00134 
00135     <span class="keywordtype">double</span> sumvar = y_var.sum();
00136     
00137     <span class="keywordflow">if</span> (sumvar == 0. || sumvar/n &lt; 1e-7 || sumvar/n &gt; 1e+7) <span class="comment">// breakout when numerical problems are likely</span>
00138         <span class="keywordflow">return</span> Scaling(<span class="keyword">new</span> LinearScaling(targets.tmean(),0.));
00139 
00140     
00141     <span class="keywordtype">double</span> b = cov.sum() / sumvar;
00142     <span class="keywordtype">double</span> a = targets.tmean() - b * y_mean;
00143     
00144     <span class="keywordflow">if</span> (!finite(b)) {
00145         
00146         cout &lt;&lt; a &lt;&lt; <span class="charliteral">' '</span> &lt;&lt; b &lt;&lt; endl;
00147         cout &lt;&lt; sumvar &lt;&lt; endl;
00148         cout &lt;&lt; y_mean &lt;&lt; endl;
00149         cout &lt;&lt; cov.sum() &lt;&lt; endl;
00150         exit(1);
00151     }
00152         
00153     Scaling s = Scaling(<span class="keyword">new</span> LinearScaling(a,b));
00154 
00155     <span class="keywordflow">return</span> s;
00156 }
00157 
00158 
00159 Scaling wls(<span class="keyword">const</span> std::valarray&lt;double&gt;&amp; inputs, <span class="keyword">const</span> TargetInfo&amp; targets) {
00160     
00161     std::valarray&lt;double&gt; x = inputs;
00162     <span class="keyword">const</span> std::valarray&lt;double&gt;&amp; w = targets.weights();
00163     
00164     <span class="keywordtype">unsigned</span> n = x.size();
00165     <span class="comment">// First calculate x'*W (as W is a diagonal matrix it's simply elementwise multiplication</span>
00166     std::valarray&lt;double&gt; wx = targets.weights() * x;
00167     
00168     <span class="comment">// Now x'*W is contained in [w,wx], calculate x' * W * x (the covariance)</span>
00169     <span class="keywordtype">double</span> a,b,d;
00170     a=b=d=0.0;
00171     
00172     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; n; ++i)
00173     {
00174         a += w[i];
00175         b += wx[i];
00176         d += x[i] * wx[i];
00177     }
00178  
00179     <span class="comment">//invert</span>
00180     
00181     <span class="keywordtype">double</span> ad_bc = a*d - b * b;
00182     <span class="comment">// if ad_bc equals zero there's a problem</span>
00183    
00184     <span class="keywordflow">if</span> (ad_bc &lt; 1e-17) <span class="keywordflow">return</span> Scaling(<span class="keyword">new</span> LinearScaling);
00185     
00186     <span class="keywordtype">double</span> ai = d/ad_bc;
00187     <span class="keywordtype">double</span> bi = -b/ad_bc;
00188     <span class="keywordtype">double</span> di = a/ad_bc;
00189     <span class="keywordtype">double</span> ci = bi;
00190     
00191     <span class="comment">// Now multiply this inverted covariance matrix (C^-1) with x' * W * y</span>
00192     
00193     <span class="comment">// create alias to reuse the wx we do not need anymore</span>
00194     std::valarray&lt;double&gt;&amp; ones = wx;
00195     
00196     <span class="comment">// calculate C^-1 * x' * W (using the fact that W is diagonal)</span>
00197     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; n; ++i) 
00198     {
00199         ones[i] = w[i]*(ai + bi * x[i]);
00200         x[i]    = w[i]*(ci + di * x[i]);
00201     }
00202 
00203     <span class="comment">// results are in [ones, x], now multiply with y</span>
00204 
00205     a = 0.0; <span class="comment">// intercept</span>
00206     b = 0.0; <span class="comment">// slope</span>
00207     
00208     <span class="keyword">const</span> valarray&lt;double&gt;&amp; t = targets.targets();
00209     
00210     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; n; ++i)
00211     {
00212         a += ones[i] * t[i];
00213         b += x[i] * t[i];
00214     }
00215     
00216     <span class="keywordflow">return</span> Scaling(<span class="keyword">new</span> LinearScaling(a,b));
00217 }
00218 
00219 
00220 <span class="comment">//Scaling med(const std::valarray&lt;double&gt;&amp; inputs, const TargetInfo&amp; targets);</span>
00221 
00222 <span class="keywordtype">double</span> mse(<span class="keyword">const</span> std::valarray&lt;double&gt;&amp; y, <span class="keyword">const</span> TargetInfo&amp; t) {
00223 
00224     valarray&lt;double&gt; residuals = t.targets()-y;
00225     residuals *= residuals;
00226     <span class="keywordtype">double</span> sz = residuals.size();
00227     <span class="keywordflow">if</span> (t.has_weights()) {
00228         residuals *= t.weights();
00229         sz = 1.0;
00230     }
00231         
00232     <span class="keywordflow">return</span> residuals.sum() / sz;
00233 }
00234 
00235 <span class="keywordtype">double</span> rms(<span class="keyword">const</span> std::valarray&lt;double&gt;&amp; y, <span class="keyword">const</span> TargetInfo&amp; t) {
00236     <span class="keywordflow">return</span> sqrt(mse(y,t));
00237 }
00238     
00239 <span class="keywordtype">double</span> mae(<span class="keyword">const</span> std::valarray&lt;double&gt;&amp; y, <span class="keyword">const</span> TargetInfo&amp; t) {
00240     valarray&lt;double&gt; residuals = abs(t.targets()-y);
00241     <span class="keywordflow">if</span> (t.has_weights()) residuals *= t.weights();
00242     <span class="keywordflow">return</span> residuals.sum() / residuals.size();
00243 }
00244 
00245 
00246 <span class="comment">/*</span>
00247 <span class="comment">    double standard_error(const std::valarray&lt;double&gt;&amp; y, const std::pair&lt;double,double&gt;&amp; scaling) {</span>
00248 <span class="comment">        double a = scaling.first;</span>
00249 <span class="comment">        double b = scaling.second;</span>
00250 <span class="comment">        double n = y.size();</span>
00251 <span class="comment">        double se = sqrt( pow(a+b*y-current_set-&gt;targets,2.0).sum() / (n-2));</span>
00252 <span class="comment">        </span>
00253 <span class="comment">        double mean_y = y.sum() / n;</span>
00254 <span class="comment">        double sxx = pow( y - mean_y, 2.0).sum();</span>
00255 <span class="comment"></span>
00256 <span class="comment">        return se / sqrt(sxx);</span>
00257 <span class="comment">    }</span>
00258 <span class="comment">  </span>
00259 <span class="comment">    double scaled_mse(const std::valarray&lt;double&gt;&amp; y){</span>
00260 <span class="comment">        std::pair&lt;double,double&gt; scaling;</span>
00261 <span class="comment">        return scaled_mse(y,scaling);</span>
00262 <span class="comment">    }</span>
00263 <span class="comment">    </span>
00264 <span class="comment">    double scaled_mse(const std::valarray&lt;double&gt;&amp; y, std::pair&lt;double, double&gt;&amp; scaling)</span>
00265 <span class="comment">    {</span>
00266 <span class="comment">        scaling = scale(y);</span>
00267 <span class="comment">        </span>
00268 <span class="comment">        double a = scaling.first;</span>
00269 <span class="comment">        double b = scaling.second;</span>
00270 <span class="comment">        </span>
00271 <span class="comment">        std::valarray&lt;double&gt; tmp = current_set-&gt;targets - a - b * y;</span>
00272 <span class="comment">        tmp *= tmp;</span>
00273 <span class="comment">        </span>
00274 <span class="comment">        if (weights.size())</span>
00275 <span class="comment">            return (weights * tmp).sum();</span>
00276 <span class="comment"></span>
00277 <span class="comment">        return tmp.sum() / tmp.size();</span>
00278 <span class="comment">    }</span>
00279 <span class="comment">   </span>
00280 <span class="comment">    double robust_mse(const std::valarray&lt;double&gt;&amp; ny, std::pair&lt;double, double&gt;&amp; scaling) {</span>
00281 <span class="comment">        </span>
00282 <span class="comment">        double smse = scaled_mse(ny,scaling);</span>
00283 <span class="comment"></span>
00284 <span class="comment">        std::valarray&lt;double&gt; y = ny;</span>
00285 <span class="comment">        // find maximum covariance case </span>
00286 <span class="comment">        double n = y.size();</span>
00287 <span class="comment"></span>
00288 <span class="comment">        int largest = 0;</span>
00289 <span class="comment">        </span>
00290 <span class="comment">        {</span>
00291 <span class="comment">            double y_mean = y.sum() / n;</span>
00292 <span class="comment">        </span>
00293 <span class="comment">            std::valarray&lt;double&gt; y_var = (y - y_mean);</span>
00294 <span class="comment">            std::valarray&lt;double&gt; cov = tcov * y_var;</span>
00295 <span class="comment">        </span>
00296 <span class="comment">            std::valarray&lt;bool&gt; maxcov = cov == cov.max();</span>
00297 <span class="comment">        </span>
00298 <span class="comment">            for (unsigned i = 0; i &lt; maxcov.size(); ++i) {</span>
00299 <span class="comment">                if (maxcov[i]) {</span>
00300 <span class="comment">                    largest = i;</span>
00301 <span class="comment">                    break;</span>
00302 <span class="comment">                }</span>
00303 <span class="comment">            }</span>
00304 <span class="comment">        }</span>
00305 <span class="comment">        </span>
00306 <span class="comment">        double y_mean = (y.sum() - y[largest]) / (n-1);</span>
00307 <span class="comment">        y[largest] = y_mean; // dissappears from covariance calculation</span>
00308 <span class="comment">        </span>
00309 <span class="comment">        std::valarray&lt;double&gt; y_var = (y - y_mean);</span>
00310 <span class="comment">        std::valarray&lt;double&gt; cov = tcov * y_var;</span>
00311 <span class="comment">        y_var *= y_var;</span>
00312 <span class="comment"></span>
00313 <span class="comment">        double sumvar = y_var.sum();</span>
00314 <span class="comment">        </span>
00315 <span class="comment">        if (sumvar == 0. || sumvar/n &lt; 1e-7 || sumvar/n &gt; 1e+7) // breakout when numerical problems are likely</span>
00316 <span class="comment">            return worst_performance();</span>
00317 <span class="comment">        </span>
00318 <span class="comment">        double b = cov.sum() / sumvar;</span>
00319 <span class="comment">        double a = tmean - b * y_mean;</span>
00320 <span class="comment">        </span>
00321 <span class="comment">        std::valarray&lt;double&gt; tmp = current_set-&gt;targets - a - b * y;</span>
00322 <span class="comment">        tmp[largest] = 0.0;</span>
00323 <span class="comment">        tmp *= tmp;</span>
00324 <span class="comment">        </span>
00325 <span class="comment">        double smse2 = tmp.sum() / (tmp.size()-1);</span>
00326 <span class="comment">        </span>
00327 <span class="comment">        static std::ofstream os("smse.txt");</span>
00328 <span class="comment">        os &lt;&lt; smse &lt;&lt; ' ' &lt;&lt; smse2 &lt;&lt; '\n';</span>
00329 <span class="comment">        </span>
00330 <span class="comment">        if (smse2 &gt; smse) {</span>
00331 <span class="comment">            return worst_performance();</span>
00332 <span class="comment">            //std::cerr &lt;&lt; "overfit? " &lt;&lt; smse &lt;&lt; ' ' &lt;&lt; smse2 &lt;&lt; '\n';</span>
00333 <span class="comment">        }</span>
00334 <span class="comment">        </span>
00335 <span class="comment">        scaling.first = a;</span>
00336 <span class="comment">        scaling.second = b;</span>
00337 <span class="comment">        </span>
00338 <span class="comment">        return smse2;</span>
00339 <span class="comment">    }</span>
00340 <span class="comment">    </span>
00341 <span class="comment">    class Sorter {</span>
00342 <span class="comment">        const std::valarray&lt;double&gt;&amp; scores;</span>
00343 <span class="comment">        public:</span>
00344 <span class="comment">            Sorter(const std::valarray&lt;double&gt;&amp; _scores) : scores(_scores) {}</span>
00345 <span class="comment">            </span>
00346 <span class="comment">            bool operator()(unsigned i, unsigned j) const {</span>
00347 <span class="comment">                return scores[i] &lt; scores[j];</span>
00348 <span class="comment">            }</span>
00349 <span class="comment">    };</span>
00350 <span class="comment">    </span>
00351 <span class="comment">    double coc(const std::valarray&lt;double&gt;&amp; y) {</span>
00352 <span class="comment">        std::vector&lt;unsigned&gt; indices(y.size());</span>
00353 <span class="comment">        for (unsigned i = 0; i &lt; y.size(); ++i) indices[i] = i;</span>
00354 <span class="comment">        std::sort(indices.begin(), indices.end(), Sorter(y));</span>
00355 <span class="comment">        </span>
00356 <span class="comment">        const std::valarray&lt;double&gt;&amp; targets = current_set-&gt;targets;</span>
00357 <span class="comment">        </span>
00358 <span class="comment">        double neg = 1.0 - targets[indices[0]];</span>
00359 <span class="comment">        double pos = targets[indices[0]];</span>
00360 <span class="comment">        </span>
00361 <span class="comment">        double cumpos = 0;</span>
00362 <span class="comment">        double cumneg = 0;</span>
00363 <span class="comment">        double sum=0;</span>
00364 <span class="comment">        </span>
00365 <span class="comment">        double last_score = y[indices[0]];</span>
00366 <span class="comment">        </span>
00367 <span class="comment">        for(unsigned i = 1; i &lt; targets.size(); ++i) {</span>
00368 <span class="comment">                </span>
00369 <span class="comment">            if (fabs(y[indices[i]] - last_score) &lt; 1e-9) { // we call it tied</span>
00370 <span class="comment">                pos += targets[indices[i]];</span>
00371 <span class="comment">                neg += 1.0 - targets[indices[i]];</span>
00372 <span class="comment">                </span>
00373 <span class="comment">                if (i &lt; targets.size()-1)</span>
00374 <span class="comment">                    continue;</span>
00375 <span class="comment">            }</span>
00376 <span class="comment">            sum += pos * cumneg + (pos * neg) * 0.5;</span>
00377 <span class="comment">            cumneg += neg;</span>
00378 <span class="comment">            cumpos += pos;</span>
00379 <span class="comment">            pos = targets[indices[i]];</span>
00380 <span class="comment">            neg = 1.0 - targets[indices[i]];</span>
00381 <span class="comment">            last_score = y[indices[i]];</span>
00382 <span class="comment">        }</span>
00383 <span class="comment">        </span>
00384 <span class="comment">        return sum / (cumneg * cumpos);</span>
00385 <span class="comment">    }</span>
00386 <span class="comment">   </span>
00387 <span class="comment">    // iterative re-weighted least squares (for parameters.classification)</span>
00388 <span class="comment">    double irls(const std::valarray&lt;double&gt;&amp; scores, std::pair&lt;double,double&gt;&amp; scaling) {</span>
00389 <span class="comment">        const std::valarray&lt;double&gt;&amp; t = current_set-&gt;targets;</span>
00390 <span class="comment">        </span>
00391 <span class="comment">        std::valarray&lt;double&gt; e(scores.size());</span>
00392 <span class="comment">        std::valarray&lt;double&gt; u(scores.size()); </span>
00393 <span class="comment">        std::valarray&lt;double&gt; w(scores.size());</span>
00394 <span class="comment">        std::valarray&lt;double&gt; z(scores.size());</span>
00395 <span class="comment">        </span>
00396 <span class="comment">        parameters.use_irls = false; parameters.classification=false;</span>
00397 <span class="comment">        scaling = scale(scores);</span>
00398 <span class="comment">        parameters.use_irls=true;parameters.classification=true;</span>
00399 <span class="comment">        </span>
00400 <span class="comment">        if (scaling.second == 0.0) return worst_performance(); </span>
00401 <span class="comment">        </span>
00402 <span class="comment">        for (unsigned i = 0; i &lt; 10; ++i) {</span>
00403 <span class="comment">            e = exp(scaling.first + scaling.second*scores);</span>
00404 <span class="comment">            u = e / (e + exp(-(scaling.first + scaling.second * scores)));</span>
00405 <span class="comment">            w = u*(1.-u);</span>
00406 <span class="comment">            z = (t-u)/w;</span>
00407 <span class="comment">            scaling = wls(scores, u, w);</span>
00408 <span class="comment">            //double ll = (log(u)*t + (1.-log(u))*(1.-t)).sum();</span>
00409 <span class="comment">            //std::cout &lt;&lt; "Scale " &lt;&lt; i &lt;&lt; ' ' &lt;&lt; scaling.first &lt;&lt; " " &lt;&lt; scaling.second &lt;&lt; " LL " &lt;&lt; 2*ll &lt;&lt; std::endl;</span>
00410 <span class="comment">        }</span>
00411 <span class="comment"></span>
00412 <span class="comment">        // log-likelihood</span>
00413 <span class="comment">        u = exp(scaling.first + scaling.second*scores) / (1 + exp(scaling.first + scaling.second*scores));</span>
00414 <span class="comment">        double ll = (log(u)*t + (1.-log(u))*(1.-t)).sum();</span>
00415 <span class="comment">        return 2*ll;</span>
00416 <span class="comment">    }</span>
00417 <span class="comment">*/</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Thu Oct 19 05:06:42 2006 for EO by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
