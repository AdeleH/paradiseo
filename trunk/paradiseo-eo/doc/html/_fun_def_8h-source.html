<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>EO: FunDef.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<div class="nav">
<a class="el" href="dir_000007.html">contrib</a>&nbsp;/&nbsp;<a class="el" href="dir_000008.html">mathsym</a>&nbsp;/&nbsp;<a class="el" href="dir_000022.html">fun</a></div>
<h1>FunDef.h</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">/*          </span>
00002 <span class="comment"> *             Copyright (C) 2005 Maarten Keijzer</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> *          This program is free software; you can redistribute it and/or modify</span>
00005 <span class="comment"> *          it under the terms of version 2 of the GNU General Public License as </span>
00006 <span class="comment"> *          published by the Free Software Foundation. </span>
00007 <span class="comment"> *</span>
00008 <span class="comment"> *          This program is distributed in the hope that it will be useful,</span>
00009 <span class="comment"> *          but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00010 <span class="comment"> *          MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00011 <span class="comment"> *          GNU General Public License for more details.</span>
00012 <span class="comment"> *</span>
00013 <span class="comment"> *          You should have received a copy of the GNU General Public License</span>
00014 <span class="comment"> *          along with this program; if not, write to the Free Software</span>
00015 <span class="comment"> *          Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
00016 <span class="comment"> */</span>
00017 
00018 <span class="preprocessor">#ifndef FUNCTION_DEF_H_</span>
00019 <span class="preprocessor"></span><span class="preprocessor">#define FUNCTION_DEF_H_</span>
00020 <span class="preprocessor"></span>
00021 <span class="preprocessor">#include &lt;string&gt;</span>
00022 <span class="preprocessor">#include &lt;vector&gt;</span>
00023 <span class="preprocessor">#include &lt;memory&gt;</span>
00024 <span class="preprocessor">#include &lt;iostream&gt;</span>
00025 
00026 <span class="preprocessor">#include "Sym.h"</span>
00027 <span class="preprocessor">#include "Interval.h"</span>
00028 
00029 <span class="keyword">class </span>FunDef {
00030     <span class="keyword">public</span>:
00031     
00032     <span class="keyword">virtual</span> ~FunDef() {}
00033     
00034     <span class="comment">// (possibly) lazy evaluation function, default implementation calls 'eager' eval</span>
00035     <span class="keyword">virtual</span> <span class="keywordtype">double</span> eval(<span class="keyword">const</span> SymVec&amp;   args, <span class="keyword">const</span> std::vector&lt;double&gt;&amp; inputs) <span class="keyword">const</span>;
00036 
00037     <span class="comment">// eager evaluation function </span>
00038     <span class="keyword">virtual</span> <span class="keywordtype">double</span> eval(<span class="keyword">const</span> std::vector&lt;double&gt;&amp; args, <span class="keyword">const</span> std::vector&lt;double&gt;&amp; inputs) <span class="keyword">const </span>= 0;
00039    
00040     <span class="comment">// interval evaluation</span>
00041     <span class="keyword">virtual</span> Interval eval(<span class="keyword">const</span> std::vector&lt;Interval&gt;&amp; args, <span class="keyword">const</span> std::vector&lt;Interval&gt;&amp; inputs) <span class="keyword">const </span>= 0; 
00042     
00043     <span class="comment">// prints 'c' like code</span>
00044     <span class="keyword">virtual</span> std::string c_print(<span class="keyword">const</span> std::vector&lt;std::string&gt;&amp;   names, <span class="keyword">const</span> std::vector&lt;std::string&gt;&amp; names) <span class="keyword">const </span>= 0;
00045 
00046     <span class="keyword">virtual</span> <span class="keywordtype">unsigned</span> min_arity() <span class="keyword">const </span>= 0;
00047     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> has_varargs()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">false</span>; } <span class="comment">// sum, prod, min, max are variable arity</span>
00048 
00049     <span class="keyword">virtual</span> std::string name() <span class="keyword">const </span>= 0;
00050     
00051     <span class="keyword">protected</span>:
00052     
00053 };
00054 
00056 <span class="keyword">extern</span> std::vector&lt;const FunDef*&gt; get_defined_functions();
00057 
00059 <span class="keyword">extern</span> <span class="keyword">const</span> FunDef&amp; get_element(token_t token);
00060 
00062 <span class="keyword">extern</span> <span class="keywordtype">double</span>      eval(<span class="keyword">const</span> Sym&amp; sym, <span class="keyword">const</span> std::vector&lt;double&gt;&amp; inputs);
00063 
00065 <span class="keyword">extern</span> Interval eval(<span class="keyword">const</span> Sym&amp; sym, <span class="keyword">const</span> std::vector&lt;Interval&gt;&amp; inputs);
00066 
00068 <span class="keyword">extern</span> std::string c_print(<span class="keyword">const</span> Sym&amp; sym);
00069 
00071 <span class="keyword">extern</span> std::string c_print(<span class="keyword">const</span> Sym&amp; sym, <span class="keyword">const</span> std::vector&lt;std::string&gt;&amp; var_names);
00072 
00074 <span class="keyword">inline</span> std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, <span class="keyword">const</span> Sym&amp; sym) { <span class="keywordflow">return</span> os &lt;&lt; c_print(sym); }
00075 
00076 <span class="comment">/* Support for Ephemeral Random Constants (ERC) */</span>
00077 
00079 <span class="keyword">extern</span> Sym SymConst(<span class="keywordtype">double</span> value);
00081 <span class="keyword">extern</span> Sym SymVar(<span class="keywordtype">unsigned</span> idx);
00082 
00093 <span class="keyword">extern</span> Sym SymLambda(Sym expression);
00094 
00095 <span class="keyword">extern</span> Sym SymUnlambda(Sym sym);
00096 
00098 <span class="keyword">extern</span> Sym expand_all(Sym sym);
00099 <span class="keyword">extern</span> Sym compress(Sym sym);
00100 
00102 std::vector&lt;double&gt; get_constants(Sym sym);
00103 
00106 Sym set_constants(Sym sym, <span class="keyword">const</span> std::vector&lt;double&gt;&amp; constants);
00107 
00109 <span class="keyword">extern</span> <span class="keywordtype">bool</span> is_constant(token_t token);
00110 <span class="keyword">extern</span> <span class="keywordtype">double</span> get_constant_value(token_t token);
00112 <span class="keyword">extern</span> <span class="keywordtype">bool</span> is_variable(token_t token);
00113 <span class="keyword">extern</span> <span class="keywordtype">unsigned</span> get_variable_index(token_t token);
00114 
00116 <span class="keyword">extern</span> <span class="keywordtype">bool</span> is_lambda(token_t token);
00117 
00118 
00120 <span class="keyword">extern</span> Sym simplify(Sym sym);
00121 
00125 <span class="keyword">extern</span> Sym differentiate(Sym sym, token_t dx);
00126 <span class="keyword">struct </span>differentiation_error{}; <span class="comment">// thrown in case of ifltz</span>
00127 
00128 <span class="comment">/* Add function to the language table (and take a guess at the arity) */</span>
00129 <span class="keyword">class </span>LanguageTable;
00130 <span class="keyword">extern</span> <span class="keywordtype">void</span> add_function_to_table(LanguageTable&amp; table, token_t token);
00131 
00132 <span class="keyword">enum</span> {
00133     sum_token,
00134     prod_token,
00135     inv_token,
00136     min_token,
00137     pow_token,
00138     ifltz_token,
00139     sin_token, cos_token, tan_token,
00140     asin_token, acos_token, atan_token,
00141     sinh_token, cosh_token, tanh_token,
00142     acosh_token, asinh_token, atanh_token,
00143     exp_token, log_token,
00144     sqr_token, sqrt_token
00145 };
00146 
00147 <span class="comment">/* Defition of function overloads: for example, this define the function 'Sym sin(Sym)' */</span>
00148 
00149 <span class="preprocessor">#define HEADERFUNC(name) inline Sym name(Sym arg) { return Sym(name##_token, arg); }</span>
00150 <span class="preprocessor"></span>
00151 <span class="comment">/* This defines the tokens: sin_token, cos_token, etc. */</span>
00152 HEADERFUNC(inv);
00153 HEADERFUNC(sin);
00154 HEADERFUNC(cos);
00155 HEADERFUNC(tan);
00156 HEADERFUNC(asin);
00157 HEADERFUNC(acos);
00158 HEADERFUNC(atan);
00159 
00160 HEADERFUNC(sinh);
00161 HEADERFUNC(cosh);
00162 HEADERFUNC(tanh);
00163 HEADERFUNC(asinh);
00164 HEADERFUNC(acosh);
00165 HEADERFUNC(atanh);
00166 
00167 HEADERFUNC(exp);
00168 HEADERFUNC(log);
00169 
00170 HEADERFUNC(sqr);
00171 HEADERFUNC(sqrt);
00172 
00173 <span class="comment">/* Get the prototype functions out, this is needed for compilation */</span>
00174 <span class="keyword">extern</span> std::string get_prototypes();
00175 
00176 <span class="comment">// reading and writing in internal format, no parser for symbolic functions implemented yet</span>
00177 <span class="keyword">extern</span> std::string write_raw(<span class="keyword">const</span> Sym&amp; sym);
00178 <span class="keyword">extern</span> <span class="keywordtype">void</span> write_raw(std::ostream&amp; os, <span class="keyword">const</span> Sym&amp; sym);
00179 <span class="keyword">extern</span> Sym read_raw(std::string str);
00180 <span class="keyword">extern</span> Sym read_raw(std::istream&amp; is); 
00181 <span class="keyword">extern</span> <span class="keywordtype">void</span> read_raw(std::istream&amp; is, Sym&amp; sym); 
00182 
00183 <span class="preprocessor">#include "SymOps.h"</span>
00184 
00185 <span class="preprocessor">#endif</span>
00186 <span class="preprocessor"></span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Thu Oct 19 05:06:40 2006 for EO by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
