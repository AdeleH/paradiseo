<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>EO: node_pool.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<div class="nav">
<a class="el" href="dir_000000.html">src</a>&nbsp;/&nbsp;<a class="el" href="dir_000017.html">gp</a></div>
<h1>node_pool.h</h1><div class="fragment"><pre class="fragment">00001 
00018 <span class="preprocessor">#ifndef node_pool_h</span>
00019 <span class="preprocessor"></span><span class="preprocessor">#define node_pool_h</span>
00020 <span class="preprocessor"></span>
<a name="l00021"></a><a class="code" href="class_mem_pool.html">00021</a> <span class="keyword">class </span><a class="code" href="class_mem_pool.html">MemPool</a>
00022 {
00023 <span class="keyword">public</span> :
00024     
00025     <a class="code" href="class_mem_pool.html">MemPool</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sz) : esize(sz&lt;<span class="keyword">sizeof</span>(Link)? <span class="keyword">sizeof</span>(Link) : sz) {}
00026     ~<a class="code" href="class_mem_pool.html">MemPool</a>()
00027     {
00028         Chunk* n = chunks;
00029         <span class="keywordflow">while</span>(n)
00030         {
00031             Chunk* p = n;
00032             n = n-&gt;next;
00033             <span class="keyword">delete</span> p;
00034         }
00035     }
00036     
00037     <span class="keywordtype">void</span>* allocate()
00038     {
00039         <span class="keywordflow">if</span> (head == 0) grow();
00040         Link* p = head;
00041         head = p-&gt;next;
00042         <span class="keywordflow">return</span> static_cast&lt;void*&gt;(p);
00043     }
00044 
00045     <span class="keywordtype">void</span> deallocate(<span class="keywordtype">void</span>* b)
00046     {
00047         Link* p = static_cast&lt;Link*&gt;(b);
00048         p-&gt;next = head;
00049         head = p;
00050     }
00051 
00052 <span class="keyword">private</span> :
00053 
00054     <span class="keywordtype">void</span> grow()
00055     {
00056         Chunk* n = <span class="keyword">new</span> Chunk;
00057         n-&gt;next = chunks;
00058         chunks = n;
00059 
00060         <span class="keyword">const</span> <span class="keywordtype">int</span> nelem = Chunk::size/esize;
00061         <span class="keywordtype">char</span>* start = n-&gt;mem;
00062         <span class="keywordtype">char</span>* last  = &amp;start[(nelem-1)*esize];
00063         <span class="keywordflow">for</span> (<span class="keywordtype">char</span>* p = start; p &lt; last; p += esize)
00064         {
00065             reinterpret_cast&lt;Link*&gt;(p)-&gt;next = 
00066                 reinterpret_cast&lt;Link*&gt;(p + esize);
00067         }
00068         
00069         reinterpret_cast&lt;Link*&gt;(last)-&gt;next = 0;
00070         head = reinterpret_cast&lt;Link*&gt;(start);
00071     }
00072 
00073     <span class="keyword">struct </span>Link
00074     {
00075         Link* next;
00076     };
00077 
00078     <span class="keyword">struct </span>Chunk
00079     {
00080         <span class="keyword">enum</span> {size = 8 * 1024 - 16};
00081         Chunk* next;
00082         <span class="keywordtype">char</span> mem[size];
00083     };
00084 
00085     Chunk* chunks;
00086     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> esize;
00087     Link* head;
00088 };
00089 
00090 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
00091 <span class="keyword">class </span>Node_alloc
00092 {
00093 <span class="keyword">public</span> :
00094     
00095     T* allocate(<span class="keywordtype">void</span>) 
00096     {
00097         T* t = static_cast&lt;T*&gt;(mem.allocate());
00098         t = <span class="keyword">new</span>  (t) T;
00099         <span class="keywordflow">return</span> t;
00100     }
00101     
00102     T* construct(<span class="keyword">const</span> T&amp; org) 
00103     {
00104         T* t = static_cast&lt;T*&gt;(mem.allocate());
00105         t = <span class="keyword">new</span>  (t) T(org);
00106         <span class="keywordflow">return</span> t;
00107     }
00108 
00109     <span class="keywordtype">void</span> deallocate(T* t)
00110     {
00111         t-&gt;~T(); <span class="comment">// call destructor</span>
00112         mem.deallocate(static_cast&lt;void*&gt;(t));
00113     }
00114 
00115 <span class="keyword">private</span> :
00116     <span class="keyword">static</span> <a class="code" href="class_mem_pool.html">MemPool</a> mem;
00117 };
00118 
00119 
00120 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; 
00121 <span class="keyword">class </span>Standard_alloc
00122 {
00123 <span class="keyword">public</span> :
00124     Standard_alloc() {}
00125 
00126     T* allocate(size_t arity = 1)
00127     {
00128         <span class="keywordflow">if</span> (arity == 0)
00129             <span class="keywordflow">return</span> 0;
00130 
00131         <span class="keywordflow">return</span> <span class="keyword">new</span> T [arity];
00132     }
00133     
00134     T* construct(size_t arity, T* org)
00135     {
00136         <span class="keywordflow">if</span> (arity == 0)
00137             <span class="keywordflow">return</span> 0;
00138 
00139         T* t = <span class="keyword">new</span> T [arity];
00140 
00141         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; arity; ++i)
00142         {
00143             t = T(org[i]);
00144         }
00145     }
00146 
00147     <span class="keywordtype">void</span> deallocate(T* t, size_t arity = 1)
00148     {
00149         <span class="keywordflow">if</span> (arity == 0)
00150             return ;
00151 
00152         <span class="keyword">delete</span> [] t;
00153     }
00154 
00155 };
00156 
00157 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; 
00158 <span class="keyword">class </span>Standard_Node_alloc
00159 {
00160 <span class="keyword">public</span> :
00161     Standard_Node_alloc() {}
00162 
00163     T* allocate(<span class="keywordtype">void</span>)
00164     {
00165         <span class="keywordflow">return</span> <span class="keyword">new</span> T;<span class="comment">// [arity];</span>
00166     }
00167 
00168     T* construct(<span class="keyword">const</span> T&amp; org)
00169     {
00170         <span class="keywordflow">return</span> <span class="keyword">new</span> T(org);
00171     }
00172 
00173     <span class="keywordtype">void</span> deallocate(T* t)
00174     {
00175         <span class="keyword">delete</span> t;
00176     }
00177 
00178 };
00179 
00180 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
00181 <span class="keyword">class </span>Tree_alloc
00182 {
00183 <span class="keyword">public</span> :
00184     Tree_alloc() {}
00185 
00186     T* allocate(size_t arity)
00187     {
00188         T* t;
00189 
00190         <span class="keywordflow">switch</span>(arity)
00191         {
00192 
00193         <span class="keywordflow">case</span> 0 : <span class="keywordflow">return</span> 0;
00194         <span class="keywordflow">case</span> 1 :
00195             {
00196                 t = static_cast&lt;T*&gt;(mem1.allocate());
00197                 <span class="keyword">new</span> (t) T;
00198                 <span class="keywordflow">break</span>;
00199             }
00200         <span class="keywordflow">case</span> 2 :
00201             {
00202                 t = static_cast&lt;T*&gt;(mem2.allocate());
00203                 <span class="keyword">new</span> (t) T;
00204                 <span class="keyword">new</span> (&amp;t[1]) T;
00205                 <span class="keywordflow">break</span>;
00206             }
00207         <span class="keywordflow">case</span> 3 :
00208             {
00209                 t = static_cast&lt;T*&gt;(mem3.allocate());
00210                 <span class="keyword">new</span> (t) T;
00211                 <span class="keyword">new</span> (&amp;t[1]) T;
00212                 <span class="keyword">new</span> (&amp;t[2]) T;
00213                 <span class="keywordflow">break</span>;
00214             }
00215         <span class="keywordflow">default</span> :
00216             {
00217                 <span class="keywordflow">return</span> <span class="keyword">new</span> T[arity];
00218             }
00219         }
00220 
00221         <span class="keywordflow">return</span> t;
00222      }
00223 
00224     T* construct(size_t arity, T* org)
00225     {
00226         T* t;
00227 
00228         <span class="keywordflow">switch</span>(arity)
00229         {
00230 
00231         <span class="keywordflow">case</span> 0 : <span class="keywordflow">return</span> 0;
00232         <span class="keywordflow">case</span> 1 :
00233             {
00234                 t = static_cast&lt;T*&gt;(mem1.allocate());
00235                 <span class="keyword">new</span> (t) T(*org);
00236                 <span class="keywordflow">break</span>;
00237             }
00238         <span class="keywordflow">case</span> 2 :
00239             {
00240                 t = static_cast&lt;T*&gt;(mem2.allocate());
00241                 <span class="keyword">new</span> (t) T(*org);
00242                 <span class="keyword">new</span> (&amp;t[1]) T(org[1]);
00243                 <span class="keywordflow">break</span>;
00244             }
00245         <span class="keywordflow">case</span> 3 :
00246             {
00247                 t = static_cast&lt;T*&gt;(mem3.allocate());
00248                 <span class="keyword">new</span> (t) T(*org);
00249                 <span class="keyword">new</span> (&amp;t[1]) T(org[1]);
00250                 <span class="keyword">new</span> (&amp;t[1]) T(org[2]);
00251                 <span class="keywordflow">break</span>;
00252             }
00253         <span class="keywordflow">default</span> :
00254             {
00255                 t = <span class="keyword">new</span> T[arity]; <span class="comment">// does call default ctor</span>
00256                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; arity; ++i)
00257                 {
00258                     t[i] = T(org[i]); <span class="comment">// constructs now</span>
00259                 }
00260             }
00261         }
00262 
00263         <span class="keywordflow">return</span> t;
00264      }
00265 
00266 
00267 
00268     <span class="keywordtype">void</span> deallocate(T* t, size_t arity)
00269     {
00270         <span class="keywordflow">switch</span>(arity)
00271         {
00272         <span class="keywordflow">case</span> 0: <span class="keywordflow">return</span>;
00273         <span class="keywordflow">case</span> 3 : 
00274             {
00275                 t[2].~T(); t[1].~T(); t[0].~T();
00276                 mem3.deallocate(static_cast&lt;void*&gt;(t));
00277                 <span class="keywordflow">return</span>;
00278             }
00279         <span class="keywordflow">case</span> 2 : 
00280             {
00281                 t[1].~T(); t[0].~T();
00282                 mem2.deallocate(static_cast&lt;void*&gt;(t));
00283                 <span class="keywordflow">return</span>;
00284             }
00285         <span class="keywordflow">case</span> 1 : 
00286             {
00287                 t[0].~T();
00288                 mem1.deallocate(static_cast&lt;void*&gt;(t));
00289                 <span class="keywordflow">return</span>;
00290             }
00291         <span class="keywordflow">default</span> :
00292             {
00293                 <span class="keyword">delete</span> [] t;
00294                 <span class="keywordflow">return</span>;
00295             }
00296         }
00297     }
00298     
00299 
00300 <span class="keyword">private</span> :
00301     <span class="keyword">static</span> <a class="code" href="class_mem_pool.html">MemPool</a> mem1;
00302     <span class="keyword">static</span> <a class="code" href="class_mem_pool.html">MemPool</a> mem2;
00303     <span class="keyword">static</span> <a class="code" href="class_mem_pool.html">MemPool</a> mem3;
00304 };
00305 
00306 <span class="comment">// static (non thread_safe) memory pools</span>
00307 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; <a class="code" href="class_mem_pool.html">MemPool</a> Node_alloc&lt;T&gt;::mem  = <span class="keyword">sizeof</span>(T);
00308 
00309 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; <a class="code" href="class_mem_pool.html">MemPool</a> Tree_alloc&lt;T&gt;::mem1 = <span class="keyword">sizeof</span>(T);
00310 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; <a class="code" href="class_mem_pool.html">MemPool</a> Tree_alloc&lt;T&gt;::mem2 = <span class="keyword">sizeof</span>(T) * 2;
00311 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; <a class="code" href="class_mem_pool.html">MemPool</a> Tree_alloc&lt;T&gt;::mem3 = <span class="keyword">sizeof</span>(T) * 3;
00312 
00313 <span class="preprocessor">#endif</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Thu Oct 19 05:06:41 2006 for EO by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
