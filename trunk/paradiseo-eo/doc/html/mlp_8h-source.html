<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>EO: mlp.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<div class="nav">
<a class="el" href="dir_000020.html">app</a>&nbsp;/&nbsp;<a class="el" href="dir_000023.html">gprop</a></div>
<h1>mlp.h</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">//-----------------------------------------------------------------------------</span>
00002 <span class="comment">// mlp.h</span>
00003 <span class="comment">//-----------------------------------------------------------------------------</span>
00004 
00005 <span class="preprocessor">#ifndef mlp_h</span>
00006 <span class="preprocessor"></span><span class="preprocessor">#define mlp_h</span>
00007 <span class="preprocessor"></span>
00008 <span class="preprocessor">#include &lt;algorithm&gt;</span>              <span class="comment">// generate</span>
00009 <span class="preprocessor">#include &lt;cmath&gt;</span>                  <span class="comment">// exp</span>
00010 <span class="preprocessor">#include &lt;iostream&gt;</span>
00011 <span class="preprocessor">#include &lt;iterator&gt;</span>
00012 <span class="preprocessor">#include &lt;numeric&gt;</span>
00013 <span class="preprocessor">#include &lt;stdexcept&gt;</span>              <span class="comment">// invalid_argument</span>
00014 <span class="preprocessor">#include &lt;utility&gt;</span>
00015 <span class="preprocessor">#include &lt;vector&gt;</span>
00016 <span class="preprocessor">#include &lt;utils/eoRNG.h&gt;</span>          <span class="comment">// eoRng</span>
00017 <span class="preprocessor">#include &lt;utils/rnd_generators.h&gt;</span> <span class="comment">// normal_generator</span>
00018 <span class="preprocessor">#include &lt;vecop.h&gt;</span>                <span class="comment">// *</span>
00019 
00020 
00021 
00022 
00023 <span class="keyword">namespace </span>mlp
00024 {
00025     <span class="keyword">using</span> <span class="keyword">namespace </span>std;
00026 
00027     <span class="keyword">typedef</span> <span class="keywordtype">double</span> real;
00028     <span class="keyword">typedef</span> std::vector&lt;real&gt; vector;
00029 }
00030 
00031 
00032 <span class="keyword">namespace </span>std {
00033   ostream&amp; operator&lt;&lt;(ostream&amp; os, <span class="keyword">const</span> mlp::vector&amp; v)
00034   {
00035     ostream_iterator&lt;mlp::real&gt; oi(os, <span class="stringliteral">" "</span>);
00036     copy(v.begin(), v.end(), oi);
00037     <span class="keywordflow">return</span> os;
00038   }
00039 
00040   istream&amp; operator&gt;&gt;(istream&amp; is, mlp::vector&amp; v)
00041   {
00042     <span class="keywordflow">for</span> (mlp::vector::iterator vi = v.begin() ; vi != v.end() ; vi++) {
00043         is &gt;&gt; *vi;
00044     }
00045     <span class="keywordflow">return</span> is;
00046   }
00047 }
00048 
00049 <span class="keyword">namespace </span>mlp
00050 {
00051   <span class="keyword">using</span> <span class="keyword">namespace </span>std;
00052 
00053   <span class="comment">//---------------------------------------------------------------------------</span>
00054   <span class="comment">// useful typedefs</span>
00055   <span class="comment">//---------------------------------------------------------------------------</span>
00056 
00057 
00058   <span class="keyword">const</span> real max_real = std::numeric_limits&lt;real&gt;::max();
00059   <span class="keyword">const</span> real min_real = std::numeric_limits&lt;real&gt;::min();
00060 
00061 
00062   <span class="comment">//---------------------------------------------------------------------------</span>
00063   <span class="comment">// sigmoid</span>
00064   <span class="comment">//---------------------------------------------------------------------------</span>
00065 
00066   real sigmoid(<span class="keyword">const</span> real&amp; x)
00067   {
00068     <span class="keywordflow">return</span> 1.0 / (1.0 + exp(-x));
00069   }
00070 
00071 
00072   <span class="comment">//---------------------------------------------------------------------------</span>
00073   <span class="comment">// neuron</span>
00074   <span class="comment">//---------------------------------------------------------------------------</span>
00075 
00076   <span class="keyword">struct </span>neuron
00077   {
00078     real   bias;
00079     vector weight;
00080 
00081     neuron(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; num_inputs = 0): weight(num_inputs) {}
00082 
00083     <span class="keywordtype">void</span> reset()
00084     {
00085       <a class="code" href="classnormal__generator.html">normal_generator&lt;real&gt;</a> rnd(1.0);
00086       bias = rnd();
00087       generate(weight.begin(), weight.end(), rnd);
00088     }
00089 
00090     real operator()(<span class="keyword">const</span> vector&amp; input)<span class="keyword"> const</span>
00091 <span class="keyword">    </span>{
00092       <span class="keywordflow">return</span> sigmoid(bias + weight * input);
00093     }
00094 
00095     <span class="keywordtype">unsigned</span> length()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> weight.size() + 1; }
00096 
00097     <span class="keywordtype">void</span> normalize()
00098     {
00099       real n = sqrt(bias * bias + weight * weight);
00100       bias /= n;
00101       weight /= n;
00102     }
00103 
00104     <span class="keywordtype">void</span> desaturate()
00105     {
00106       bias = -5.0 + 10.0 / (1.0 + exp(bias / -5.0));
00107 
00108       <span class="keywordflow">for</span> (vector::iterator w = weight.begin(); w != weight.end(); ++w)
00109         *w = -5.0 + 10.0 / (1.0 + exp(*w / -5.0));
00110     }
00111 
00112     <span class="keywordtype">void</span> perturb_num(<span class="keywordtype">double</span> &amp;num, <span class="keywordtype">double</span> magnitude) {
00113        <span class="keywordtype">double</span> scale = max(num, 0.05) * magnitude;
00114        <span class="keywordtype">double</span> perturbation = scale * (drand48() - 0.5);
00115        num += perturbation;
00116     }
00117 
00118     <span class="keywordtype">void</span> perturb(<span class="keywordtype">double</span> magnitude = 0.3, <span class="keywordtype">double</span> probability = 1.0)
00119     {
00120 
00121       <span class="keywordflow">for</span> (vector::iterator w = weight.begin(); w != weight.end(); ++w)
00122           <span class="keywordflow">if</span> ( probability &gt;= 1.0 || drand48() &lt; probability)
00123               perturb_num(*w, magnitude);
00124       <span class="keywordflow">if</span> ( probability &gt;= 1.0 || drand48() &lt; probability)
00125         perturb_num(bias, magnitude);
00126     }
00127  };
00128 }
00129 
00130 <span class="keyword">namespace </span>std {
00131 
00132   ostream&amp; operator&lt;&lt;(ostream&amp; os, <span class="keyword">const</span> mlp::neuron&amp; n)
00133   {
00134     <span class="keywordflow">return</span> os &lt;&lt; n.bias &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; n.weight;
00135   }
00136 
00137   istream&amp; operator&gt;&gt;(istream&amp; is, mlp::neuron&amp; n)
00138   {
00139     <span class="keywordflow">return</span> is &gt;&gt; n.bias &gt;&gt; n.weight;
00140   }
00141 
00142 }
00143 
00144 <span class="keyword">namespace </span>mlp {
00145 
00146   <span class="comment">//---------------------------------------------------------------------------</span>
00147   <span class="comment">// layer</span>
00148   <span class="comment">//---------------------------------------------------------------------------</span>
00149 
00150   <span class="keyword">class </span>layer: <span class="keyword">public</span> std::vector&lt;neuron&gt;
00151   {
00152   <span class="keyword">public</span>:
00153     layer(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; num_inputs = 0, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; num_neurons = 0):
00154       std::vector&lt;neuron&gt;(num_neurons, neuron(num_inputs)) {}
00155 
00156     <span class="keywordtype">void</span> reset()
00157     {
00158       <a class="code" href="classnormal__generator.html">normal_generator&lt;real&gt;</a> rnd(1.0);
00159       <span class="keywordflow">for</span>(iterator n = begin(); n != end(); ++n)
00160         n-&gt;reset();
00161     }
00162 
00163     vector operator()(<span class="keyword">const</span> vector&amp; input)<span class="keyword"> const</span>
00164 <span class="keyword">    </span>{
00165       vector output(size());
00166 
00167       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i = 0; i &lt; output.size(); ++i)
00168         output[i] = (*this)[i](input);
00169 
00170       <span class="keywordflow">return</span> output;
00171     }
00172 
00173     <span class="keywordtype">unsigned</span> length()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> front().length() * size(); }
00174 
00175     <span class="keywordtype">void</span> normalize()
00176     {
00177       <span class="keywordflow">for</span>(iterator n = begin(); n != end(); ++n)
00178         n-&gt;normalize();
00179     }
00180 
00181     <span class="keywordtype">void</span> desaturate()
00182     {
00183       <span class="keywordflow">for</span>(iterator n = begin(); n != end(); ++n)
00184         n-&gt;desaturate();
00185     }
00186 
00187     <span class="keywordtype">void</span> perturb(<span class="keywordtype">double</span> magnitude = 0.3, <span class="keywordtype">double</span> probability = 1.0)
00188     {
00189       <span class="keywordflow">for</span>(iterator n = begin(); n != end(); ++n)
00190         n-&gt;perturb();
00191     }
00192 
00193   };
00194 
00195 }
00196 
00197 <span class="keyword">namespace </span>std {
00198 
00199   ostream&amp; operator&lt;&lt;(ostream&amp; os, <span class="keyword">const</span> mlp::layer&amp; l)
00200   {
00201     ostream_iterator&lt;mlp::neuron&gt; oi(os, <span class="stringliteral">" "</span>);
00202     copy(l.begin(), l.end(), oi);
00203     <span class="keywordflow">return</span> os;
00204   }
00205 
00206   istream&amp; operator&gt;&gt;(istream&amp; is, mlp::layer&amp; l)
00207   {
00208     <span class="keywordflow">for</span> (mlp::layer::iterator li = l.begin() ; li != l.end() ; li++) {
00209         is &gt;&gt; *li;
00210     }
00211     <span class="keywordflow">return</span> is;
00212   }
00213 
00214 }
00215 
00216 <span class="keyword">namespace </span>mlp {
00217 
00218 
00219   <span class="comment">//---------------------------------------------------------------------------</span>
00220   <span class="comment">// net</span>
00221   <span class="comment">//---------------------------------------------------------------------------</span>
00222 
00223   <span class="keyword">class </span>net: <span class="keyword">public</span> std::vector&lt;layer&gt;
00224   {
00225   <span class="keyword">public</span>:
00226     net(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; num_inputs = 0,
00227         <span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; num_outputs = 0,
00228         <span class="keyword">const</span> std::vector&lt;unsigned&gt;&amp; hidden = std::vector&lt;unsigned&gt;())
00229     {
00230       init(num_inputs,num_outputs,hidden);
00231     }
00232 
00233 
00234     net(istream &amp;is) {
00235         load(is);
00236     }
00237 
00239       <span class="keyword">virtual</span> ~net() {};
00240 
00241     <span class="keywordtype">void</span> load(istream &amp;is) {
00242         <span class="keywordtype">unsigned</span> num_inputs;
00243         <span class="keywordtype">unsigned</span> num_outputs;
00244         <span class="keywordtype">unsigned</span> num_hidden_layers;
00245 
00246         is &gt;&gt; num_inputs &gt;&gt; num_outputs &gt;&gt; num_hidden_layers;
00247 
00248         std::vector&lt;unsigned&gt; layer_sizes;
00249         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;num_hidden_layers;i++) {
00250            <span class="keywordtype">unsigned</span> layer_size;
00251            is &gt;&gt; layer_size;
00252            layer_sizes.push_back(layer_size);
00253         }
00254         <span class="keywordtype">unsigned</span> check_outputs;
00255         is &gt;&gt; check_outputs;
00256         assert (check_outputs ==  num_outputs);
00257         init (num_inputs,num_outputs,layer_sizes);
00258         <span class="comment">// skip forward to pass up opening '&lt;' char</span>
00259         <span class="keywordtype">char</span> c=<span class="charliteral">' '</span>;
00260         <span class="keywordflow">while</span> (c!=<span class="charliteral">'&lt;'</span> &amp;&amp; !is.eof()) { is &gt;&gt; c;}
00261         <span class="keywordflow">for</span> (iterator l =begin() ; l != end(); l++) {
00262             is &gt;&gt; *l;
00263         }
00264         <span class="keywordflow">do</span> { is &gt;&gt; c; } <span class="keywordflow">while</span> (c == <span class="charliteral">' '</span> &amp;&amp; !is.eof());
00265         assert(c == <span class="charliteral">'&gt;'</span>);
00266     }
00267 
00268     <span class="keywordtype">void</span> init( <span class="keywordtype">unsigned</span> num_inputs,
00269                <span class="keywordtype">unsigned</span> num_outputs,
00270                <span class="keyword">const</span> std::vector&lt;unsigned&gt;&amp; hidden ) {
00271       clear();
00272       <span class="keywordflow">switch</span>(hidden.size())
00273         {
00274         <span class="keywordflow">case</span> 0:
00275           push_back(layer(num_inputs, num_outputs));
00276           <span class="keywordflow">break</span>;
00277         <span class="keywordflow">default</span>:
00278           push_back(layer(num_inputs, hidden.front()));
00279           <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; hidden.size() - 1; ++i)
00280             push_back(layer(hidden[i], hidden[i + 1]));
00281           push_back(layer(hidden.back(), num_outputs));
00282           <span class="keywordflow">break</span>;
00283         }
00284     }
00285 
00286     <span class="keywordtype">void</span> reset()
00287     {
00288       <a class="code" href="classnormal__generator.html">normal_generator&lt;real&gt;</a> rnd(1.0);
00289       <span class="keywordflow">for</span>(iterator l = begin(); l != end(); ++l)
00290         l-&gt;reset();
00291     }
00292 
00293     <span class="keyword">virtual</span> vector operator()(<span class="keyword">const</span> vector&amp; input) <span class="keyword">const </span>;
00294 
00295     <span class="keywordtype">unsigned</span> winner(<span class="keyword">const</span> vector&amp; input)<span class="keyword"> const</span>
00296 <span class="keyword">    </span>{
00297       vector tmp = (*this)(input);
00298       <span class="keywordflow">return</span> (max_element(tmp.begin(), tmp.end()) - tmp.begin());
00299     }
00300 
00301     <span class="keywordtype">void</span> save(ostream &amp;os)<span class="keyword"> const </span>{
00302         <span class="comment">// Save the number of inputs, number of outputs, and number of hidden layers</span>
00303         os &lt;&lt; num_inputs() &lt;&lt; <span class="stringliteral">"\n"</span> &lt;&lt; num_outputs() &lt;&lt; <span class="stringliteral">"\n"</span> &lt;&lt; num_hidden_layers() &lt;&lt; <span class="stringliteral">"\n"</span>;
00304         <span class="keywordflow">for</span>(const_iterator l = begin(); l != end(); ++l)
00305            os &lt;&lt; l-&gt;size() &lt;&lt; <span class="stringliteral">" "</span>;
00306         os &lt;&lt; <span class="stringliteral">"\n"</span>;
00307         os &lt;&lt; *<span class="keyword">this</span>;
00308         os &lt;&lt; <span class="stringliteral">"\n"</span>;
00309     }
00310 
00311     <span class="keywordtype">unsigned</span> num_inputs()<span class="keyword">  const </span>{ <span class="keywordflow">return</span> front().front().length() - 1; }
00312     <span class="keywordtype">unsigned</span> num_outputs()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> back().size(); }
00313     <span class="keywordtype">unsigned</span> num_hidden_layers()<span class="keyword"> const </span>{
00314         <span class="keywordtype">signed</span> s = (signed) size() -1;
00315         <span class="keywordflow">return</span> (s&lt;0) ? 0 : s ;
00316     }
00317 
00318 
00319     <span class="keywordtype">unsigned</span> length()
00320     {
00321       <span class="keywordtype">unsigned</span> sum = 0;
00322 
00323       <span class="keywordflow">for</span>(iterator l = begin(); l != end(); ++l)
00324         sum += l-&gt;length();
00325 
00326       <span class="keywordflow">return</span> sum;
00327     }
00328 
00329     <span class="keywordtype">void</span> normalize()
00330     {
00331       <span class="keywordflow">for</span>(iterator l = begin(); l != end(); ++l)
00332         l-&gt;normalize();
00333     }
00334 
00335     <span class="keywordtype">void</span> desaturate()
00336     {
00337       <span class="keywordflow">for</span>(iterator l = begin(); l != end(); ++l)
00338         l-&gt;desaturate();
00339     }
00340 
00341     <span class="keywordtype">void</span> perturb(<span class="keywordtype">double</span> magnitude = 0.3, <span class="keywordtype">double</span> probability = 1.0)
00342     {
00343       <span class="keywordflow">for</span>(iterator l = begin(); l != end(); ++l)
00344         l-&gt;perturb();
00345     }
00346   };
00347 
00348 <span class="preprocessor">#ifndef NO_MLP_VIRTUALS</span>
00349 <span class="preprocessor"></span>    vector net::operator()(<span class="keyword">const</span> vector&amp; input)<span class="keyword"> const</span>
00350 <span class="keyword">    </span>{
00351       vector tmp = input;
00352 
00353       <span class="keywordflow">for</span>(const_iterator l = begin(); l != end(); ++l)
00354         tmp = (*l)(tmp);
00355 
00356       <span class="keywordflow">return</span> tmp;
00357     }
00358 <span class="preprocessor">#endif</span>
00359 <span class="preprocessor"></span>
00360 
00361   <span class="comment">//---------------------------------------------------------------------------</span>
00362   <span class="comment">// sample</span>
00363   <span class="comment">//---------------------------------------------------------------------------</span>
00364 
00365   <span class="keyword">struct </span>sample
00366   {
00367     vector input, output;
00368 
00369     sample(<span class="keywordtype">unsigned</span> input_size = 0, <span class="keywordtype">unsigned</span> output_size = 0):
00370       input(input_size), output(output_size) {}
00371   };
00372 
00373   istream&amp; operator&gt;&gt;(istream&amp; is, sample&amp; s)
00374   {
00375     <span class="keywordflow">return</span> is &gt;&gt; s.input &gt;&gt; s.output;
00376   }
00377 
00378   ostream&amp; operator&lt;&lt;(ostream&amp; os, <span class="keyword">const</span> sample&amp; s)
00379   {
00380     <span class="keywordflow">return</span> os &lt;&lt; s.input &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; s.output;
00381   }
00382 
00383 
00384   <span class="comment">//---------------------------------------------------------------------------</span>
00385   <span class="comment">// set</span>
00386   <span class="comment">//---------------------------------------------------------------------------</span>
00387 
00388   <span class="keyword">class </span>set: <span class="keyword">public</span> std::vector&lt;sample&gt;
00389   {
00390   <span class="keyword">public</span>:
00391     set(<span class="keywordtype">unsigned</span> input_size  = 0, <span class="keywordtype">unsigned</span> output_size = 0,
00392         <span class="keywordtype">unsigned</span> num_samples = 0):
00393       std::vector&lt;sample&gt;(num_samples, sample(input_size, output_size)) {}
00394 
00395     set(istream&amp; is) : std::vector&lt;sample&gt;(0, sample(0, 0)) {
00396         clear();
00397         load(is);
00398     }
00399 
00400     <span class="keywordtype">void</span> load(istream &amp;is) {
00401         <span class="keywordtype">unsigned</span> input_size, output_size;
00402         is &gt;&gt; input_size &gt;&gt; output_size;
00403         sample samp(input_size, output_size);;
00404         <span class="keywordflow">while</span> (is &gt;&gt; samp) { push_back(samp); }
00405     }
00406 
00407     <span class="keywordtype">void</span> save(ostream &amp;os)<span class="keyword"> const </span>{
00408         os &lt;&lt; front().input.size() &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; front().output.size() &lt;&lt; endl;
00409         copy(begin(), end(), ostream_iterator&lt;sample&gt;(os,<span class="stringliteral">"\n"</span>));
00410     }
00411   };
00412 
00413   ostream&amp; operator&lt;&lt;(ostream&amp; os, <span class="keyword">const</span> set&amp; s)
00414   {
00415     os &lt;&lt; <span class="stringliteral">"&lt;"</span> &lt;&lt; endl;
00416     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; s.size(); ++i)
00417       os &lt;&lt; s[i] &lt;&lt; endl;
00418     <span class="keywordflow">return</span> os &lt;&lt; <span class="stringliteral">"&gt;"</span>;
00419   }
00420 
00421   <span class="comment">//---------------------------------------------------------------------------</span>
00422   <span class="comment">// euclidean_distance</span>
00423   <span class="comment">//---------------------------------------------------------------------------</span>
00424 
00425   real euclidean_distance(<span class="keyword">const</span> net&amp; n1, <span class="keyword">const</span> net&amp; n2)
00426   {
00427     real sum = 0;
00428 
00429     <span class="keywordflow">for</span>(net::const_reverse_iterator l1 = n1.rbegin(), l2 = n2.rbegin();
00430         l1 != n1.rend() &amp;&amp; l2 != n2.rend(); ++l1, ++l2)
00431       <span class="keywordflow">for</span>(layer::const_iterator n1 = l1-&gt;begin(), n2 = l2-&gt;begin();
00432           n1 != l1-&gt;end() &amp;&amp; n2 != l2-&gt;end(); ++n1, ++n2)
00433         {
00434           real b = n1-&gt;bias - n2-&gt;bias;
00435           vector w = n1-&gt;weight - n2-&gt;weight;
00436           sum += b * b + w * w;
00437         }
00438     <span class="comment">/*</span>
00439 <span class="comment">      #include &lt;fstream&gt;</span>
00440 <span class="comment">      std::ofstream file("dist.stat", ios::app);</span>
00441 <span class="comment">      file &lt;&lt; sqrt(sum) &lt;&lt; endl;</span>
00442 <span class="comment">    */</span>
00443     <span class="keywordflow">return</span> sqrt(sum);
00444   }
00445 
00446   <span class="comment">//---------------------------------------------------------------------------</span>
00447 
00448 } <span class="comment">// namespace mlp</span>
00449 
00450 
00451 
00452 <span class="preprocessor">#endif // mlp_h</span>
00453 <span class="preprocessor"></span>
00454 
00455 <span class="comment">// Local Variables:</span>
00456 <span class="comment">// mode:C++</span>
00457 <span class="comment">// c-file-style: "Stroustrup"</span>
00458 <span class="comment">// End:</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Thu Oct 19 05:06:41 2006 for EO by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
