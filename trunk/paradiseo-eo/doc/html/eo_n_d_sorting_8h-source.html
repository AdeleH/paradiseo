<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>EO: eoNDSorting.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<div class="nav">
<a class="el" href="dir_000000.html">src</a></div>
<h1>eoNDSorting.h</h1><div class="fragment"><pre class="fragment">00001 
00025 <span class="comment">//-----------------------------------------------------------------------------</span>
00026 
00027 <span class="preprocessor">#ifndef eoNDSorting_h</span>
00028 <span class="preprocessor"></span><span class="preprocessor">#define eoNDSorting_h</span>
00029 <span class="preprocessor"></span>
00030 <span class="preprocessor">#include &lt;EO.h&gt;</span>
00031 <span class="preprocessor">#include &lt;algorithm&gt;</span>
00032 <span class="preprocessor">#include &lt;eoPop.h&gt;</span>
00033 <span class="preprocessor">#include &lt;eoPerf2Worth.h&gt;</span>
00034 <span class="preprocessor">#include &lt;cassert&gt;</span>
00035 
00041 <span class="keyword">template</span> &lt;<span class="keyword">class</span> EOT&gt;
<a name="l00042"></a><a class="code" href="classeo_n_d_sorting.html">00042</a> <span class="keyword">class </span><a class="code" href="classeo_n_d_sorting.html">eoNDSorting</a> : <span class="keyword">public</span> <a class="code" href="classeo_perf2_worth_cached.html">eoPerf2WorthCached</a>&lt;EOT, double&gt;
00043 {
00044   <span class="keyword">public</span> :
00045 
00046     <span class="keyword">using</span> <a class="code" href="classeo_perf2_worth_cached.html">eoPerf2WorthCached&lt;EOT, double&gt;</a>::value;
00047       <a class="code" href="classeo_n_d_sorting.html">eoNDSorting</a>(<span class="keywordtype">bool</span> nasty_flag_ = <span class="keyword">false</span>)
00048           : nasty_declone_flag_that_only_is_implemented_for_two_objectives(nasty_flag_)
00049         {}
00050 
00051 
00052     <a class="code" href="classeo_n_d_sorting.html">eoNDSorting</a>()
00053         : nasty_declone_flag_that_only_is_implemented_for_two_objectives(<span class="keyword">false</span>)
00054         {}
00055 
00060     <span class="keyword">virtual</span> std::vector&lt;double&gt; <a class="code" href="classeo_n_d_sorting.html#a2">niche_penalty</a>(<span class="keyword">const</span> std::vector&lt;unsigned&gt;&amp; current_front, <span class="keyword">const</span> <a class="code" href="classeo_pop.html">eoPop&lt;EOT&gt;</a>&amp; _pop) = 0;
00061 
<a name="l00062"></a><a class="code" href="classeo_n_d_sorting.html#a3">00062</a>     <span class="keywordtype">void</span> <a class="code" href="classeo_n_d_sorting.html#a3">calculate_worths</a>(<span class="keyword">const</span> <a class="code" href="classeo_pop.html">eoPop&lt;EOT&gt;</a>&amp; _pop)
00063     {
00064         <span class="comment">// resize the worths beforehand</span>
00065         <a class="code" href="classeo_value_param.html#a2">value</a>().resize(_pop.size());
00066 
00067         <span class="keyword">typedef</span> <span class="keyword">typename</span> EOT::Fitness::fitness_traits traits;
00068 
00069         <span class="keywordflow">switch</span> (traits::nObjectives())
00070         {
00071             <span class="keywordflow">case</span> 1:
00072                 {
00073                     one_objective(_pop);
00074                     <span class="keywordflow">return</span>;
00075                 }
00076             <span class="keywordflow">case</span> 2:
00077                 {
00078                     <a class="code" href="classeo_n_d_sorting.html#d1">two_objectives</a>(_pop);
00079                     <span class="keywordflow">return</span>;
00080                 }
00081             <span class="keywordflow">default</span> :
00082                 {
00083                     m_objectives(_pop);
00084                 }
00085         }
00086     }
00087 
00088 <span class="keyword">private</span> :
00089 
<a name="l00094"></a><a class="code" href="classeo_n_d_sorting_1_1_dummy_e_o.html">00094</a>     <span class="keyword">class </span><a class="code" href="classeo_n_d_sorting_1_1_dummy_e_o.html">DummyEO</a> : <span class="keyword">public</span> <a class="code" href="class_e_o.html">EO</a>&lt;typename EOT::Fitness&gt;
00095     {
00096       <span class="keyword">public</span>: <span class="keywordtype">unsigned</span> index;
00097     };
00098 
00099     <span class="keywordtype">void</span> one_objective(<span class="keyword">const</span> <a class="code" href="classeo_pop.html">eoPop&lt;EOT&gt;</a>&amp; _pop)
00100     {
00101         <span class="keywordtype">unsigned</span> i;
00102         std::vector&lt;DummyEO&gt; tmp_pop;
00103         tmp_pop.resize(_pop.size());
00104 
00105         <span class="comment">// copy pop to dummy population (only need the fitnesses)</span>
00106         <span class="keywordflow">for</span> (i = 0; i &lt; _pop.size(); ++i)
00107         {
00108           tmp_pop[i].fitness(_pop[i].fitness());
00109           tmp_pop[i].index = i;
00110         }
00111 
00112         std::sort(tmp_pop.begin(), tmp_pop.end(), std::greater&lt;DummyEO&gt;());
00113 
00114         <span class="keywordflow">for</span> (i = 0; i &lt; _pop.size(); ++i)
00115         {
00116           <a class="code" href="classeo_value_param.html#a2">value</a>()[tmp_pop[i].index] = _pop.size() - i; <span class="comment">// set rank</span>
00117         }
00118 
00119         <span class="comment">// no point in calculcating niche penalty, as every distinct fitness value has a distinct rank</span>
00120     }
00121 
<a name="l00140"></a><a class="code" href="classeo_n_d_sorting.html#d1">00140</a>     <span class="keywordtype">void</span> <a class="code" href="classeo_n_d_sorting.html#d1">two_objectives</a>(<span class="keyword">const</span> <a class="code" href="classeo_pop.html">eoPop&lt;EOT&gt;</a>&amp; _pop)
00141     {
00142                 <span class="keywordtype">unsigned</span> i;
00143         <span class="keyword">typedef</span> <span class="keyword">typename</span> EOT::Fitness::fitness_traits traits;
00144         assert(traits::nObjectives() == 2);
00145 
00146         std::vector&lt;unsigned&gt; sort1(_pop.size()); <span class="comment">// index into population sorted on first objective</span>
00147 
00148         <span class="keywordflow">for</span> (i = 0; i &lt; _pop.size(); ++i)
00149         {
00150             sort1[i] = i;
00151         }
00152 
00153         std::sort(sort1.begin(), sort1.end(), Sorter(_pop));
00154 
00155         <span class="comment">// Ok, now the meat of the algorithm</span>
00156 
00157         <span class="keywordtype">unsigned</span> last_front = 0;
00158 
00159         <span class="keywordtype">double</span> max1 = -1e+20;
00160         <span class="keywordflow">for</span> (i = 0; i &lt; _pop.size(); ++i)
00161         {
00162             max1 = std::max(max1, _pop[i].fitness()[1]);
00163         }
00164 
00165         max1 = max1 + 1.0; <span class="comment">// add a bit to it so that it is a real upperbound</span>
00166 
00167         <span class="keywordtype">unsigned</span> prev_front = 0;
00168         std::vector&lt;double&gt; d;
00169         d.resize(_pop.size(), max1); <span class="comment">// initialize with the value max1 everywhere</span>
00170 
00171         std::vector&lt;std::vector&lt;unsigned&gt; &gt; fronts(_pop.size()); <span class="comment">// to store indices into the front</span>
00172 
00173         <span class="keywordflow">for</span> (i = 0; i &lt; _pop.size(); ++i)
00174         {
00175             <span class="keywordtype">unsigned</span> index = sort1[i];
00176 
00177             <span class="comment">// check for clones and delete them</span>
00178             <span class="keywordflow">if</span> (0 &amp;&amp; i &gt; 0)
00179             {
00180                 <span class="keywordtype">unsigned</span> prev = sort1[i-1];
00181                 <span class="keywordflow">if</span> ( _pop[index].fitness() == _pop[prev].fitness())
00182                 { <span class="comment">// it's a clone, give it the worst rank!</span>
00183 
00184                     <span class="keywordflow">if</span> (nasty_declone_flag_that_only_is_implemented_for_two_objectives)
00185                         <span class="comment">//declone</span>
00186                         fronts.back().push_back(index);
00187                     <span class="keywordflow">else</span> <span class="comment">// assign it the rank of the previous</span>
00188                         fronts[prev_front].push_back(index);
00189                     <span class="keywordflow">continue</span>;
00190                 }
00191             }
00192 
00193             <span class="keywordtype">double</span> value2 = _pop[index].fitness()[1];
00194 
00195             <span class="keywordflow">if</span> (traits::maximizing(1))
00196                 value2 = max1 - value2;
00197 
00198             <span class="comment">// perform binary search using std::upper_bound, a log n operation for each member</span>
00199             std::vector&lt;double&gt;::iterator it =
00200                 std::upper_bound(d.begin(), d.begin() + last_front, value2);
00201 
00202             <span class="keywordtype">unsigned</span> front = unsigned(it - d.begin());
00203             <span class="keywordflow">if</span> (front == last_front) ++last_front;
00204 
00205             assert(it != d.end());
00206 
00207             *it = value2; <span class="comment">//update d</span>
00208             fronts[front].push_back(index); <span class="comment">// add it to the front</span>
00209 
00210             prev_front = front;
00211         }
00212 
00213         <span class="comment">// ok, and finally the niche penalty</span>
00214 
00215         <span class="keywordflow">for</span> (i = 0; i &lt; fronts.size(); ++i)
00216         {
00217             <span class="keywordflow">if</span> (fronts[i].size() == 0) <span class="keywordflow">continue</span>;
00218 
00219             <span class="comment">// Now we have the indices to the current front in current_front, do the niching</span>
00220             std::vector&lt;double&gt; niche_count = <a class="code" href="classeo_n_d_sorting.html#a2">niche_penalty</a>(fronts[i], _pop);
00221 
00222             <span class="comment">// Check whether the derived class was nice</span>
00223             <span class="keywordflow">if</span> (niche_count.size() != fronts[i].size())
00224             {
00225               <span class="keywordflow">throw</span> std::logic_error(<span class="stringliteral">"eoNDSorting: niche and front should have the same size"</span>);
00226             }
00227 
00228             <span class="keywordtype">double</span> max_niche = *std::max_element(niche_count.begin(), niche_count.end());
00229 
00230             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j = 0; j &lt; fronts[i].size(); ++j)
00231             {
00232               <a class="code" href="classeo_value_param.html#a2">value</a>()[fronts[i][j]] = i + niche_count[j] / (max_niche + 1.); <span class="comment">// divide by max_niche + 1 to ensure that this front does not overlap with the next</span>
00233             }
00234 
00235         }
00236 
00237         <span class="comment">// invert ranks to obtain a 'bigger is better' score</span>
00238         rank_to_worth();
00239     }
00240 
00241     <span class="keyword">class </span>Sorter
00242     {
00243         <span class="keyword">public</span>:
00244             Sorter(<span class="keyword">const</span> <a class="code" href="classeo_pop.html">eoPop&lt;EOT&gt;</a>&amp; _pop) : pop(_pop) {}
00245 
00246             <span class="keywordtype">bool</span> <a class="code" href="classeo_perf2_worth_cached.html#a1">operator()</a>(<span class="keywordtype">unsigned</span> i, <span class="keywordtype">unsigned</span> j)<span class="keyword"> const</span>
00247 <span class="keyword">            </span>{
00248                 <span class="keyword">typedef</span> <span class="keyword">typename</span> EOT::Fitness::fitness_traits traits;
00249 
00250                 <span class="keywordtype">double</span> diff = pop[i].fitness()[0] - pop[j].fitness()[0];
00251 
00252                 <span class="keywordflow">if</span> (fabs(diff) &lt; traits::tol())
00253                 {
00254                     diff = pop[i].fitness()[1] - pop[j].fitness()[1];
00255 
00256                     <span class="keywordflow">if</span> (fabs(diff) &lt; traits::tol())
00257                         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00258 
00259                     <span class="keywordflow">if</span> (traits::maximizing(1))
00260                         <span class="keywordflow">return</span> diff &gt; 0.;
00261                     <span class="keywordflow">return</span> diff &lt; 0.;
00262                 }
00263 
00264                 <span class="keywordflow">if</span> (traits::maximizing(0))
00265                     <span class="keywordflow">return</span> diff &gt; 0.;
00266                 <span class="keywordflow">return</span> diff &lt; 0.;
00267             }
00268 
00269             <span class="keyword">const</span> <a class="code" href="classeo_pop.html">eoPop&lt;EOT&gt;</a>&amp; pop;
00270     };
00271 
00272     <span class="keywordtype">void</span> m_objectives(<span class="keyword">const</span> <a class="code" href="classeo_pop.html">eoPop&lt;EOT&gt;</a>&amp; _pop)
00273     {
00274       <span class="keywordtype">unsigned</span> i;
00275 
00276       <span class="keyword">typedef</span> <span class="keyword">typename</span> EOT::Fitness::fitness_traits traits;
00277 
00278       std::vector&lt;std::vector&lt;unsigned&gt; &gt; S(_pop.size()); <span class="comment">// which individuals does guy i dominate</span>
00279       std::vector&lt;unsigned&gt; n(_pop.size(), 0); <span class="comment">// how many individuals dominate guy i</span>
00280 
00281       <span class="keywordtype">unsigned</span> j;
00282       <span class="keywordflow">for</span> (i = 0; i &lt; _pop.size(); ++i)
00283       {
00284         <span class="keywordflow">for</span> (j = 0; j &lt; _pop.size(); ++j)
00285         {
00286           <span class="keywordflow">if</span> (_pop[i].fitness().dominates(_pop[j].fitness()))
00287           { <span class="comment">// i dominates j</span>
00288             S[i].push_back(j); <span class="comment">// add j to i's domination std::list</span>
00289 
00290             <span class="comment">//n[j]++; // as i dominates j</span>
00291           }
00292           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (_pop[j].fitness().dominates(_pop[i].fitness()))
00293           { <span class="comment">// j dominates i, increment count for i, add i to the domination std::list of j</span>
00294             n[i]++;
00295 
00296             <span class="comment">//S[j].push_back(i);</span>
00297           }
00298         }
00299       }
00300 
00301       std::vector&lt;unsigned&gt; current_front;
00302       current_front.reserve(_pop.size());
00303 
00304       <span class="comment">// get the first front out</span>
00305       <span class="keywordflow">for</span> (i = 0; i &lt; _pop.size(); ++i)
00306       {
00307         <span class="keywordflow">if</span> (n[i] == 0)
00308         {
00309           current_front.push_back(i);
00310         }
00311       }
00312 
00313       std::vector&lt;unsigned&gt; next_front;
00314       next_front.reserve(_pop.size());
00315 
00316       <span class="keywordtype">unsigned</span> front_index = 0; <span class="comment">// which front are we processing</span>
00317       <span class="keywordflow">while</span> (!current_front.empty())
00318       {
00319         <span class="comment">// Now we have the indices to the current front in current_front, do the niching</span>
00320         std::vector&lt;double&gt; niche_count = <a class="code" href="classeo_n_d_sorting.html#a2">niche_penalty</a>(current_front, _pop);
00321 
00322         <span class="comment">// Check whether the derived class was nice</span>
00323         <span class="keywordflow">if</span> (niche_count.size() != current_front.size())
00324         {
00325           <span class="keywordflow">throw</span> std::logic_error(<span class="stringliteral">"eoNDSorting: niche and front should have the same size"</span>);
00326         }
00327 
00328         <span class="keywordtype">double</span> max_niche = *std::max_element(niche_count.begin(), niche_count.end());
00329 
00330         <span class="keywordflow">for</span> (i = 0; i &lt; current_front.size(); ++i)
00331         {
00332           <a class="code" href="classeo_value_param.html#a2">value</a>()[current_front[i]] = front_index + niche_count[i] / (max_niche + 1.); <span class="comment">// divide by max_niche + 1 to ensure that this front does not overlap with the next</span>
00333         }
00334 
00335         <span class="comment">// Calculate which individuals are in the next front;</span>
00336 
00337         <span class="keywordflow">for</span> (i = 0; i &lt; current_front.size(); ++i)
00338         {
00339           <span class="keywordflow">for</span> (j = 0; j &lt; S[current_front[i]].size(); ++j)
00340           {
00341             <span class="keywordtype">unsigned</span> dominated_individual = S[current_front[i]][j];
00342             n[dominated_individual]--; <span class="comment">// As we remove individual i -- being part of the current front -- it no longer dominates j</span>
00343 
00344             <span class="keywordflow">if</span> (n[dominated_individual] == 0) <span class="comment">// it should be in the current front</span>
00345             {
00346               next_front.push_back(dominated_individual);
00347             }
00348           }
00349         }
00350 
00351         front_index++; <span class="comment">// go to the next front</span>
00352         swap(current_front, next_front); <span class="comment">// make the next front current</span>
00353         next_front.clear(); <span class="comment">// clear it for the next iteration</span>
00354       }
00355 
00356       rank_to_worth();
00357     }
00358 
00359     <span class="keywordtype">void</span> rank_to_worth()
00360     {
00361       <span class="comment">// now all that's left to do is to transform lower rank into higher worth</span>
00362       <span class="keywordtype">double</span> max_fitness = *std::max_element(<a class="code" href="classeo_value_param.html#a2">value</a>().begin(), <a class="code" href="classeo_value_param.html#a2">value</a>().end());
00363 
00364       <span class="comment">// but make sure it's an integer upper bound, so that all ranks inside the highest integer are the front</span>
00365       max_fitness = ceil(max_fitness);
00366 
00367       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; <a class="code" href="classeo_value_param.html#a2">value</a>().size(); ++i)
00368       {
00369         <a class="code" href="classeo_value_param.html#a2">value</a>()[i] = max_fitness - <a class="code" href="classeo_value_param.html#a2">value</a>()[i];
00370       }
00371 
00372     }
00373     <span class="keyword">public</span> : <span class="keywordtype">bool</span> nasty_declone_flag_that_only_is_implemented_for_two_objectives;
00374 };
00375 
00379 <span class="keyword">template</span> &lt;<span class="keyword">class</span> EOT&gt;
<a name="l00380"></a><a class="code" href="classeo_n_d_sorting___i.html">00380</a> <span class="keyword">class </span><a class="code" href="classeo_n_d_sorting___i.html">eoNDSorting_I</a> : <span class="keyword">public</span> <a class="code" href="classeo_n_d_sorting.html">eoNDSorting</a>&lt;EOT&gt;
00381 {
00382 <span class="keyword">public</span> :
00383   <a class="code" href="classeo_n_d_sorting___i.html">eoNDSorting_I</a>(<span class="keywordtype">double</span> _nicheSize, <span class="keywordtype">bool</span> nasty_flag_ = <span class="keyword">false</span>) : <a class="code" href="classeo_n_d_sorting.html">eoNDSorting&lt;EOT&gt;</a>(nasty_flag_), nicheSize(_nicheSize) {}
00384 
<a name="l00385"></a><a class="code" href="classeo_n_d_sorting___i.html#a1">00385</a>   std::vector&lt;double&gt; <a class="code" href="classeo_n_d_sorting___i.html#a1">niche_penalty</a>(<span class="keyword">const</span> std::vector&lt;unsigned&gt;&amp; current_front, <span class="keyword">const</span> <a class="code" href="classeo_pop.html">eoPop&lt;EOT&gt;</a>&amp; _pop)
00386   {
00387         std::vector&lt;double&gt; niche_count(current_front.size(), 0.);
00388 
00389         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; current_front.size(); ++i)
00390         { <span class="comment">// calculate whether the other points lie within the nice</span>
00391           <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j = 0; j &lt; current_front.size(); ++j)
00392           {
00393             <span class="keywordflow">if</span> (i == j)
00394               <span class="keywordflow">continue</span>;
00395 
00396             <span class="keywordtype">double</span> dist = 0.0;
00397 
00398             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> k = 0; k &lt; _pop[current_front[j]].fitness().size(); ++k)
00399             {
00400               <span class="keywordtype">double</span> d = _pop[current_front[i]].fitness()[k] - _pop[current_front[j]].fitness()[k];
00401               dist += d*d;
00402             }
00403 
00404             <span class="keywordflow">if</span> (dist &lt; nicheSize)
00405             {
00406               niche_count[i] += 1.0 - pow(dist / nicheSize,2.);
00407             }
00408           }
00409         }
00410 
00411         <span class="keywordflow">return</span> niche_count;
00412   }
00413 
00414   <span class="keyword">private</span> :
00415 
00416   <span class="keywordtype">double</span> nicheSize;
00417 };
00418 
00433 <span class="keyword">template</span> &lt;<span class="keyword">class</span> EOT&gt;
<a name="l00434"></a><a class="code" href="classeo_n_d_sorting___i_i.html">00434</a> <span class="keyword">class </span><a class="code" href="classeo_n_d_sorting___i_i.html">eoNDSorting_II</a> : <span class="keyword">public</span> <a class="code" href="classeo_n_d_sorting.html">eoNDSorting</a>&lt;EOT&gt;
00435 {
00436   <span class="keyword">public</span>:
00437 
00438     <a class="code" href="classeo_n_d_sorting___i_i.html">eoNDSorting_II</a>(<span class="keywordtype">bool</span> nasty_flag_ = <span class="keyword">false</span>) : <a class="code" href="classeo_n_d_sorting.html">eoNDSorting&lt;EOT&gt;</a>(nasty_flag_) {}
00439 
00440   <span class="keyword">typedef</span> std::pair&lt;double, unsigned&gt; double_index_pair;
00441 
00442   <span class="keyword">class </span>compare_nodes
00443   {
00444   <span class="keyword">public</span> :
00445     <span class="keywordtype">bool</span> <a class="code" href="classeo_perf2_worth_cached.html#a1">operator()</a>(<span class="keyword">const</span> double_index_pair&amp; a, <span class="keyword">const</span> double_index_pair&amp; b)<span class="keyword"> const</span>
00446 <span class="keyword">    </span>{
00447       <span class="keywordflow">return</span> a.first &lt; b.first;
00448     }
00449   };
00450 
<a name="l00452"></a><a class="code" href="classeo_n_d_sorting___i_i.html#a1">00452</a>   std::vector&lt;double&gt; <a class="code" href="classeo_n_d_sorting___i_i.html#a1">niche_penalty</a>(<span class="keyword">const</span> std::vector&lt;unsigned&gt;&amp; _cf, <span class="keyword">const</span> <a class="code" href="classeo_pop.html">eoPop&lt;EOT&gt;</a>&amp; _pop)
00453   {
00454     <span class="keyword">typedef</span> <span class="keyword">typename</span> EOT::Fitness::fitness_traits traits;
00455     <span class="keywordtype">unsigned</span> i;
00456     std::vector&lt;double&gt; niche_count(_cf.size(), 0.);
00457 
00458 
00459     <span class="keywordtype">unsigned</span> nObjectives = traits::nObjectives(); <span class="comment">//_pop[_cf[0]].fitness().size();</span>
00460 
00461     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> o = 0; o &lt; nObjectives; ++o)
00462     {
00463 
00464       std::vector&lt;std::pair&lt;double, unsigned&gt; &gt; performance(_cf.size());
00465       <span class="keywordflow">for</span> (i =0; i &lt; _cf.size(); ++i)
00466       {
00467         performance[i].first = _pop[_cf[i]].fitness()[o];
00468         performance[i].second = i;
00469       }
00470 
00471       std::sort(performance.begin(), performance.end(), compare_nodes()); <span class="comment">// a lambda operator would've been nice here</span>
00472 
00473       std::vector&lt;double&gt; nc(niche_count.size(), 0.0);
00474 
00475       <span class="keywordflow">for</span> (i = 1; i &lt; _cf.size()-1; ++i)
00476       { <span class="comment">// and yet another level of indirection</span>
00477         nc[performance[i].second] = performance[i+1].first - performance[i-1].first;
00478       }
00479 
00480       <span class="keywordtype">double</span> max_dist = *std::max_element(nc.begin(), nc.end());
00481 
00482       <span class="comment">// set boundary at max_dist + 1 (so it will get chosen over all the others</span>
00483       nc[performance[0].second] = max_dist + 1;
00484       nc[performance.back().second] = max_dist + 1;
00485 
00486       <span class="keywordflow">for</span> (i = 0; i &lt; nc.size(); ++i)
00487       {
00488         niche_count[i] = (max_dist + 1 - nc[i]);
00489       }
00490     }
00491 
00492     <span class="keywordflow">return</span> niche_count;
00493   }
00494 };
00495 
00496 <span class="preprocessor">#endif</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Thu Oct 19 05:06:36 2006 for EO by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
