<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>EO: Sym.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<div class="nav">
<a class="el" href="dir_000007.html">contrib</a>&nbsp;/&nbsp;<a class="el" href="dir_000008.html">mathsym</a>&nbsp;/&nbsp;<a class="el" href="dir_000028.html">sym</a></div>
<h1>Sym.h</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">/*          </span>
00002 <span class="comment"> *             Copyright (C) 2005 Maarten Keijzer</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> *          This program is free software; you can redistribute it and/or modify</span>
00005 <span class="comment"> *          it under the terms of version 2 of the GNU General Public License as </span>
00006 <span class="comment"> *          published by the Free Software Foundation. </span>
00007 <span class="comment"> *</span>
00008 <span class="comment"> *          This program is distributed in the hope that it will be useful,</span>
00009 <span class="comment"> *          but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00010 <span class="comment"> *          MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00011 <span class="comment"> *          GNU General Public License for more details.</span>
00012 <span class="comment"> *</span>
00013 <span class="comment"> *          You should have received a copy of the GNU General Public License</span>
00014 <span class="comment"> *          along with this program; if not, write to the Free Software</span>
00015 <span class="comment"> *          Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
00016 <span class="comment"> */</span>
00017 
00018 <span class="preprocessor">#ifndef SYMNODE_H_</span>
00019 <span class="preprocessor"></span><span class="preprocessor">#define SYMNODE_H_</span>
00020 <span class="preprocessor"></span>
00021 <span class="preprocessor">#include &lt;cassert&gt;</span>
00022 
00023 <span class="preprocessor">#if __GNUC__ &gt;= 3</span>
00024 <span class="preprocessor"></span><span class="preprocessor">#include &lt;backward/hash_map.h&gt;</span>
00025 <span class="preprocessor">#elif __GNUC__ &lt; 3</span>
00026 <span class="preprocessor"></span><span class="preprocessor">#include &lt;hash_map.h&gt;</span>
00027 <span class="keyword">using</span> std::hash_map;
00028 <span class="preprocessor">#endif</span>
00029 <span class="preprocessor"></span>
00030 <span class="comment">/* Empty 'extra statistics' structure, derive from this to keep other characteristics of nodes */</span>
00031 <span class="keyword">struct </span>UniqueNodeStats { <span class="keyword">virtual</span> ~UniqueNodeStats(){} };
00032 
00033 <span class="preprocessor">#include "SymImpl.h"</span>
00034 <span class="preprocessor">#include "token.h"</span>
00035 
00036 <span class="preprocessor">#if __GNUC__ == 4</span>
00037 <span class="preprocessor"></span><span class="preprocessor">#define USE_TR1 1</span>
00038 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00039 <span class="preprocessor"></span><span class="preprocessor">#define USE_TR1 0</span>
00040 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00041 <span class="preprocessor"></span>
00042 <span class="preprocessor">#if USE_TR1</span>
00043 <span class="preprocessor"></span><span class="preprocessor">#include &lt;tr1/unordered_map&gt;</span>
00044 <span class="keyword">typedef</span> std::tr1::unordered_map&lt;detail::SymKey, detail::SymValue, detail::SymKey::Hash&gt; SymMap;
00045 <span class="preprocessor">#else</span>
00046 <span class="preprocessor"></span><span class="keyword">typedef</span> hash_map&lt;detail::SymKey, detail::SymValue, detail::SymKey::Hash&gt; SymMap;
00047 <span class="preprocessor">#endif</span>
00048 <span class="preprocessor"></span>
00049 <span class="keyword">typedef</span> SymMap::iterator SymIterator;
00050 
00051 <span class="comment">/* Sym is the tree, for which all the nodes are stored in a hash table. </span>
00052 <span class="comment"> * This makes checking for equality O(1) */</span>
00053 <span class="keyword">class </span>Sym
00054 {
00055     <span class="keyword">public</span>:
00056         
00057         Sym() : node(dag.end()) {}
00058         <span class="keyword">explicit</span> Sym(token_t token, <span class="keyword">const</span> SymVec&amp; args);
00059         <span class="keyword">explicit</span> Sym(token_t token, <span class="keyword">const</span> Sym&amp; args);
00060         <span class="keyword">explicit</span> Sym(token_t var);
00061         
00062         <span class="keyword">explicit</span> Sym(SymIterator it) : node(it) { incref(); }
00063         
00064         Sym(<span class="keyword">const</span> Sym&amp; oth) : node(oth.node) { incref(); }
00065         ~Sym() { decref(); }
00066         
00067         <span class="keyword">const</span> Sym&amp; operator=(<span class="keyword">const</span> Sym&amp; oth) {
00068             <span class="keywordflow">if</span> (oth.node == node) <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00069             decref();
00070             node = oth.node;
00071             incref();
00072             <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00073         }
00074 
00075         <span class="comment">/* Unique Stats are user defined */</span>
00076         UniqueNodeStats* extra_stats()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> empty()? 0 : node-&gt;second.uniqueNodeStats; }
00077         
00078         <span class="keywordtype">int</span> hashcode()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> node-&gt;first.get_hash_code(); } <span class="comment">//detail::SymKey::Hash hash; return hash(node-&gt;first); }</span>
00079         
00080         <span class="comment">// Friends, need to touch the node</span>
00081         <span class="keyword">friend</span> <span class="keyword">struct </span>detail::SymKey::Hash;
00082         <span class="keyword">friend</span> <span class="keyword">struct </span>detail::SymKey;
00083         
00084         <span class="keywordtype">unsigned</span> refcount()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> empty()? 0: node-&gt;second.refcount; }
00085 
00086         <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> Sym&amp; other)<span class="keyword"> const </span>{
00087             <span class="keywordflow">return</span> node == other.node;
00088         }
00089         <span class="keywordtype">bool</span> operator!=(<span class="keyword">const</span> Sym&amp; other)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> !(*<span class="keyword">this</span> == other); }
00090 
00091         <span class="keywordtype">bool</span> empty()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> node == dag.end(); }
00092 
00093         <span class="comment">/* Support for traversing trees */</span>
00094         <span class="keywordtype">unsigned</span> arity()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> node-&gt;first.arity(); }
00095         token_t    token()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> node-&gt;first.token; }
00096         
00097         <span class="keyword">const</span> SymVec&amp; args()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> node-&gt;first.vec(); }
00098         
00099         <span class="comment">/* size() - depth */</span>
00100         <span class="keywordtype">unsigned</span> size()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> empty()? 0 : node-&gt;second.size; }
00101         <span class="keywordtype">unsigned</span> depth()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> empty()? 0 : node-&gt;second.depth; }
00102         
00103         SymMap::iterator iterator()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> node; }
00104 
00105         <span class="comment">/* Statics accessing some static members */</span>
00106         <span class="keyword">static</span> SymMap&amp; get_dag() { <span class="keywordflow">return</span> dag; }
00107         
00108         <span class="comment">/* This function can be set to create some UniqueNodeStats derivative that can contain extra stats for a node,</span>
00109 <span class="comment">         * it can for instance be used to create ERC's and what not. */</span>
00110         <span class="keyword">static</span> <span class="keywordtype">void</span> set_factory_function(UniqueNodeStats* (*f)(<span class="keyword">const</span> Sym&amp;)) { factory=f; } 
00111         <span class="keyword">static</span> <span class="keywordtype">void</span> clear_factory_function() { factory = 0; }
00112         
00113         <span class="keyword">static</span> <span class="keyword">const</span> std::vector&lt;unsigned&gt;&amp; token_refcount() { <span class="keywordflow">return</span> token_count; }
00114         
00115         <span class="keywordtype">unsigned</span> address()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> reinterpret_cast&lt;unsigned&gt;(&amp;*node); }
00116         
00117     <span class="keyword">private</span> :
00118         
00119         <span class="comment">// implements getting subtrees</span>
00120         Sym private_get(size_t w) <span class="keyword">const</span>; 
00121         
00122         <span class="keywordtype">unsigned</span> __unchecked_refcount()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> node-&gt;second.refcount; }
00123         
00124         <span class="keywordtype">void</span> incref() {
00125             <span class="keywordflow">if</span> (!empty()) {
00126                 ++(node-&gt;second.refcount);
00127                 ++token_count[token()];
00128             }
00129         }
00130         <span class="keywordtype">void</span> decref() {
00131             <span class="keywordflow">if</span> (!empty()) {
00132                 --token_count[token()];
00133                 <span class="keywordflow">if</span> (--(node-&gt;second.refcount) == 0) {
00134                     dag.erase(node);
00135                 }
00136             }
00137         }
00138 
00139         <span class="comment">// The one and only data member, an iterator into the static map below</span>
00140         SymIterator node;
00141         
00142         <span class="comment">// A static hash_map that contains all live nodes.. </span>
00143         <span class="keyword">static</span> SymMap dag;
00144         
00145         <span class="keyword">static</span> std::vector&lt;unsigned&gt; token_count;
00146         
00147         <span class="comment">// Factory function for creating extra node stats, default will be 0</span>
00148         <span class="keyword">static</span> UniqueNodeStats* (*factory)(<span class="keyword">const</span> Sym&amp;);
00149         
00150 };
00151 
00152 <span class="comment">/* Utility hash functor for syms */</span>
00153 <span class="keyword">class </span>HashSym {
00154     <span class="keyword">public</span>:
00155     <span class="keywordtype">int</span> operator()(<span class="keyword">const</span> Sym&amp; sym)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> sym.hashcode(); }
00156 };
00157 
00158 <span class="comment">/* Utility Functions */</span>
00159 
00160 <span class="comment">// get_subtree retrieves a subtree by standard ordering (0=root, and then depth first)</span>
00161 Sym get_subtree(<span class="keyword">const</span> Sym&amp; org, size_t w); 
00162 
00163 <span class="comment">// insert_subtree uses the same ordering as get and inserts the second argument, returning a new tree</span>
00164 Sym insert_subtree(<span class="keyword">const</span> Sym&amp; org, size_t w, <span class="keyword">const</span> Sym&amp; nw);
00165 
00166 <span class="comment">/* Get the successor from the hashtable, no particular purpose other than an interesting way to mutate */</span>
00167 <span class="keyword">inline</span> Sym next(<span class="keyword">const</span> Sym&amp; sym) {
00168     SymIterator it = sym.iterator();
00169     ++it;
00170     <span class="keywordflow">if</span> (it == Sym::get_dag().end()) it = Sym::get_dag().begin();
00171     <span class="keywordflow">return</span> Sym(it);
00172 }
00173 
00174 <span class="preprocessor">#endif</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Thu Oct 19 05:06:42 2006 for EO by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
