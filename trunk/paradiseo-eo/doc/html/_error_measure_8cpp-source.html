<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>EO: ErrorMeasure.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<div class="nav">
<a class="el" href="dir_000007.html">contrib</a>&nbsp;/&nbsp;<a class="el" href="dir_000008.html">mathsym</a>&nbsp;/&nbsp;<a class="el" href="dir_000012.html">regression</a></div>
<h1>ErrorMeasure.cpp</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">/*          </span>
00002 <span class="comment"> *             Copyright (C) 2005 Maarten Keijzer</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> *          This program is free software; you can redistribute it and/or modify</span>
00005 <span class="comment"> *          it under the terms of version 2 of the GNU General Public License as </span>
00006 <span class="comment"> *          published by the Free Software Foundation. </span>
00007 <span class="comment"> *</span>
00008 <span class="comment"> *          This program is distributed in the hope that it will be useful,</span>
00009 <span class="comment"> *          but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00010 <span class="comment"> *          MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00011 <span class="comment"> *          GNU General Public License for more details.</span>
00012 <span class="comment"> *</span>
00013 <span class="comment"> *          You should have received a copy of the GNU General Public License</span>
00014 <span class="comment"> *          along with this program; if not, write to the Free Software</span>
00015 <span class="comment"> *          Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
00016 <span class="comment"> */</span>
00017 
00018 
00019 <span class="preprocessor">#include &lt;vector&gt;</span>
00020 <span class="preprocessor">#include &lt;valarray&gt;</span>
00021 
00022 <span class="preprocessor">#include "MultiFunction.h"</span>
00023 
00024 <span class="preprocessor">#include "ErrorMeasure.h"</span>
00025 <span class="preprocessor">#include "Dataset.h"</span>
00026 <span class="preprocessor">#include "Sym.h"</span>
00027 <span class="preprocessor">#include "FunDef.h"</span>
00028 <span class="preprocessor">#include "sym_compile.h"</span>
00029 <span class="preprocessor">#include "TargetInfo.h"</span>
00030 <span class="preprocessor">#include "stats.h"</span>
00031 
00032 <span class="keyword">using</span> <span class="keyword">namespace </span>std;
00033 
00034 <span class="preprocessor">#ifdef INTERVAL_DEBUG</span>
00035 <span class="preprocessor"></span>
00036 <span class="preprocessor">#include &lt;BoundsCheck.h&gt;</span>
00037 <span class="preprocessor">#include &lt;FunDef.h&gt;</span>
00038 
00039 vector&lt;double&gt; none;
00040 IntervalBoundsCheck bounds(none, none);
00041 
00042 <span class="preprocessor">#endif</span>
00043 <span class="preprocessor"></span>
00044 
00045 
00046 <span class="keyword">static</span> <span class="keywordtype">double</span> not_a_number = atof(<span class="stringliteral">"nan"</span>);
00047 
00048 <span class="keyword">class </span>ErrorMeasureImpl {
00049     <span class="keyword">public</span>:
00050         <span class="keyword">const</span> Dataset&amp; data;
00051         TargetInfo train_info;
00052         
00053         ErrorMeasure::measure measure;
00054         
00055         Scaling no_scaling;
00056         
00057         ErrorMeasureImpl(<span class="keyword">const</span> Dataset&amp; d, <span class="keywordtype">double</span> t_p, ErrorMeasure::measure m) : data(d), measure(m) {
00058             
00059 <span class="preprocessor">#ifdef INTERVAL_DEBUG</span>
00060 <span class="preprocessor"></span>            bounds = IntervalBoundsCheck(d.input_minima(), d.input_maxima());
00061 <span class="preprocessor">#endif</span>
00062 <span class="preprocessor"></span>
00063             <span class="keywordtype">unsigned</span> nrecords = d.n_records();
00064             <span class="keywordtype">unsigned</span> cases = unsigned(t_p * nrecords);
00065             
00066             valarray&lt;double&gt; t(cases);
00067 
00068             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; cases; ++i) {
00069                 t[i] = data.get_target(i);
00070             }
00071 
00072             train_info = TargetInfo(t);
00073             no_scaling = Scaling(<span class="keyword">new</span> NoScaling);
00074         }
00075         
00076         ErrorMeasure::result eval(<span class="keyword">const</span> valarray&lt;double&gt;&amp; y) {
00077             
00078             ErrorMeasure::result result;
00079             result.scaling = no_scaling;
00080             
00081             
00082             <span class="keywordflow">switch</span>(measure) {
00083                 <span class="keywordflow">case</span> ErrorMeasure::mean_squared:
00084                     result.error = pow(train_info.targets() - y, 2.0).sum() / y.size();
00085                     <span class="keywordflow">return</span> result;
00086                 <span class="keywordflow">case</span> ErrorMeasure::absolute:
00087                     result.error = abs(train_info.targets() - y).sum() / y.size();
00088                     <span class="keywordflow">return</span> result;
00089                 <span class="keywordflow">case</span> ErrorMeasure::mean_squared_scaled:
00090                     result.scaling = ols(y, train_info);
00091                     result.error  = pow(train_info.targets() - result.scaling-&gt;transform(y), 2.0).sum() / y.size();
00092                     <span class="keywordflow">return</span> result;
00093                 <span class="keywordflow">default</span>: 
00094                     cerr &lt;&lt; <span class="stringliteral">"Unknown measure encountered: "</span> &lt;&lt; measure &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; __FILE__ &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; __LINE__ &lt;&lt; endl;
00095             }
00096             
00097             <span class="keywordflow">return</span> result;
00098         }   
00099         
00100         <span class="keywordtype">unsigned</span> train_cases()<span class="keyword"> const </span>{
00101             <span class="keywordflow">return</span> train_info.targets().size();
00102         }
00103 
00104         vector&lt;ErrorMeasure::result&gt; multi_function_eval(<span class="keyword">const</span> vector&lt;Sym&gt;&amp; pop) {
00105            
00106             <span class="keywordflow">if</span> (pop.size() == 0) <span class="keywordflow">return</span> vector&lt;ErrorMeasure::result&gt;();
00107             
00108             multi_function all = compile(pop);
00109             <span class="comment">//MultiFunction all(pop);</span>
00110             std::vector&lt;double&gt; y(pop.size());
00111             
00112             Scaling noScaling = Scaling(<span class="keyword">new</span> NoScaling);
00113             
00114             <span class="keyword">const</span> std::valarray&lt;double&gt;&amp; t = train_info.targets();
00115             
00116             cout &lt;&lt; <span class="stringliteral">"Population size "</span> &lt;&lt; pop.size() &lt;&lt; endl;
00117             
00118             <span class="keywordflow">if</span> (measure == ErrorMeasure::mean_squared_scaled) {
00119                 std::vector&lt;Var&gt; var(pop.size());
00120                 std::vector&lt;Cov&gt; cov(pop.size());
00121             
00122                 Var vart;
00123 
00124                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; t.size(); ++i) {
00125                     vart.update(t[i]);
00126                     
00127                     all(&amp;data.get_inputs(i)[0], &amp;y[0]); <span class="comment">// evalutate</span>
00128                     <span class="comment">//all(data.get_inputs(i), y); // evalutate</span>
00129 
00130                     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j = 0; j &lt; pop.size(); ++j) {
00131                         var[j].update(y[j]);
00132                         cov[j].update(y[j], t[i]);
00133                     }
00134                 }
00135                 
00136                 std::vector&lt;ErrorMeasure::result&gt; result(pop.size());
00137                 
00138                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; pop.size(); ++i) {
00139                     
00140                     <span class="comment">// calculate scaling</span>
00141                     <span class="keywordtype">double</span> b = cov[i].get_cov() / var[i].get_var();
00142                     
00143                     <span class="keywordflow">if</span> (!finite(b)) {
00144                         result[i].scaling = noScaling;
00145                         result[i].error = vart.get_var(); <span class="comment">// largest error</span>
00146                         <span class="keywordflow">continue</span>;
00147                     }
00148                     
00149                     <span class="keywordtype">double</span> a = vart.get_mean() - b * var[i].get_mean();
00150                     
00151                     result[i].scaling = Scaling( <span class="keyword">new</span> LinearScaling(a,b));
00152 
00153                     <span class="comment">// calculate error</span>
00154                     <span class="keywordtype">double</span> c = cov[i].get_cov();
00155                     c *= c;
00156                     
00157                     <span class="keywordtype">double</span> err = vart.get_var() - c / var[i].get_var();
00158                     result[i].error = err; 
00159                     <span class="keywordflow">if</span> (!finite(err)) {
00160                         <span class="comment">//cout &lt;&lt; pop[i] &lt;&lt; endl;</span>
00161                         cout &lt;&lt; <span class="stringliteral">"b     "</span> &lt;&lt; b &lt;&lt; endl;
00162                         cout &lt;&lt; <span class="stringliteral">"var t "</span> &lt;&lt; vart.get_var() &lt;&lt; endl;
00163                         cout &lt;&lt; <span class="stringliteral">"var i "</span> &lt;&lt; var[i].get_var() &lt;&lt; endl;
00164                         cout &lt;&lt; <span class="stringliteral">"cov   "</span> &lt;&lt; cov[i].get_cov() &lt;&lt; endl;
00165                         
00166                         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j = 0; j &lt; t.size(); ++j) {
00167                             all(&amp;data.get_inputs(i)[0], &amp;y[0]); <span class="comment">// evalutate</span>
00168                             <span class="comment">//all(data.get_inputs(j), y); // evalutate</span>
00169                             
00170                             cout &lt;&lt; y[i] &lt;&lt; <span class="charliteral">' '</span> &lt;&lt; ::eval(pop[i], data.get_inputs(j)) &lt;&lt; endl;
00171                         }
00172                         
00173                         exit(1);
00174                     }
00175                 }
00176         
00177                 <span class="keywordflow">return</span> result;
00178             }
00179         
00180             
00181             std::vector&lt;double&gt; err(pop.size()); 
00182             
00183             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; train_cases(); ++i) {
00184                 <span class="comment">// evaluate</span>
00185                 all(&amp;data.get_inputs(i)[0], &amp;y[0]);
00186                 <span class="comment">//all(data.get_inputs(i), y);</span>
00187 
00188                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j = 0; j &lt; pop.size(); ++j) {
00189                     <span class="keywordtype">double</span> diff = y[j] - t[i];
00190                     <span class="keywordflow">if</span> (measure == ErrorMeasure::mean_squared) { <span class="comment">// branch prediction will probably solve this inefficiency</span>
00191                         err[j] += diff * diff;
00192                     } <span class="keywordflow">else</span> {
00193                         err[j] += fabs(diff);
00194                     }
00195                     
00196                 }
00197                 
00198             }
00199             
00200             std::vector&lt;ErrorMeasure::result&gt; result(pop.size());
00201 
00202             <span class="keywordtype">double</span> n = train_cases();
00203             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; pop.size(); ++i) {
00204                 result[i].error = err[i] / n;
00205                 result[i].scaling = noScaling;
00206             }
00207 
00208             <span class="keywordflow">return</span> result;
00209             
00210         }
00211 
00212         vector&lt;ErrorMeasure::result&gt; single_function_eval(<span class="keyword">const</span> vector&lt;Sym&gt; &amp; pop) {
00213             
00214             vector&lt;single_function&gt; funcs(pop.size());
00215             compile(pop, funcs); <span class="comment">// get one function pointer for each individual</span>
00216 
00217             valarray&lt;double&gt; y(train_cases());
00218             vector&lt;ErrorMeasure::result&gt; result(pop.size());
00219             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; funcs.size(); ++i) {
00220                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j = 0; j &lt; train_cases(); ++j) {
00221                     y[j] = funcs[i](&amp;data.get_inputs(j)[0]);
00222                 }
00223         
00224 <span class="preprocessor">#ifdef INTERVAL_DEBUG</span>
00225 <span class="preprocessor"></span>                <span class="comment">//cout &lt;&lt; "eval func " &lt;&lt; i &lt;&lt; " " &lt;&lt; pop[i] &lt;&lt; endl;</span>
00226                 pair&lt;double, double&gt; b = bounds.calc_bounds(pop[i]);
00227                 
00228                 <span class="comment">// check if y is in bounds</span>
00229                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j = 0; j &lt; y.size(); ++j) {
00230                     <span class="keywordflow">if</span> (y[j] &lt; b.first -1e-4 || y[j] &gt; b.second + 1e-4 || !finite(y[j])) {
00231                         cout &lt;&lt; <span class="stringliteral">"Error "</span> &lt;&lt; y[j] &lt;&lt; <span class="stringliteral">" not in "</span> &lt;&lt; b.first &lt;&lt; <span class="charliteral">' '</span> &lt;&lt; b.second &lt;&lt; endl;
00232                         cout &lt;&lt; <span class="stringliteral">"Function "</span> &lt;&lt; pop[i] &lt;&lt; endl;
00233                         exit(1);
00234                     }
00235                 }
00236 <span class="preprocessor">#endif</span>
00237 <span class="preprocessor"></span>                
00238                 result[i] = eval(y);
00239             }
00240             
00241             <span class="keywordflow">return</span> result; 
00242         }
00243         
00244         vector&lt;ErrorMeasure::result&gt; calc_error(<span class="keyword">const</span> vector&lt;Sym&gt;&amp; pop) {
00245 
00246             <span class="comment">// first declone</span>
00247 <span class="preprocessor">#if USE_TR1</span>
00248 <span class="preprocessor"></span>            <span class="keyword">typedef</span> std::tr1::unordered_map&lt;Sym, unsigned, HashSym&gt; HashMap;
00249 <span class="preprocessor">#else</span>
00250 <span class="preprocessor"></span>            <span class="keyword">typedef</span> hash_map&lt;Sym, unsigned, HashSym&gt; HashMap;
00251 <span class="preprocessor">#endif      </span>
00252 <span class="preprocessor"></span>            HashMap clone_map;
00253             vector&lt;Sym&gt; decloned; 
00254             decloned.reserve(pop.size());
00255             
00256             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; pop.size(); ++i) {
00257                 HashMap::iterator it = clone_map.find(pop[i]);
00258 
00259                 <span class="keywordflow">if</span> (it == clone_map.end()) { <span class="comment">// new</span>
00260                     clone_map[ pop[i] ] = decloned.size();
00261                     decloned.push_back(pop[i]);
00262                 } 
00263                 
00264             }
00265             
00266             <span class="comment">// evaluate </span>
00267             vector&lt;ErrorMeasure::result&gt; dresult;
00268             <span class="comment">// currently we can only accumulate simple measures such as absolute and mean_squared</span>
00269             <span class="keywordflow">switch</span>(measure) {
00270                 <span class="keywordflow">case</span> ErrorMeasure::mean_squared:
00271                 <span class="keywordflow">case</span> ErrorMeasure::absolute:
00272                     dresult = multi_function_eval(decloned);
00273                     <span class="keywordflow">break</span>;
00274                 <span class="keywordflow">case</span> ErrorMeasure::mean_squared_scaled:
00275                     dresult = multi_function_eval(decloned);
00276                     <span class="keywordflow">break</span>;
00277             }
00278             
00279             vector&lt;ErrorMeasure::result&gt; result(pop.size());
00280             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; result.size(); ++i) {
00281                 result[i] = dresult[ clone_map[pop[i]] ];
00282             }
00283         
00284             <span class="keywordflow">return</span> result;
00285         }
00286         
00287 };
00288 
00289 ErrorMeasure::result::result() {
00290     error = 0.0;
00291     scaling = Scaling(0);
00292 }
00293 
00294 <span class="keywordtype">bool</span> ErrorMeasure::result::valid()<span class="keyword"> const </span>{
00295     <span class="keywordflow">return</span> isfinite(error);
00296 }
00297 
00298 ErrorMeasure::ErrorMeasure(<span class="keyword">const</span> Dataset&amp; data, <span class="keywordtype">double</span> train_perc, measure meas) {
00299     pimpl = <span class="keyword">new</span> ErrorMeasureImpl(data, train_perc, meas);
00300 }
00301 
00302 ErrorMeasure::~ErrorMeasure() { <span class="keyword">delete</span> pimpl; }
00303 ErrorMeasure::ErrorMeasure(<span class="keyword">const</span> ErrorMeasure&amp; that) { pimpl = <span class="keyword">new</span> ErrorMeasureImpl(*that.pimpl); }
00304 
00305 
00306 ErrorMeasure::result ErrorMeasure::calc_error(Sym sym) {
00307    
00308     single_function f = compile(sym);
00309     
00310     valarray&lt;double&gt; y(pimpl-&gt;train_cases());
00311      
00312     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; y.size(); ++i) {
00313 
00314         y[i] = f(&amp;pimpl-&gt;data.get_inputs(i)[0]);
00315         
00316         <span class="keywordflow">if</span> (!finite(y[i])) {
00317             result res;
00318             res.scaling = Scaling(<span class="keyword">new</span> NoScaling);
00319             res.error = not_a_number;
00320             <span class="keywordflow">return</span> res;
00321         }
00322     }
00323    
00324     <span class="keywordflow">return</span> pimpl-&gt;eval(y); 
00325 }
00326 
00327 vector&lt;ErrorMeasure::result&gt; ErrorMeasure::calc_error(<span class="keyword">const</span> vector&lt;Sym&gt;&amp; syms) {
00328     <span class="keywordflow">return</span> pimpl-&gt;calc_error(syms);
00329     
00330 }
00331 
00332 <span class="keywordtype">double</span> ErrorMeasure::worst_performance()<span class="keyword"> const </span>{
00333     
00334     <span class="keywordflow">if</span> (pimpl-&gt;measure == mean_squared_scaled) {
00335         <span class="keywordflow">return</span> pimpl-&gt;train_info.tvar();
00336     }
00337     
00338     <span class="keywordflow">return</span> 1e+20; 
00339 }
00340 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Thu Oct 19 05:06:39 2006 for EO by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
