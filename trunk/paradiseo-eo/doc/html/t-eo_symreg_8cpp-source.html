<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>EO: t-eoSymreg.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<div class="nav">
<a class="el" href="dir_000002.html">test</a></div>
<h1>t-eoSymreg.cpp</h1><div class="fragment"><pre class="fragment">00001 <span class="preprocessor">#ifdef _MSC_VER</span>
00002 <span class="preprocessor"></span><span class="preprocessor">#pragma warning(disable:4786)</span>
00003 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00004 <span class="preprocessor"></span>
00005 <span class="preprocessor">#include &lt;gp/eoParseTree.h&gt;</span>
00006 <span class="preprocessor">#include &lt;eo&gt;</span>
00007 
00008 <span class="keyword">using</span> <span class="keyword">namespace </span>gp_parse_tree;
00009 <span class="keyword">using</span> <span class="keyword">namespace </span>std;
00010 
00011 <span class="comment">//-----------------------------------------------------------------------------</span>
00012 
00013 <span class="keyword">class </span>SymregNode
00014 {
00015 <span class="keyword">public</span> :
00016 
00017         <span class="keyword">enum</span> Operator {X = <span class="charliteral">'x'</span>, Plus = <span class="charliteral">'+'</span>, Min = <span class="charliteral">'-'</span>, Mult = <span class="charliteral">'*'</span>, PDiv = <span class="charliteral">'/'</span>};
00018 
00019         SymregNode(<span class="keywordtype">void</span>)                                { init(); }
00020         SymregNode(Operator _op)                { op = _op; }
00021         <span class="keyword">virtual</span> ~SymregNode(<span class="keywordtype">void</span>)                       {}
00022 
00023         <span class="comment">// arity function, need this function!</span>
00024         <span class="keywordtype">int</span> arity(<span class="keywordtype">void</span>)<span class="keyword"> const      </span>{ <span class="keywordflow">return</span> op == X? 0 : 2; }
00025 
00026     <span class="keywordtype">void</span> randomize(<span class="keywordtype">void</span>) {}
00027     
00028         <span class="comment">// evaluation function, single case, using first argument to give value of variable</span>
00029         <span class="keyword">template</span> &lt;<span class="keyword">class</span> Children&gt;
00030         <span class="keywordtype">void</span> operator()(<span class="keywordtype">double</span>&amp; result, Children args, <span class="keywordtype">double</span> var)<span class="keyword"> const</span>
00031 <span class="keyword">        </span>{
00032         <span class="keywordtype">double</span> r1, r2;
00033 
00034         <span class="keywordflow">if</span> (arity() == 2)
00035         {
00036             args[0].apply(r1, var);
00037             args[1].apply(r2, var);
00038         }
00039 
00040                 <span class="keywordflow">switch</span> (op)
00041                 {
00042                 <span class="keywordflow">case</span> Plus : result = r1 + r2; <span class="keywordflow">break</span>;
00043                 <span class="keywordflow">case</span> Min  : result = r1 - r2; <span class="keywordflow">break</span>;
00044                 <span class="keywordflow">case</span> Mult : result = r1 * r2; <span class="keywordflow">break</span>;
00045                 <span class="keywordflow">case</span> PDiv : 
00046                         {
00047                                 <span class="keywordflow">if</span> (r2 == 0.0)
00048                                         result = 1.0; <span class="comment">// protection a la Koza, realistic implementations should maybe throw an exception</span>
00049                 <span class="keywordflow">else</span>
00050                                     result = r1 / r2;
00051                 <span class="keywordflow">break</span>;
00052                         }
00053 
00054                 <span class="keywordflow">case</span> X    : result = var; <span class="keywordflow">break</span>;
00055                 }
00056 
00057         }
00058 
00060     <span class="keyword">template</span> &lt;<span class="keyword">class</span> Children&gt;
00061         <span class="keywordtype">void</span> operator()(string&amp; result, Children args)<span class="keyword"> const</span>
00062 <span class="keyword">    </span>{
00063         <span class="keyword">static</span> <span class="keyword">const</span> string lb = <span class="stringliteral">"("</span>;
00064         <span class="keyword">static</span> <span class="keyword">const</span> string rb = <span class="stringliteral">")"</span>;
00065         <span class="keywordtype">char</span> opStr[4] = <span class="stringliteral">"   "</span>;
00066         opStr[1] = op;
00067         
00068             <span class="keywordflow">if</span> (arity() == 0)
00069                 {
00070             result = <span class="stringliteral">"x"</span>;
00071             <span class="keywordflow">return</span>;
00072         }
00073         <span class="comment">// else</span>
00074         string r1;
00075         args[0].apply(r1);
00076         result = lb + r1;
00077         result += opStr; 
00078         args[1].apply(r1);
00079         result += r1 + rb;
00080     }
00081 
00082     Operator getOp(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> op; }    
00083 
00084 <span class="keyword">protected</span> :
00085 
00086         <span class="keywordtype">void</span> init(<span class="keywordtype">void</span>)                                 { op = X; }
00087 
00088 <span class="keyword">private</span> :
00089 
00090         Operator op; <span class="comment">// the type of node</span>
00091 };
00092 
00094 <span class="keyword">static</span> SymregNode init_sequence[5] = {SymregNode::X, SymregNode::Plus, SymregNode::Min, SymregNode::Mult, SymregNode::PDiv}; <span class="comment">// needed for intialization</span>
00095 
00096 <span class="comment">// MSVC does not recognize the lt_arity&lt;Node&gt; in eoParseTreeDepthInit</span>
00097 <span class="comment">// without this specialization ...</span>
00098 <span class="comment">// 2 months later, it seems it does not accept this definition ...</span>
00099 <span class="comment">// but dies accept the lt_arity&lt;Node&gt; in eoParseTreeDepthInit</span>
00100 <span class="comment">// !!!</span>
00101 <span class="comment">// #ifdef _MSC_VER </span>
00102 <span class="comment">// template &lt;&gt;</span>
00103 <span class="comment">// bool lt_arity(const SymregNode &amp;node1, const SymregNode &amp;node2) </span>
00104 <span class="comment">// {</span>
00105 <span class="comment">//              return (node1.arity() &lt; node2.arity());</span>
00106 <span class="comment">// }</span>
00107 <span class="comment">// #endif</span>
00108 
00109 <span class="comment">//-----------------------------------------------------------</span>
00110 <span class="comment">// saving, loading</span>
00111 
00112 std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, <span class="keyword">const</span> SymregNode&amp; eot)
00113 {
00114     os &lt;&lt; static_cast&lt;char&gt;(eot.getOp());
00115     <span class="keywordflow">return</span> os;
00116 }
00117 
00118 std::istream&amp; operator&gt;&gt;(std::istream&amp; is, SymregNode&amp; eot)
00119 {
00120     <span class="keywordtype">char</span> type;
00121     type = (char) is.get();
00122     eot = SymregNode(static_cast&lt;SymregNode::Operator&gt;(type));
00123     <span class="keywordflow">return</span> is;
00124 }
00125 
00126 
00127 <span class="comment">//-----------------------------------------------------------------------------</span>
00130 <span class="comment"></span><span class="keywordtype">double</span> targetFunction(<span class="keywordtype">double</span> x)
00131 { 
00132         <span class="keywordflow">return</span> x * x * x * x - x * x * x + x * x * x - x * x + x - 10; 
00133 }
00134 
00135 <span class="comment">// parameters controlling the sampling of points</span>
00136 <span class="keyword">const</span> <span class="keywordtype">double</span> xbegin = -10.0f;
00137 <span class="keyword">const</span> <span class="keywordtype">double</span> xend   = 10.0f;
00138 <span class="keyword">const</span> <span class="keywordtype">double</span> xstep  = 1.3f; 
00139 
00140 <span class="keyword">template</span> &lt;<span class="keyword">class</span> FType, <span class="keyword">class</span> Node&gt; <span class="keyword">struct </span>RMS: <span class="keyword">public</span> <a class="code" href="classeo_eval_func.html">eoEvalFunc</a>&lt; eoParseTree&lt;FType, Node&gt; &gt; 
00141 {
00142 <span class="keyword">public</span> :
00143 
00144     <span class="keyword">typedef</span> <a class="code" href="classeo_parse_tree.html">eoParseTree&lt;FType, Node&gt;</a> <a class="code" href="classeo_parse_tree.html">EoType</a>;
00145 
00146     <span class="keyword">typedef</span> <a class="code" href="classeo_parse_tree.html">eoParseTree&lt;FType, Node&gt;</a> argument_type;
00147     <span class="keyword">typedef</span> <span class="keywordtype">double</span>                   <a class="code" href="classeo_pareto_fitness.html">fitness_type</a>;
00148 
00149         RMS(<span class="keywordtype">void</span>) : <a class="code" href="classeo_eval_func.html">eoEvalFunc</a>&lt;<a class="code" href="classeo_parse_tree.html">EoType</a>&gt;()
00150         {
00151                 <span class="keywordtype">int</span> n = int( (xend - xbegin) / xstep);
00152                 
00153                 inputs.resize(n);
00154                 target.resize(n);
00155 
00156                 <span class="keywordtype">int</span> i = 0;
00157 
00158         <span class="keywordflow">for</span> (<span class="keywordtype">double</span> x = xbegin; x &lt; xend &amp;&amp; i &lt; n; ++i, x+=xstep)
00159                 {
00160                         target[i] = targetFunction(x);
00161                         inputs[i] = x;
00162                 }
00163         }
00164 
00165     ~RMS() {}
00166     
00167         <span class="keywordtype">void</span> <a class="code" href="classeo_u_f.html#a1">operator()</a>( <a class="code" href="classeo_parse_tree.html">EoType</a> &amp; _eo )  
00168         {
00169                 vector&lt;double&gt; outputs;
00170                 outputs.resize(inputs.size());
00171                 
00172         <span class="keywordtype">double</span> fitness = 0.0;
00173         
00174         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; inputs.size(); ++i)
00175         {
00176                     _eo.apply(outputs[i], inputs[i]);
00177                 fitness += (outputs[i] - target[i]) * (outputs[i] - target[i]);
00178         }
00179                 
00180         fitness /= (double) target.size();
00181         fitness = sqrt(fitness);
00182                         
00183                 <span class="keywordflow">if</span> (fitness &gt; 1e+20)
00184                         fitness = 1e+20;
00185 
00186                 _eo.<a class="code" href="class_e_o.html#a2">fitness</a>(fitness);
00187         }
00188 
00189 <span class="keyword">private</span> :
00190         vector&lt;double&gt; inputs;
00191         vector&lt;double&gt; target;
00192 };
00193 
00194 <span class="keyword">template</span> &lt;<span class="keyword">class</span> EOT, <span class="keyword">class</span> FitnessType&gt;
00195 <span class="keywordtype">void</span> print_best(<a class="code" href="classeo_pop.html">eoPop&lt;EOT&gt;</a>&amp; pop)
00196 {
00197     std::cout &lt;&lt; std::endl;
00198     <a class="code" href="classeo_pareto_fitness.html">FitnessType</a> best = pop[0].fitness();
00199     <span class="keywordtype">int</span> index = 0;
00200 
00201     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 1; i &lt; pop.size(); ++i)
00202     {
00203         <span class="keywordflow">if</span> (best &lt; pop[i].fitness())
00204         {
00205             best = pop[i].fitness();
00206             index = i;
00207         }
00208     }
00209     
00210     std::cout &lt;&lt; <span class="stringliteral">"\t"</span>;
00211         
00212     string str;
00213     pop[index].apply(str);
00214     
00215     std::cout &lt;&lt; str.c_str();
00216     std::cout &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">"RMS Error = "</span> &lt;&lt; pop[index].fitness() &lt;&lt; std::endl;
00217 }
00218 
00219 <span class="keywordtype">int</span> main()
00220 {
00221     <span class="keyword">typedef</span> <a class="code" href="classeo_scalar_fitness.html">eoMinimizingFitness</a> <a class="code" href="classeo_pareto_fitness.html">FitnessType</a>;
00222     <span class="keyword">typedef</span> SymregNode GpNode;
00223 
00224     <span class="keyword">typedef</span> <a class="code" href="classeo_parse_tree.html">eoParseTree&lt;FitnessType, GpNode&gt;</a> <a class="code" href="classeo_parse_tree.html">EoType</a>;
00225     <span class="keyword">typedef</span> <a class="code" href="classeo_pop.html">eoPop&lt;EoType&gt;</a> <a class="code" href="classeo_pop.html">Pop</a>;  
00226 
00227     <span class="keyword">const</span> <span class="keywordtype">int</span> MaxSize = 100;
00228     <span class="keyword">const</span> <span class="keywordtype">int</span> nGenerations = 10; <span class="comment">// only a test, so few generations</span>
00229 
00230     <span class="comment">// Initializor sequence, contains the allowable nodes</span>
00231     vector&lt;GpNode&gt; init(init_sequence, init_sequence + 5);
00232 
00233     <span class="comment">// Depth Initializor, defaults to grow method.</span>
00234     eoGpDepthInitializer&lt;FitnessType, GpNode&gt; initializer(10, init);
00235     
00236     <span class="comment">// Root Mean Squared Error Measure</span>
00237     RMS&lt;FitnessType, GpNode&gt;              eval;
00238 
00239     Pop pop(50, initializer);
00240 
00241     apply&lt;EoType&gt;(eval, pop);
00242 
00243     <a class="code" href="classeo_subtree_x_over.html">eoSubtreeXOver&lt;FitnessType, GpNode&gt;</a>   xover(MaxSize);
00244     <a class="code" href="classeo_branch_mutation.html">eoBranchMutation&lt;FitnessType, GpNode&gt;</a> mutation(initializer, MaxSize);
00245 
00246     <span class="comment">// The operators are  encapsulated into an eoTRansform object, </span>
00247     <span class="comment">// that performs sequentially crossover and mutation</span>
00248     <a class="code" href="classeo_s_g_a_transform.html">eoSGATransform&lt;EoType&gt;</a> transform(xover, 0.75, mutation, 0.25);
00249 
00250     <span class="comment">// The robust tournament selection</span>
00251     <a class="code" href="classeo_det_tournament_select.html">eoDetTournamentSelect&lt;EoType&gt;</a> selectOne(2);   <span class="comment">// tSize in [2,POPSIZE]</span>
00252     <span class="comment">// is now encapsulated in a eoSelectMany: 2 at a time -&gt; SteadyState</span>
00253     <a class="code" href="classeo_select_many.html">eoSelectMany&lt;EoType&gt;</a> select(selectOne,2, eo_is_an_integer);    
00254   
00255     <span class="comment">// and the Steady-State replacement</span>
00256     <a class="code" href="classeo_s_s_g_a_worse_replacement.html">eoSSGAWorseReplacement&lt;EoType&gt;</a> replace;
00257   
00258     <span class="comment">// Terminators</span>
00259     <a class="code" href="classeo_gen_continue.html">eoGenContinue&lt;EoType&gt;</a> term(nGenerations);
00260 
00261     <a class="code" href="classeo_check_point.html">eoCheckPoint&lt;EoType&gt;</a> checkPoint(term);
00262 
00263     <a class="code" href="classeo_average_stat.html">eoAverageStat&lt;EoType&gt;</a>     avg;
00264     <a class="code" href="classeo_best_fitness_stat.html">eoBestFitnessStat&lt;EoType&gt;</a> best;
00265     <a class="code" href="classeo_stdout_monitor.html">eoStdoutMonitor</a> monitor;
00266 
00267     checkPoint.add(monitor);
00268     checkPoint.add(avg);
00269     checkPoint.add(best);
00270 
00271     monitor.<a class="code" href="classeo_monitor.html#a1">add</a>(avg);
00272     monitor.<a class="code" href="classeo_monitor.html#a1">add</a>(best);
00273 
00274     <span class="comment">// GP generation</span>
00275     <a class="code" href="classeo_easy_e_a.html">eoEasyEA&lt;EoType&gt;</a> gp(checkPoint, eval, select, transform, replace);
00276 
00277     std::cout &lt;&lt; <span class="stringliteral">"Initialization done"</span> &lt;&lt; std::endl;
00278 
00279     print_best&lt;EoType, FitnessType&gt;(pop);
00280 
00281     <span class="keywordflow">try</span>
00282     {
00283       gp(pop);
00284     }
00285     <span class="keywordflow">catch</span> (std::exception&amp; e)
00286     {
00287             std::cout &lt;&lt; <span class="stringliteral">"exception: "</span> &lt;&lt; e.what() &lt;&lt; std::endl;;
00288             exit(EXIT_FAILURE);
00289     }
00290 
00291     print_best&lt;EoType, FitnessType&gt;(pop);
00292 
00293 }
00294 
00295 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Thu Oct 19 05:06:44 2006 for EO by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
