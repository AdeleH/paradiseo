<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>EO: README.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<div class="nav">
<a class="el" href="dir_000007.html">contrib</a>&nbsp;/&nbsp;<a class="el" href="dir_000008.html">mathsym</a>&nbsp;/&nbsp;<a class="el" href="dir_000028.html">sym</a></div>
<h1>README.cpp</h1><div class="fragment"><pre class="fragment">00001 
00002 <span class="comment">/* </span>
00003 <span class="comment">        DESCRIPTION:</span>
00004 <span class="comment"></span>
00005 <span class="comment"></span>
00006 <span class="comment">The class 'Sym' in this package provides a reference counted, hashed tree structure that can be used in genetic programming.</span>
00007 <span class="comment">The hash table behind the scenes makes sure that every subtree in the application is stored only once.</span>
00008 <span class="comment">This has a couple of advantages:</span>
00009 <span class="comment"></span>
00010 <span class="comment">o Memory: all subtrees are stored only once</span>
00011 <span class="comment">o Comparison: comparison for equality for two subtrees boils down to a pointer comparison </span>
00012 <span class="comment">o Overview: by accessing the hashtable, you get an instant overview of the state of the population</span>
00013 <span class="comment"></span>
00014 <span class="comment"></span>
00015 <span class="comment">The disadvantage of this method is the constant time overhead for computing hashes. In practice,</span>
00016 <span class="comment">it seems to be fast enough.</span>
00017 <span class="comment"></span>
00018 <span class="comment"></span>
00019 <span class="comment">===== How to Use this =========</span>
00020 <span class="comment"></span>
00021 <span class="comment">In essence, the Sym data structure contains two important pieces of data,</span>
00022 <span class="comment">the 'token' (of type token_t = int) and the children, a vector of Sym (called SymVec).</span>
00023 <span class="comment">The token should contain all information to be able to figure out which </span>
00024 <span class="comment">function/terminal is represented by the node in the tree. By retrieving this token value</span>
00025 <span class="comment">and the SymVec it is possible to write recursive traversal routines for evaluation, printing,</span>
00026 <span class="comment">etc.</span>
00027 <span class="comment"></span>
00028 <span class="comment">*/</span>
00029 
00030 <span class="preprocessor">#include &lt;iostream&gt;</span>
00031 <span class="preprocessor">#include "Sym.h"</span>
00032 
00033 <span class="keyword">using</span> <span class="keyword">namespace </span>std;
00034 
00035 
00036 <span class="comment">/* </span>
00037 <span class="comment"> * Suppose token value '0' designates our terminal, and token value '1' designates a binary function.</span>
00038 <span class="comment"> * Later on a ternary function will be used as well, designated with token value '2'</span>
00039 <span class="comment"> * The function below will create a tree of size three</span>
00040 <span class="comment">*/</span>
00041 Sym test1() {
00042     
00043     SymVec children; 
00044     children.push_back( Sym(0) ); <span class="comment">// push_back is a member from std::vector, SymVec is derived from std::vector</span>
00045     children.push_back( Sym(0) );
00046 
00047     Sym tree = Sym(token_t(1), children); <span class="comment">// creates the tree</span>
00048 
00049     <span class="comment">/* Done, now print some information about the node */</span>
00050 
00051     cout &lt;&lt; <span class="stringliteral">"Size      =  "</span> &lt;&lt; tree.size() &lt;&lt; endl;     <span class="comment">// prints 3</span>
00052     cout &lt;&lt; <span class="stringliteral">"Depth     = "</span> &lt;&lt; tree.depth() &lt;&lt; endl;    <span class="comment">// prints 2</span>
00053     cout &lt;&lt; <span class="stringliteral">"Refcount  = "</span> &lt;&lt; tree.refcount() &lt;&lt; endl; <span class="comment">// prints 1</span>
00054 
00055     Sym tree2 = tree; <span class="comment">// make a copy (this only changes refcount)</span>
00056 
00057     cout &lt;&lt; <span class="stringliteral">"Refcount now = "</span> &lt;&lt; tree.refcount() &lt;&lt; endl; <span class="comment">// print 2</span>
00058     
00059     <span class="keywordflow">return</span> tree; <span class="comment">// tree2 will be deleted and reference count returns to 1</span>
00060 }
00061 
00062 <span class="comment">/* To actually use the tree, evaluate it, the following simple recursive function</span>
00063 <span class="comment"> * can be used</span>
00064 <span class="comment">*/</span>
00065 
00066 <span class="keywordtype">int</span> eval(<span class="keyword">const</span> Sym&amp; sym) {
00067     <span class="keywordflow">if</span> (sym.token() == 0) { <span class="comment">// it's a terminal in this example</span>
00068         <span class="keywordflow">return</span> 1;
00069     }
00070     <span class="comment">// else it's the function</span>
00071     <span class="keyword">const</span> SymVec&amp; children = sym.args(); <span class="comment">// get the children out, children.size() is the arity</span>
00072 
00073     <span class="comment">// let's assume that we've also got a ternary function designated by token '2'</span>
00074     
00075     <span class="keywordflow">if</span> (sym.token() == token_t(1))
00076         <span class="keywordflow">return</span> eval(children[0]) + eval(children[1]); <span class="comment">// evaluate</span>
00077 
00078     <span class="keywordflow">return</span> eval(children[0]) + eval(children[1]) * eval(children[2]); <span class="comment">// a ternary function</span>
00079 }
00080 
00081 <span class="comment">/* Note that you simply use the stored token that was defined above. Simply checking the size of SymVec in</span>
00082 <span class="comment"> * this particular example could have sufficed, but it's instructive to use the tokens.</span>
00083 <span class="comment"> * </span>
00084 <span class="comment"> * And to test this: </span>
00085 <span class="comment">*/</span>
00086 
00087 <span class="keywordtype">void</span> test_eval() {
00088     
00089     Sym tree = test1();
00090 
00091     cout &lt;&lt; <span class="stringliteral">"Evaluating tree1 returns "</span> &lt;&lt; eval(tree) &lt;&lt; endl;
00092 }
00093 
00094 <span class="comment">/* Writing initialization functions.</span>
00095 <span class="comment"> *</span>
00096 <span class="comment"> * As the Sym class is recursive in nature, initialization can simply be done using </span>
00097 <span class="comment"> * recursive routines as above. As an example, the following code does 'full' initialization.</span>
00098 <span class="comment"> */</span>
00099 
00100 Sym init_full(<span class="keywordtype">int</span> depth_left) {
00101     <span class="keywordflow">if</span> (depth_left == 0) <span class="keywordflow">return</span> Sym(0); <span class="comment">// create terminal</span>
00102     <span class="comment">// else create either a binary or a ternary function</span>
00103     
00104     depth_left--;
00105     
00106     <span class="keywordflow">if</span> (rand() % 2 == 0) { <span class="comment">// create binary</span>
00107         SymVec vec(2);
00108         vec[0] = init_full(depth_left);
00109         vec[1] = init_full(depth_left);
00110 
00111         <span class="keywordflow">return</span> Sym(token_t(1), vec);
00112         
00113     } <span class="keywordflow">else</span> { <span class="comment">// create ternary tree</span>
00114         SymVec vec(3);
00115         vec[0] = init_full(depth_left);
00116         vec[1] = init_full(depth_left);
00117         vec[2] = init_full(depth_left);
00118 
00119         <span class="keywordflow">return</span> Sym(token_t(2), vec); <span class="comment">// token value 2 designates a ternary now, even though the arity can simply be read from the size of the 'SymVec'</span>
00120     }
00121     
00122 }
00123 
00124 
00125 <span class="comment">/* Examining the hash table.</span>
00126 <span class="comment"> *</span>
00127 <span class="comment"> * The hash table is a static member of the Sym class, but can be obtained and inspected</span>
00128 <span class="comment"> * at any point during the run. The hash table follows the SGI implementation of hashmap (and effectively</span>
00129 <span class="comment"> * uses it in gcc). An example:</span>
00130 <span class="comment"> */</span>
00131 
00132 <span class="keywordtype">void</span> inspect_hashtable() {
00133     SymMap&amp; dag = Sym::get_dag(); <span class="comment">// get the hashmap</span>
00134     <span class="keywordtype">unsigned</span> i = 0;
00135     <span class="keywordflow">for</span> (SymMap::iterator it = dag.begin(); it != dag.end(); ++it) {
00136         Sym node(it); <span class="comment">// initialize a 'sym' with the iterator </span>
00137 
00138         cout &lt;&lt; <span class="stringliteral">"Node "</span> &lt;&lt; i++ &lt;&lt; <span class="stringliteral">" size "</span> &lt;&lt; node.size();
00139         cout &lt;&lt; <span class="stringliteral">" refcount "</span> &lt;&lt; node.refcount()-1; <span class="comment">// -1: note that by creating the Sym above the refcount is increased</span>
00140         cout &lt;&lt; <span class="stringliteral">" depth "</span> &lt;&lt; node.depth();
00141         cout &lt;&lt; <span class="charliteral">'\n'</span>;
00142     }
00143     
00144 }
00145 
00146 <span class="comment">/* The above code effectively examines all distinct subtrees in use in the application and prints some stats for the node */</span>
00147 
00148 <span class="comment">/* Manipulating trees </span>
00149 <span class="comment"> *</span>
00150 <span class="comment"> * The Sym class is set up in such a way that you cannot change a Sym, so how do you perform crossover and mutation?</span>
00151 <span class="comment"> *</span>
00152 <span class="comment"> * Simple, you create new syms. The Sym class supports two functions to make this easier: 'get_subtree' and 'insert_subtree'.</span>
00153 <span class="comment"> * These traverse the tree by index, where 0 designates the root and other values are indexed depth first.</span>
00154 <span class="comment"> */</span>
00155 
00156 Sym subtree_xover(Sym a, Sym b) {
00157     
00158     Sym to_insert = get_subtree(a,  rand() % a.size() ); <span class="comment">// select random subtree, will crash if too high a value is given</span>
00159     
00160     <span class="comment">/* 'insert' it into b. This will not really insert, it will however create a new sym,</span>
00161 <span class="comment">     * equal to 'b' but with a's subtree inserted at the designated spot. */</span>
00162     <span class="keywordflow">return</span> insert_subtree(b, rand() % b.size(), to_insert); 
00163     
00164 }
00165 
00166 <span class="comment">/* Tying it together, we can create a simple genetic programming system. Mutation is not implemented here,</span>
00167 <span class="comment"> * but would be easy enough to add by using recursion and/or 'set'. */</span>
00168 
00169 <span class="keywordtype">void</span> run_gp() {
00170     
00171     <span class="keywordtype">int</span> ngens = 50;
00172     <span class="keywordtype">int</span> popsize = 1000;
00173 
00174     cout &lt;&lt; <span class="stringliteral">"Starting running "</span> &lt;&lt; popsize &lt;&lt; <span class="stringliteral">" individuals for "</span> &lt;&lt; ngens &lt;&lt; <span class="stringliteral">" generations."</span> &lt;&lt; endl;
00175     
00176     vector&lt;Sym&gt; pop(popsize); 
00177     
00178     <span class="comment">// init population</span>
00179     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; pop.size(); ++i) {
00180         pop[i] = init_full(5); 
00181     }
00182     
00183     <span class="keywordtype">double</span> best = 0.0;
00184     
00185     <span class="comment">// do a very simple steady state tournament </span>
00186     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> gen = 0; gen &lt; ngens * pop.size(); ++gen) {
00187         <span class="keywordtype">int</span> sel1 = rand()% pop.size();
00188         <span class="keywordtype">int</span> sel2 = rand() % pop.size();
00189         <span class="keywordtype">int</span> sel3 = rand() % pop.size();
00190 
00191         <span class="keywordtype">double</span> ev1 = eval(pop[sel1]);
00192         <span class="keywordtype">double</span> ev3 = eval(pop[sel3]);
00193         
00194         <span class="keywordtype">double</span> bst = max(ev1,ev3);
00195         <span class="keywordflow">if</span> (bst &gt; best) {
00196             best = bst;
00197         }
00198         
00199         <span class="keywordflow">if</span> (ev3 &gt; ev1) {
00200             sel1 = sel3; <span class="comment">// selection pressure</span>
00201         }
00202 
00203         Sym child = subtree_xover(pop[sel1], pop[sel2]);
00204         
00205         <span class="comment">// Check for uniqueness</span>
00206         <span class="keywordflow">if</span> (child.refcount() == 1) pop[ rand() % pop.size() ] = child;
00207     }
00208     
00209     <span class="comment">// and at the end:</span>
00210     
00211     inspect_hashtable();
00212 
00213     <span class="comment">// and also count number of nodes in the population</span>
00214     <span class="keywordtype">int</span> sz = 0;
00215     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; pop.size(); ++i) { sz += pop[i].size(); }
00216     cout &lt;&lt; <span class="stringliteral">"Number of distinct nodes "</span> &lt;&lt; Sym::get_dag().size() &lt;&lt; endl;
00217     cout &lt;&lt; <span class="stringliteral">"Nodes in population      "</span> &lt;&lt; sz &lt;&lt; endl;
00218     cout &lt;&lt; <span class="stringliteral">"ratio                    "</span> &lt;&lt; double(Sym::get_dag().size())/sz &lt;&lt; endl;
00219     cout &lt;&lt; <span class="stringliteral">"Best fitness             "</span> &lt;&lt; best &lt;&lt; endl;
00220     
00221 }
00222 
00223 <span class="comment">/* One extra mechanism is supported to add annotations to nodes. Something derived from</span>
00224 <span class="comment"> * 'UniqueNodeStats' can be used to attach new information to nodes. For this to function,</span>
00225 <span class="comment"> * we need to supply a 'factory' function that creates these node-stats; attach this function to the </span>
00226 <span class="comment"> * Sym class, so that it gets called whenever a new node is created. The constructors of the Sym class</span>
00227 <span class="comment"> * take care of this.</span>
00228 <span class="comment"> *</span>
00229 <span class="comment"> * IMPORTANT: </span>
00230 <span class="comment"> *      in a realistic application, the factory function needs to be set BEFORE any Syms are created</span>
00231 <span class="comment"> *      Mixing Syms creating with and without the factory can lead to unexpected results    </span>
00232 <span class="comment"> *</span>
00233 <span class="comment"> * First we derive some structure from UniqueNodeStats: */</span>
00234 
00235 <span class="keyword">struct </span>MyNodeStats : <span class="keyword">public</span> UniqueNodeStats {
00236     
00237     <span class="keywordtype">int</span> sumsize;
00238     
00239     ~MyNodeStats() { cout &lt;&lt; <span class="stringliteral">"MyNodeStats::~MyNodeStats, sumsize = "</span> &lt;&lt; sumsize &lt;&lt; endl; }
00240 };
00241 
00242 <span class="comment">/* then define the factory function. It will get a Sym, which is just created.  */</span>
00243 UniqueNodeStats* create_stats(<span class="keyword">const</span> Sym&amp; sym) {
00244     MyNodeStats* stats = <span class="keyword">new</span> MyNodeStats; <span class="comment">// Sym will take care of memory management</span>
00245     
00246     <span class="keywordtype">int</span> sumsize = sym.size();
00247     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; sym.args().size(); ++i) {
00248         <span class="comment">// retrieve the extra node stats of the child</span>
00249         UniqueNodeStats* unique_stats = sym.args()[i].extra_stats(); <span class="comment">// extra_stats retrieves the stats</span>
00250         MyNodeStats* child_stats = static_cast&lt;MyNodeStats*&gt;(unique_stats); <span class="comment">// cast it to the right struct</span>
00251         sumsize += child_stats-&gt;sumsize;
00252     }
00253     
00254     stats-&gt;sumsize = sumsize;
00255     <span class="keywordflow">return</span> stats; <span class="comment">// now it will get attached to the node and deleted when its reference count goes to zero</span>
00256 }
00257 
00258 <span class="keywordtype">void</span> test_node_stats() {
00259     
00260     <span class="keywordflow">if</span> (Sym::get_dag().size() != 0) {
00261         cerr &lt;&lt; <span class="stringliteral">"Cannot mix nodes with and without factory functions"</span> &lt;&lt; endl;
00262         exit(1);
00263     }
00264     
00265     <span class="comment">/* Very Important: attach the factory function to the Sym class */</span>
00266     Sym::set_factory_function(create_stats);
00267 
00268     Sym tree = init_full(5); <span class="comment">// create a tree</span>
00269     
00270     <span class="comment">// get extra node stats out</span>
00271     MyNodeStats* stats = static_cast&lt;MyNodeStats*&gt;( tree.extra_stats() );
00272 
00273     cout &lt;&lt; <span class="stringliteral">"Size = "</span> &lt;&lt; tree.size() &lt;&lt; <span class="stringliteral">" SumSize = "</span> &lt;&lt; stats-&gt;sumsize &lt;&lt; endl;
00274     
00275     Sym::clear_factory_function(); <span class="comment">// reset</span>
00276 }
00277 
00278 
00279 <span class="comment">/* And run the code above */</span>
00280 
00281 <span class="keywordtype">int</span> main() {
00282     srand(time(0));
00283     cout &lt;&lt; <span class="stringliteral">"********** TEST EVALUATION **************\n"</span>;
00284     test_eval();
00285     cout &lt;&lt; <span class="stringliteral">"********** TEST ALGORITHM ***************\n"</span>;
00286     run_gp();
00287 
00288     cout &lt;&lt; <span class="stringliteral">"********** TEST FACTORY  ****************\n"</span>;
00289     test_node_stats(); <span class="comment">// can work because there are no live nodes</span>
00290 
00291 }
00292 
00293 <span class="comment">/* ********** Member function reference: ********************</span>
00294 <span class="comment"> *</span>
00295 <span class="comment"> * Sym()            The default constructor will create an undefined node (no token and no children), check for empty() to see if a node is undefined</span>
00296 <span class="comment"> * </span>
00297 <span class="comment"> * Sym(token_t)     Create a terminal</span>
00298 <span class="comment"> *</span>
00299 <span class="comment"> * Sym(token_t, const SymVec&amp;)</span>
00300 <span class="comment"> *                  Create a node with token and SymVec as the children</span>
00301 <span class="comment"> * </span>
00302 <span class="comment"> * Sym(SymIterator it)</span>
00303 <span class="comment"> *                  Create a sym from an iterator (taken from the hashtable directly, or from Sym::iterator)</span>
00304 <span class="comment"> *</span>
00305 <span class="comment"> * dtor, copy-ctor and assignment</span>
00306 <span class="comment"> *</span>
00307 <span class="comment"> * UniqueNodeStats* extra_stats()    </span>
00308 <span class="comment"> *                  Returns an UniqueNodeStats pointer (= 0 if no factory is defined)</span>
00309 <span class="comment"> * </span>
00310 <span class="comment"> * </span>
00311 <span class="comment"> * int hashcode()   returns the hashcode for the node</span>
00312 <span class="comment"> * </span>
00313 <span class="comment"> * int refcount()   returns the reference count for the node</span>
00314 <span class="comment"> * </span>
00315 <span class="comment"> * bool operator==  checks for equality (note that this is a pointer compare, really really fast)</span>
00316 <span class="comment"> * </span>
00317 <span class="comment"> * bool empty()     returns whether the node is undefined, i.e. created through the default ctor </span>
00318 <span class="comment"> * </span>
00319 <span class="comment"> * int arity()      shorthand for sym.args().size()</span>
00320 <span class="comment"> * </span>
00321 <span class="comment"> * token_t token()  return identifying token for the node</span>
00322 <span class="comment"> * </span>
00323 <span class="comment"> * const SymVec&amp; args()</span>
00324 <span class="comment"> *                  returns the children of the node (in a vector&lt;Sym&gt;)</span>
00325 <span class="comment"> *                  </span>
00326 <span class="comment"> * unsigned size()  returns the size, i.e., number of nodes</span>
00327 <span class="comment"> * </span>
00328 <span class="comment"> * unsigned depth() returns the depth</span>
00329 <span class="comment"> * </span>
00330 <span class="comment"> * iterator()       returns the pointer to the node in the hashtable</span>
00331 <span class="comment"> *</span>
00332 <span class="comment"> * </span>
00333 <span class="comment"> ********** Static functions: ********************</span>
00334 <span class="comment"> *</span>
00335 <span class="comment"> *</span>
00336 <span class="comment"> * </span>
00337 <span class="comment"> * SymMap&amp; get_dag()    returns the hash table containing all nodes. This should only be used for inspection,</span>
00338 <span class="comment"> *                      even though the dag itself is not const. This to enable the use of the ctor Sym(SymIterator) to inspect</span>
00339 <span class="comment"> *                      using the Sym interface (rather than the hash table interface). This does allow you to make destructive</span>
00340 <span class="comment"> *                      changes to the class, so use with care</span>
00341 <span class="comment"> *</span>
00342 <span class="comment"> * set_factory_function( UniqueNodeStats (*)(const Sym&amp;) )</span>
00343 <span class="comment"> *                      Set the factory function</span>
00344 <span class="comment"> *</span>
00345 <span class="comment"> *  clear_factory_function()    </span>
00346 <span class="comment"> *                      Clears the factory function, allocated UniqueNodeStats will still be deleted, but no new ones will be created.</span>
00347 <span class="comment"> *</span>
00348 <span class="comment"> ********** Utility Functions ******************** </span>
00349 <span class="comment"> * </span>
00350 <span class="comment"> * Sym get_subtree(const Sym&amp; org, int i)</span>
00351 <span class="comment"> *                      Retreive the i-th subtree from the Sym. Standard depth first ordering, where root has index 0 and the</span>
00352 <span class="comment"> *                      rightmost terminal has index sym.size()-1</span>
00353 <span class="comment"> *</span>
00354 <span class="comment"> * Sym insert_subtree(const Sym&amp; org, int i, const Sym&amp; subtree)</span>
00355 <span class="comment"> *                      Returns a Sym that is equal to 'org', for which the i-th subtree (same ordering as get_subtree) is replaced</span>
00356 <span class="comment"> *                      by the third argument subtree.</span>
00357 <span class="comment"> * </span>
00358 <span class="comment"> * Sym next(const Sym&amp;)</span>
00359 <span class="comment"> *                      Returns the successor of the argument sym from the hashtable with wrap around. This is implemented just because</span>
00360 <span class="comment"> *                      it can be done. It may be an interesting way to mutate...</span>
00361 <span class="comment"> * </span>
00362 <span class="comment"> * */</span>
00363 
00364 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Thu Oct 19 05:06:42 2006 for EO by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
