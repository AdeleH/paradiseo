\section{eo\-Pareto\-One\-Constraint\-Fitness$<$ Fitness\-Traits $>$ Class Template Reference}
\label{classeo_pareto_one_constraint_fitness}\index{eoParetoOneConstraintFitness@{eoParetoOneConstraintFitness}}
eo\-Pareto\-One\-Constraint\-Fitness class: std::vector of doubles + constraint value  


{\tt \#include $<$eo\-Pareto\-Constraint\-Fitness.h$>$}

\subsection*{Public Types}
\begin{CompactItemize}
\item 
typedef Fitness\-Traits {\bf fitness\_\-traits}\label{classeo_pareto_one_constraint_fitness_w0}

\end{CompactItemize}
\subsection*{Public Member Functions}
\begin{CompactItemize}
\item 
{\bf eo\-Pareto\-One\-Constraint\-Fitness} (std::vector$<$ double $>$ \&\_\-v)\label{classeo_pareto_one_constraint_fitness_a1}

\item 
{\bf eo\-Pareto\-One\-Constraint\-Fitness} (std::vector$<$ double $>$ \&\_\-v, double \_\-c)\label{classeo_pareto_one_constraint_fitness_a2}

\item 
bool {\bf feasible} () const \label{classeo_pareto_one_constraint_fitness_a3}

\item 
double {\bf violation} () const \label{classeo_pareto_one_constraint_fitness_a4}

\item 
double {\bf Constraint\-Value} () const \label{classeo_pareto_one_constraint_fitness_a5}

\item 
void {\bf Constraint\-Value} (double \_\-c)\label{classeo_pareto_one_constraint_fitness_a6}

\item 
bool {\bf dominates} (const {\bf eo\-Pareto\-One\-Constraint\-Fitness}$<$ Fitness\-Traits $>$ \&\_\-other) const \label{classeo_pareto_one_constraint_fitness_a7}

\begin{CompactList}\small\item\em Partial order based on Pareto-dominance. \item\end{CompactList}\item 
bool {\bf operator$<$} (const {\bf eo\-Pareto\-One\-Constraint\-Fitness}$<$ Fitness\-Traits $>$ \&\_\-other) const \label{classeo_pareto_one_constraint_fitness_a8}

\begin{CompactList}\small\item\em compare $\ast$not$\ast$ on dominance, but on the first, then the second, etc \item\end{CompactList}\item 
bool {\bf operator$>$} (const {\bf eo\-Pareto\-One\-Constraint\-Fitness}$<$ Fitness\-Traits $>$ \&\_\-other) const \label{classeo_pareto_one_constraint_fitness_a9}

\item 
bool {\bf operator$<$=} (const {\bf eo\-Pareto\-One\-Constraint\-Fitness}$<$ Fitness\-Traits $>$ \&\_\-other) const \label{classeo_pareto_one_constraint_fitness_a10}

\item 
bool {\bf operator$>$=} (const {\bf eo\-Pareto\-One\-Constraint\-Fitness}$<$ Fitness\-Traits $>$ \&\_\-other) const \label{classeo_pareto_one_constraint_fitness_a11}

\item 
bool {\bf operator==} (const {\bf eo\-Pareto\-One\-Constraint\-Fitness}$<$ Fitness\-Traits $>$ \&\_\-other) const \label{classeo_pareto_one_constraint_fitness_a12}

\item 
bool {\bf operator!=} (const {\bf eo\-Pareto\-One\-Constraint\-Fitness}$<$ Fitness\-Traits $>$ \&\_\-other) const \label{classeo_pareto_one_constraint_fitness_a13}

\end{CompactItemize}
\subsection*{Static Public Member Functions}
\begin{CompactItemize}
\item 
void {\bf set\-Up} (unsigned \_\-n, std::vector$<$ bool $>$ \&\_\-b)\label{classeo_pareto_one_constraint_fitness_e0}

\begin{CompactList}\small\item\em access to the traits characteristics (so you don't have to write a lot of typedef's around \item\end{CompactList}\item 
bool {\bf maximizing} (unsigned \_\-i)\label{classeo_pareto_one_constraint_fitness_e1}

\end{CompactItemize}
\subsection*{Private Attributes}
\begin{CompactItemize}
\item 
double {\bf constraint\-Value}\label{classeo_pareto_one_constraint_fitness_r0}

\end{CompactItemize}


\subsection{Detailed Description}
\subsubsection*{template$<$class Fitness\-Traits = eo\-Pareto\-Fitness\-Traits$>$ class eo\-Pareto\-One\-Constraint\-Fitness$<$ Fitness\-Traits $>$}

eo\-Pareto\-One\-Constraint\-Fitness class: std::vector of doubles + constraint value 

Comparison (dominance) is done on pareto dominance for 2 feasible individuals, one feasible individual always wins over an infeasible on constraint violations for 2 infeasible individuals

The template argument Fitness\-Traits defaults to {\bf eo\-Pareto\-Fitness\-Traits}{\rm (p.\,\pageref{classeo_pareto_fitness_traits})}, which can be replaces at will by any other class that implements the static functions defined therein.

Note that the domninance defines a partial order, so that !dominates(a,b) \&\& !domaintes(b,a) does not neccessarily imply that (a==b) The other way around does hold.

However, be careful that the comparison operators do define a total order based on considering first objective, then in case of tie, second objective, etc

NOTE: in a hurry, I did not want to make it derive from {\bf eo\-Pareto\-Fitness}{\rm (p.\,\pageref{classeo_pareto_fitness})} (used cut-and-paste instead!) : I know it might be a good idea, but I'm not sure I see why at the moment (any hint someone?) 



Definition at line 61 of file eo\-Pareto\-Constraint\-Fitness.h.

The documentation for this class was generated from the following file:\begin{CompactItemize}
\item 
eo\-Pareto\-Constraint\-Fitness.h\end{CompactItemize}
