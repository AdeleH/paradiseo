<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>EO: eoRealOp.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<div class="nav">
<a class="el" href="dir_000000.html">src</a>&nbsp;/&nbsp;<a class="el" href="dir_000010.html">es</a></div>
<h1>eoRealOp.h</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">// -*- mode: c++; c-indent-level: 4; c++-member-init-indent: 8; comment-column: 35; -*-</span>
00002 
00003 <span class="comment">//-----------------------------------------------------------------------------</span>
00004 <span class="comment">// eoRealOp.h</span>
00005 <span class="comment">// (c) Maarten Keijzer 2000 - Marc Schoenauer 2001</span>
00006 <span class="comment">/*</span>
00007 <span class="comment">    This library is free software; you can redistribute it and/or</span>
00008 <span class="comment">    modify it under the terms of the GNU Lesser General Public</span>
00009 <span class="comment">    License as published by the Free Software Foundation; either</span>
00010 <span class="comment">    version 2 of the License, or (at your option) any later version.</span>
00011 <span class="comment"></span>
00012 <span class="comment">    This library is distributed in the hope that it will be useful,</span>
00013 <span class="comment">    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00014 <span class="comment">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
00015 <span class="comment">    Lesser General Public License for more details.</span>
00016 <span class="comment"></span>
00017 <span class="comment">    You should have received a copy of the GNU Lesser General Public</span>
00018 <span class="comment">    License along with this library; if not, write to the Free Software</span>
00019 <span class="comment">    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
00020 <span class="comment"></span>
00021 <span class="comment">    Contact: Marc.Schoenauer@polytechnique.fr</span>
00022 <span class="comment">             mak@dhi.dk</span>
00023 <span class="comment"> */</span>
00024 <span class="comment">//-----------------------------------------------------------------------------</span>
00025 
00026 <span class="preprocessor">#ifndef eoRealOp_h</span>
00027 <span class="preprocessor"></span><span class="preprocessor">#define eoRealOp_h</span>
00028 <span class="preprocessor"></span>
00029 <span class="comment">//-----------------------------------------------------------------------------</span>
00030 
00031 <span class="preprocessor">#include &lt;algorithm&gt;</span>    <span class="comment">// swap_ranges</span>
00032 <span class="preprocessor">#include &lt;utils/eoRNG.h&gt;</span>
00033 <span class="preprocessor">#include &lt;es/eoReal.h&gt;</span>
00034 <span class="preprocessor">#include &lt;utils/eoRealVectorBounds.h&gt;</span>
00035 
00036 <span class="comment">//-----------------------------------------------------------------------------</span>
00037 
<a name="l00045"></a><a class="code" href="classeo_uniform_mutation.html">00045</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> EOT&gt; <span class="keyword">class </span><a class="code" href="classeo_uniform_mutation.html">eoUniformMutation</a>: <span class="keyword">public</span> <a class="code" href="classeo_mon_op.html">eoMonOp</a>&lt;EOT&gt;
00046 {
00047  <span class="keyword">public</span>:
<a name="l00056"></a><a class="code" href="classeo_uniform_mutation.html#a0">00056</a>   <a class="code" href="classeo_uniform_mutation.html#a0">eoUniformMutation</a>(<span class="keyword">const</span> <span class="keywordtype">double</span>&amp; _epsilon, <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; _p_change = 1.0):
00057     homogeneous(true), bounds(eoDummyVectorNoBounds), epsilon(1, _epsilon),
00058     p_change(1, _p_change) {}
00059 
<a name="l00066"></a><a class="code" href="classeo_uniform_mutation.html#a1">00066</a>   <a class="code" href="classeo_uniform_mutation.html#a0">eoUniformMutation</a>(<a class="code" href="classeo_real_vector_bounds.html">eoRealVectorBounds</a> &amp; _bounds,
00067                     <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; _epsilon, <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; _p_change = 1.0):
00068     homogeneous(false), bounds(_bounds), epsilon(_bounds.size(), _epsilon),
00069     p_change(_bounds.size(), _p_change)
00070   {
00071     <span class="comment">// scale to the range - if any</span>
00072     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;bounds.size(); i++)
00073       <span class="keywordflow">if</span> (bounds.<a class="code" href="classeo_real_base_vector_bounds.html#a4">isBounded</a>(i))
00074           epsilon[i] *= _epsilon*bounds.<a class="code" href="classeo_real_base_vector_bounds.html#a18">range</a>(i);
00075   }
00076 
<a name="l00083"></a><a class="code" href="classeo_uniform_mutation.html#a2">00083</a>   <a class="code" href="classeo_uniform_mutation.html#a0">eoUniformMutation</a>(<a class="code" href="classeo_real_vector_bounds.html">eoRealVectorBounds</a> &amp; _bounds,
00084                     <span class="keyword">const</span> std::vector&lt;double&gt;&amp; _epsilon,
00085                     <span class="keyword">const</span> std::vector&lt;double&gt;&amp; _p_change):
00086     homogeneous(false), bounds(_bounds), epsilon(_epsilon),
00087     p_change(_p_change) {}
00088 
<a name="l00090"></a><a class="code" href="classeo_uniform_mutation.html#a3">00090</a>   <span class="keyword">virtual</span> std::string <a class="code" href="classeo_uniform_mutation.html#a3">className</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">"eoUniformMutation"</span>; }
00091 
<a name="l00096"></a><a class="code" href="classeo_uniform_mutation.html#a4">00096</a>   <span class="keywordtype">bool</span> <a class="code" href="classeo_uniform_mutation.html#a4">operator()</a>(<a class="code" href="struct_dummy.html">EOT</a>&amp; _eo)
00097     {
00098       <span class="keywordtype">bool</span> hasChanged=<span class="keyword">false</span>;
00099       <span class="keywordflow">if</span> (homogeneous)             <span class="comment">// implies no bounds object</span>
00100         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> lieu=0; lieu&lt;_eo.size(); lieu++)
00101           {
00102             <span class="keywordflow">if</span> (rng.<a class="code" href="classeo_rng.html#a6">flip</a>(p_change[0]))
00103               {
00104                 _eo[lieu] += 2*epsilon[0]*rng.<a class="code" href="classeo_rng.html#a4">uniform</a>()-epsilon[0];
00105                 hasChanged = <span class="keyword">true</span>;
00106               }
00107           }
00108       <span class="keywordflow">else</span>
00109         {
00110           <span class="comment">// sanity check ?</span>
00111           <span class="keywordflow">if</span> (_eo.size() != bounds.size())
00112             <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">"Invalid size of indi in eoUniformMutation"</span>);
00113 
00114           <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> lieu=0; lieu&lt;_eo.size(); lieu++)
00115             <span class="keywordflow">if</span> (rng.<a class="code" href="classeo_rng.html#a6">flip</a>(p_change[lieu]))
00116               {
00117                 <span class="comment">// check the bounds</span>
00118                 <span class="keywordtype">double</span> emin = _eo[lieu]-epsilon[lieu];
00119                 <span class="keywordtype">double</span> emax = _eo[lieu]+epsilon[lieu];
00120                 <span class="keywordflow">if</span> (bounds.<a class="code" href="classeo_real_base_vector_bounds.html#a8">isMinBounded</a>(lieu))
00121                   emin = std::max(bounds.<a class="code" href="classeo_real_base_vector_bounds.html#a16">minimum</a>(lieu), emin);
00122                 <span class="keywordflow">if</span> (bounds.<a class="code" href="classeo_real_base_vector_bounds.html#a9">isMaxBounded</a>(lieu))
00123                   emax = std::min(bounds.<a class="code" href="classeo_real_base_vector_bounds.html#a17">maximum</a>(lieu), emax);
00124                 _eo[lieu] = emin + (emax-emin)*rng.<a class="code" href="classeo_rng.html#a4">uniform</a>();
00125                 hasChanged = <span class="keyword">true</span>;
00126               }
00127         }
00128       <span class="keywordflow">return</span> hasChanged;
00129     }
00130 
00131 <span class="keyword">private</span>:
00132   <span class="keywordtype">bool</span> homogeneous;   <span class="comment">// == no bounds passed in the ctor</span>
00133   <a class="code" href="classeo_real_vector_bounds.html">eoRealVectorBounds</a> &amp; bounds;
00134   std::vector&lt;double&gt; epsilon;     <span class="comment">// the ranges for mutation</span>
00135   std::vector&lt;double&gt; p_change;    <span class="comment">// the proba that each variable is modified</span>
00136 };
00137 
<a name="l00144"></a><a class="code" href="classeo_det_uniform_mutation.html">00144</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> EOT&gt; <span class="keyword">class </span><a class="code" href="classeo_det_uniform_mutation.html">eoDetUniformMutation</a>: <span class="keyword">public</span> <a class="code" href="classeo_mon_op.html">eoMonOp</a>&lt;EOT&gt;
00145 {
00146  <span class="keyword">public</span>:
<a name="l00154"></a><a class="code" href="classeo_det_uniform_mutation.html#a0">00154</a>   <a class="code" href="classeo_det_uniform_mutation.html#a0">eoDetUniformMutation</a>(<span class="keyword">const</span> <span class="keywordtype">double</span>&amp; _epsilon, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; _no = 1):
00155     homogeneous(true), bounds(eoDummyVectorNoBounds),
00156     epsilon(1, _epsilon), no(_no) {}
00157 
<a name="l00164"></a><a class="code" href="classeo_det_uniform_mutation.html#a1">00164</a>   <a class="code" href="classeo_det_uniform_mutation.html#a0">eoDetUniformMutation</a>(<a class="code" href="classeo_real_vector_bounds.html">eoRealVectorBounds</a> &amp; _bounds,
00165                        <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; _epsilon, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; _no = 1):
00166     homogeneous(false), bounds(_bounds),
00167     epsilon(_bounds.size(), _epsilon), no(_no)
00168   {
00169     <span class="comment">// scale to the range - if any</span>
00170     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;bounds.size(); i++)
00171       <span class="keywordflow">if</span> (bounds.<a class="code" href="classeo_real_base_vector_bounds.html#a4">isBounded</a>(i))
00172           epsilon[i] *= _epsilon*bounds.<a class="code" href="classeo_real_base_vector_bounds.html#a18">range</a>(i);
00173   }
00174 
<a name="l00181"></a><a class="code" href="classeo_det_uniform_mutation.html#a2">00181</a>   <a class="code" href="classeo_det_uniform_mutation.html#a0">eoDetUniformMutation</a>(<a class="code" href="classeo_real_vector_bounds.html">eoRealVectorBounds</a> &amp; _bounds,
00182                        <span class="keyword">const</span> std::vector&lt;double&gt;&amp; _epsilon,
00183                        <span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; _no = 1):
00184     homogeneous(false), bounds(_bounds), epsilon(_epsilon), no(_no)
00185   {
00186     <span class="comment">// scale to the range - if any</span>
00187     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;bounds.size(); i++)
00188       <span class="keywordflow">if</span> (bounds.<a class="code" href="classeo_real_base_vector_bounds.html#a4">isBounded</a>(i))
00189           epsilon[i] *= _epsilon[i]*bounds.<a class="code" href="classeo_real_base_vector_bounds.html#a18">range</a>(i);
00190   }
00191 
<a name="l00193"></a><a class="code" href="classeo_det_uniform_mutation.html#a3">00193</a>   <span class="keyword">virtual</span> std::string <a class="code" href="classeo_det_uniform_mutation.html#a3">className</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">"eoDetUniformMutation"</span>; }
00194 
<a name="l00199"></a><a class="code" href="classeo_det_uniform_mutation.html#a4">00199</a>   <span class="keywordtype">bool</span> <a class="code" href="classeo_det_uniform_mutation.html#a4">operator()</a>(<a class="code" href="struct_dummy.html">EOT</a>&amp; _eo)
00200     {
00201       <span class="keywordflow">if</span> (homogeneous)
00202         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;no; i++)
00203           {
00204             <span class="keywordtype">unsigned</span> lieu = rng.<a class="code" href="classeo_rng.html#a5">random</a>(_eo.size());
00205             <span class="comment">// actually, we should test that we don't re-modify same variable!</span>
00206             _eo[lieu] = 2*epsilon[0]*rng.<a class="code" href="classeo_rng.html#a4">uniform</a>()-epsilon[0];
00207           }
00208       <span class="keywordflow">else</span>
00209         {
00210           <span class="comment">// sanity check ?</span>
00211           <span class="keywordflow">if</span> (_eo.size() != bounds.size())
00212             <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">"Invalid size of indi in eoDetUniformMutation"</span>);
00213           <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;no; i++)
00214             {
00215               <span class="keywordtype">unsigned</span> lieu = rng.<a class="code" href="classeo_rng.html#a5">random</a>(_eo.size());
00216               <span class="comment">// actually, we should test that we don't re-modify same variable!</span>
00217 
00218               <span class="comment">// check the bounds</span>
00219               <span class="keywordtype">double</span> emin = _eo[lieu]-epsilon[lieu];
00220               <span class="keywordtype">double</span> emax = _eo[lieu]+epsilon[lieu];
00221               <span class="keywordflow">if</span> (bounds.<a class="code" href="classeo_real_base_vector_bounds.html#a8">isMinBounded</a>(lieu))
00222                 emin = std::max(bounds.<a class="code" href="classeo_real_base_vector_bounds.html#a16">minimum</a>(lieu), emin);
00223               <span class="keywordflow">if</span> (bounds.<a class="code" href="classeo_real_base_vector_bounds.html#a9">isMaxBounded</a>(lieu))
00224                 emax = std::min(bounds.<a class="code" href="classeo_real_base_vector_bounds.html#a17">maximum</a>(lieu), emax);
00225               _eo[lieu] = emin + (emax-emin)*rng.<a class="code" href="classeo_rng.html#a4">uniform</a>();
00226             }
00227         }
00228       <span class="keywordflow">return</span> <span class="keyword">true</span>;
00229     }
00230 
00231 <span class="keyword">private</span>:
00232   <span class="keywordtype">bool</span> homogeneous;   <span class="comment">//  == no bounds passed in the ctor</span>
00233   <a class="code" href="classeo_real_vector_bounds.html">eoRealVectorBounds</a> &amp; bounds;
00234   std::vector&lt;double&gt; epsilon;     <span class="comment">// the ranges of mutation</span>
00235   <span class="keywordtype">unsigned</span> no;
00236 };
00237 
00238 
00239 <span class="comment">// two arithmetical crossovers</span>
00240 
<a name="l00247"></a><a class="code" href="classeo_segment_crossover.html">00247</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> EOT&gt; <span class="keyword">class </span><a class="code" href="classeo_segment_crossover.html">eoSegmentCrossover</a>: <span class="keyword">public</span> <a class="code" href="classeo_quad_op.html">eoQuadOp</a>&lt;EOT&gt;
00248 {
00249  <span class="keyword">public</span>:
<a name="l00259"></a><a class="code" href="classeo_segment_crossover.html#a0">00259</a>   <a class="code" href="classeo_segment_crossover.html#a0">eoSegmentCrossover</a>(<span class="keyword">const</span> <span class="keywordtype">double</span>&amp; _alpha = 0.0) :
00260     bounds(eoDummyVectorNoBounds), alpha(_alpha), range(1+2*_alpha) {}
00261 
<a name="l00270"></a><a class="code" href="classeo_segment_crossover.html#a1">00270</a>   <a class="code" href="classeo_segment_crossover.html#a0">eoSegmentCrossover</a>(<a class="code" href="classeo_real_vector_bounds.html">eoRealVectorBounds</a> &amp; _bounds,
00271                      <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; _alpha = 0.0) :
00272     bounds(_bounds), alpha(_alpha), range(1+2*_alpha) {}
00273 
<a name="l00275"></a><a class="code" href="classeo_segment_crossover.html#a2">00275</a>   <span class="keyword">virtual</span> std::string <a class="code" href="classeo_segment_crossover.html#a2">className</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">"eoSegmentCrossover"</span>; }
00276 
<a name="l00282"></a><a class="code" href="classeo_segment_crossover.html#a3">00282</a>   <span class="keywordtype">bool</span> <a class="code" href="classeo_segment_crossover.html#a3">operator()</a>(<a class="code" href="struct_dummy.html">EOT</a>&amp; _eo1, <a class="code" href="struct_dummy.html">EOT</a>&amp; _eo2)
00283     {
00284       <span class="keywordtype">unsigned</span> i;
00285       <span class="keywordtype">double</span> r1, r2, fact;
00286       <span class="keywordtype">double</span> alphaMin = -alpha;
00287       <span class="keywordtype">double</span> alphaMax = 1+alpha;
00288       <span class="keywordflow">if</span> (alpha == 0.0)            <span class="comment">// no check to perform</span>
00289         fact = -alpha + rng.<a class="code" href="classeo_rng.html#a4">uniform</a>(range); <span class="comment">// in [-alpha,1+alpha)</span>
00290       <span class="keywordflow">else</span>                         <span class="comment">// look for the bounds for fact</span>
00291         {
00292           <span class="keywordflow">for</span> (i=0; i&lt;_eo1.size(); i++)
00293             {
00294               r1=_eo1[i];
00295               r2=_eo2[i];
00296               <span class="keywordflow">if</span> (r1 != r2) {      <span class="comment">// otherwise you'll get NAN's</span>
00297                 <span class="keywordtype">double</span> rmin = std::min(r1, r2);
00298                 <span class="keywordtype">double</span> rmax = std::max(r1, r2);
00299                 <span class="keywordtype">double</span> length = rmax - rmin;
00300                 <span class="keywordflow">if</span> (bounds.<a class="code" href="classeo_real_base_vector_bounds.html#a8">isMinBounded</a>(i))
00301                   {
00302                     alphaMin = std::max(alphaMin, (bounds.<a class="code" href="classeo_real_base_vector_bounds.html#a16">minimum</a>(i)-rmin)/length);
00303                     alphaMax = std::min(alphaMax, (rmax-bounds.<a class="code" href="classeo_real_base_vector_bounds.html#a16">minimum</a>(i))/length);
00304                   }
00305                 <span class="keywordflow">if</span> (bounds.<a class="code" href="classeo_real_base_vector_bounds.html#a9">isMaxBounded</a>(i))
00306                   {
00307                     alphaMax = std::min(alphaMax, (bounds.<a class="code" href="classeo_real_base_vector_bounds.html#a17">maximum</a>(i)-rmin)/length);
00308                     alphaMin = std::max(alphaMin, (rmax-bounds.<a class="code" href="classeo_real_base_vector_bounds.html#a17">maximum</a>(i))/length);
00309                   }
00310               }
00311             }
00312           fact = alphaMin + (alphaMax-alphaMin)*rng.<a class="code" href="classeo_rng.html#a4">uniform</a>();
00313         }
00314 
00315       <span class="keywordflow">for</span> (i=0; i&lt;_eo1.size(); i++)
00316         {
00317           r1=_eo1[i];
00318           r2=_eo2[i];
00319           _eo1[i] = fact * r1 + (1-fact) * r2;
00320           _eo2[i] = (1-fact) * r1 + fact * r2;
00321         }
00322       <span class="keywordflow">return</span> <span class="keyword">true</span>;         <span class="comment">// shoudl test if fact was 0 or 1 :-)))</span>
00323     }
00324 
00325 <span class="keyword">protected</span>:
00326   <a class="code" href="classeo_real_vector_bounds.html">eoRealVectorBounds</a> &amp; bounds;
00327   <span class="keywordtype">double</span> alpha;
00328   <span class="keywordtype">double</span> range;                    <span class="comment">// == 1+2*alpha</span>
00329 };
00330 
00337 <span class="keyword">template</span>&lt;<span class="keyword">class</span> EOT&gt; <span class="keyword">class </span>eoHypercubeCrossover: <span class="keyword">public</span> <a class="code" href="classeo_quad_op.html">eoQuadOp</a>&lt;EOT&gt;
00338 {
00339  <span class="keyword">public</span>:
00349   eoHypercubeCrossover(<span class="keyword">const</span> <span class="keywordtype">double</span>&amp; _alpha = 0.0):
00350     bounds(eoDummyVectorNoBounds), alpha(_alpha), range(1+2*_alpha)
00351   {
00352     <span class="keywordflow">if</span> (_alpha &lt; 0)
00353       <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">"BLX coefficient should be positive"</span>);
00354   }
00355 
00364   eoHypercubeCrossover(<a class="code" href="classeo_real_vector_bounds.html">eoRealVectorBounds</a> &amp; _bounds,
00365                         <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; _alpha = 0.0):
00366     bounds(_bounds), alpha(_alpha), range(1+2*_alpha)
00367   {
00368     <span class="keywordflow">if</span> (_alpha &lt; 0)
00369       <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">"BLX coefficient should be positive"</span>);
00370   }
00371 
00373   <span class="keyword">virtual</span> std::string className()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">"eoHypercubeCrossover"</span>; }
00374 
00380   <span class="keywordtype">bool</span> <a class="code" href="classeo_b_f.html#a1">operator()</a>(<a class="code" href="struct_dummy.html">EOT</a>&amp; _eo1, <a class="code" href="struct_dummy.html">EOT</a>&amp; _eo2)
00381     {
00382       <span class="keywordtype">bool</span> hasChanged = <span class="keyword">false</span>;
00383       <span class="keywordtype">unsigned</span> i;
00384       <span class="keywordtype">double</span> r1, r2, fact;
00385       <span class="keywordflow">if</span> (alpha == 0.0)            <span class="comment">// no check to perform</span>
00386           <span class="keywordflow">for</span> (i=0; i&lt;_eo1.size(); i++)
00387             {
00388               r1=_eo1[i];
00389               r2=_eo2[i];
00390               <span class="keywordflow">if</span> (r1 != r2) {      <span class="comment">// otherwise do nothing</span>
00391                 fact = rng.<a class="code" href="classeo_rng.html#a4">uniform</a>(range);       <span class="comment">// in [0,1)</span>
00392                 _eo1[i] = fact * r1 + (1-fact) * r2;
00393                 _eo2[i] = (1-fact) * r1 + fact * r2;
00394                 hasChanged = <span class="keyword">true</span>; <span class="comment">// forget (im)possible alpha=0</span>
00395               }
00396             }
00397       <span class="keywordflow">else</span>         <span class="comment">// check the bounds</span>
00398         <span class="comment">// do not try to get a bound on the linear factor, but rather</span>
00399         <span class="comment">// on the object variables themselves</span>
00400         <span class="keywordflow">for</span> (i=0; i&lt;_eo1.size(); i++)
00401           {
00402             r1=_eo1[i];
00403             r2=_eo2[i];
00404             <span class="keywordflow">if</span> (r1 != r2) {        <span class="comment">// otherwise do nothing</span>
00405               <span class="keywordtype">double</span> rmin = std::min(r1, r2);
00406               <span class="keywordtype">double</span> rmax = std::max(r1, r2);
00407 
00408               <span class="comment">// compute min and max for object variables</span>
00409               <span class="keywordtype">double</span> objMin = -alpha * rmax + (1+alpha) * rmin;
00410               <span class="keywordtype">double</span> objMax = -alpha * rmin + (1+alpha) * rmax;
00411 
00412               <span class="comment">// first find the limits on the alpha's</span>
00413               <span class="keywordflow">if</span> (bounds.isMinBounded(i))
00414                 {
00415                   objMin = std::max(objMin, bounds.minimum(i));
00416                 }
00417               <span class="keywordflow">if</span> (bounds.isMaxBounded(i))
00418                 {
00419                   objMax = std::min(objMax, bounds.maximum(i));
00420                 }
00421               <span class="comment">// then draw variables</span>
00422               <span class="keywordtype">double</span> median = (objMin+objMax)/2.0; <span class="comment">// uniform within bounds</span>
00423               <span class="comment">// double median = (rmin+rmax)/2.0;  // Bounce on bounds</span>
00424               <span class="keywordtype">double</span> valMin = objMin + (median-objMin)*rng.<a class="code" href="classeo_rng.html#a4">uniform</a>();
00425               <span class="keywordtype">double</span> valMax = median + (objMax-median)*rng.<a class="code" href="classeo_rng.html#a4">uniform</a>();
00426               <span class="comment">// don't always put large value in _eo1 - or what?</span>
00427               <span class="keywordflow">if</span> (rng.<a class="code" href="classeo_rng.html#a6">flip</a>(0.5))
00428                 {
00429                   _eo1[i] = valMin;
00430                   _eo2[i] = valMax;
00431                 }
00432               <span class="keywordflow">else</span>
00433                 {
00434                   _eo1[i] = valMax;
00435                   _eo2[i] = valMin;
00436                 }
00437               <span class="comment">// seomthing has changed</span>
00438               hasChanged = <span class="keyword">true</span>; <span class="comment">// forget (im)possible alpha=0</span>
00439             }
00440           }
00441 
00442     <span class="keywordflow">return</span> hasChanged;
00443    }
00444 
00445 <span class="keyword">protected</span>:
00446   <a class="code" href="classeo_real_vector_bounds.html">eoRealVectorBounds</a> &amp; bounds;
00447   <span class="keywordtype">double</span> alpha;
00448   <span class="keywordtype">double</span> range;                    <span class="comment">// == 1+2*alphaMin</span>
00449 };
00450 
00451 
00457 <span class="keyword">template</span>&lt;<span class="keyword">class</span> EOT&gt; <span class="keyword">class </span>eoRealUXover: <span class="keyword">public</span> <a class="code" href="classeo_quad_op.html">eoQuadOp</a>&lt;EOT&gt;
00458 {
00459  <span class="keyword">public</span>:
00464   eoRealUXover(<span class="keyword">const</span> <span class="keywordtype">float</span>&amp; _preference = 0.5): preference(_preference)
00465     {
00466       <span class="keywordflow">if</span> ( (_preference &lt;= 0.0) || (_preference &gt;= 1.0) )
00467         std::runtime_error(<span class="stringliteral">"UxOver --&gt; invalid preference"</span>);
00468     }
00469 
00471   <span class="keyword">virtual</span> std::string className()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">"eoRealUXover"</span>; }
00472 
00479   <span class="keywordtype">bool</span> <a class="code" href="classeo_b_f.html#a1">operator()</a>(<a class="code" href="struct_dummy.html">EOT</a>&amp; _eo1, <a class="code" href="struct_dummy.html">EOT</a>&amp; _eo2)
00480     {
00481       <span class="keywordflow">if</span> ( _eo1.size() != _eo2.size())
00482             std::runtime_error(<span class="stringliteral">"UxOver --&gt; chromosomes sizes don't match"</span> );
00483       <span class="keywordtype">bool</span> changed = <span class="keyword">false</span>;
00484       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;_eo1.size(); i++)
00485         {
00486           <span class="keywordflow">if</span> (rng.<a class="code" href="classeo_rng.html#a6">flip</a>(preference))
00487             <span class="keywordflow">if</span> (_eo1[i] != _eo2[i])
00488               {
00489                 <span class="keywordtype">double</span> tmp = _eo1[i];
00490               _eo1[i]=_eo2[i];
00491               _eo2[i] = tmp;
00492               changed = <span class="keyword">true</span>;
00493             }
00494         }
00495       <span class="keywordflow">return</span> changed;
00496     }
00497     <span class="keyword">private</span>:
00498       <span class="keywordtype">float</span> preference;
00499 };
00500 
00501 
00502 <span class="comment">//-----------------------------------------------------------------------------</span>
00504 <span class="comment"></span><span class="preprocessor">#endif</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Thu Oct 19 05:06:37 2006 for EO by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
