<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>EO: SecondRealEA.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<div class="nav">
<a class="el" href="dir_000003.html">tutorial</a>&nbsp;/&nbsp;<a class="el" href="dir_000005.html">Lesson3</a></div>
<h1>SecondRealEA.cpp</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">//-----------------------------------------------------------------------------</span>
00002 <span class="comment">// SecondRealEA.cpp</span>
00003 <span class="comment">//-----------------------------------------------------------------------------</span>
00004 <span class="comment">//*</span>
00005 <span class="comment">// Same code than FirstBitEA as far as Evolutionary Computation is concerned</span>
00006 <span class="comment">// but now you learn to enter the parameters in a more flexible way</span>
00007 <span class="comment">// (also slightly different than in SecondBitEA.cpp)</span>
00008 <span class="comment">// and to twidle the output to your preferences (as in SecondBitEA.cpp)</span>
00009 <span class="comment">//</span>
00010 <span class="comment">//-----------------------------------------------------------------------------</span>
00011 <span class="preprocessor">#ifdef HAVE_CONFIG_H</span>
00012 <span class="preprocessor"></span><span class="preprocessor">#include &lt;config.h&gt;</span>
00013 <span class="preprocessor">#endif</span>
00014 <span class="preprocessor"></span>
00015 <span class="comment">// standard includes</span>
00016 <span class="preprocessor">#include &lt;fstream&gt;</span>
00017 <span class="preprocessor">#include &lt;iostream&gt;</span>   <span class="comment">// cout</span>
00018 <span class="preprocessor">#include &lt;stdexcept&gt;</span>  <span class="comment">// runtime_error</span>
00019 
00020 <span class="comment">// the general include for eo</span>
00021 <span class="preprocessor">#include &lt;eo&gt;</span>
00022 <span class="preprocessor">#include &lt;es.h&gt;</span>
00023 
00024 <span class="comment">// REPRESENTATION</span>
00025 <span class="comment">//-----------------------------------------------------------------------------</span>
00026 <span class="comment">// define your individuals</span>
00027 <span class="keyword">typedef</span> <a class="code" href="classeo_real.html">eoReal&lt;eoMinimizingFitness&gt;</a> <a class="code" href="classeo_real.html">Indi</a>;
00028 
00029 <span class="comment">// Use functions from namespace std</span>
00030 <span class="keyword">using</span> <span class="keyword">namespace </span>std;
00031 
00032 <span class="comment">// EVALFUNC</span>
00033 <span class="comment">//-----------------------------------------------------------------------------</span>
00034 <span class="comment">// a simple fitness function that computes the euclidian norm of a real vector</span>
00035 <span class="comment">// Now in a separate file, and declared as binary_value(const vector&lt;bool&gt; &amp;)</span>
00036 
00037 <span class="preprocessor">#include "real_value.h"</span>
00038 
00039 <span class="comment">// GENERAL</span>
00040 <span class="comment">//-----------------------------------------------------------------------------</span>
00041 
00042 <span class="keywordtype">void</span> main_function(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)
00043 {
00044 <span class="comment">// PARAMETRES</span>
00045 <span class="comment">//-----------------------------------------------------------------------------</span>
00046 <span class="comment">// instead of having all values of useful parameters as constants, read them:</span>
00047 <span class="comment">// either on the command line (--option=value or -o=value)</span>
00048 <span class="comment">//     or in a parameter file (same syntax, order independent,</span>
00049 <span class="comment">//                             # = usual comment character</span>
00050 <span class="comment">//     or in the environment (TODO)</span>
00051 
00052   <span class="comment">// First define a parser from the command-line arguments</span>
00053   eoParser parser(argc, argv);
00054 
00055   <span class="comment">// For each parameter, you can in on single line</span>
00056   <span class="comment">// define the parameter, read it through the parser, and assign it</span>
00057 
00058   <span class="keywordtype">unsigned</span> seed = parser.createParam(<span class="keywordtype">unsigned</span>(time(0)), <span class="stringliteral">"seed"</span>, <span class="stringliteral">"Random number seed"</span>, <span class="charliteral">'S'</span>).value(); <span class="comment">// will be in default section General</span>
00059 
00060   <span class="comment">// description of genotype</span>
00061   <span class="keywordtype">unsigned</span> vecSize = parser.createParam(<span class="keywordtype">unsigned</span>(8), <span class="stringliteral">"vecSize"</span>, <span class="stringliteral">"Genotype size"</span>,<span class="charliteral">'V'</span>, <span class="stringliteral">"Representation"</span> ).value();
00062 
00063    <span class="comment">// parameters for evolution engine</span>
00064     <span class="keywordtype">unsigned</span> popSize = parser.createParam(<span class="keywordtype">unsigned</span>(10), <span class="stringliteral">"popSize"</span>, <span class="stringliteral">"Population size"</span>,<span class="charliteral">'P'</span>, <span class="stringliteral">"Evolution engine"</span> ).value();
00065 
00066     <span class="keywordtype">unsigned</span> tSize = parser.createParam(<span class="keywordtype">unsigned</span>(2), <span class="stringliteral">"tSize"</span>, <span class="stringliteral">"Tournament size"</span>,<span class="charliteral">'T'</span>, <span class="stringliteral">"Evolution Engine"</span> ).value();
00067 
00068    <span class="comment">// init and stop</span>
00069     string loadName = parser.createParam(string(<span class="stringliteral">""</span>), <span class="stringliteral">"Load"</span>,<span class="stringliteral">"A save file to restart from"</span>,<span class="charliteral">'L'</span>, <span class="stringliteral">"Persistence"</span> ).value();
00070 
00071     <span class="keywordtype">unsigned</span> maxGen = parser.createParam(<span class="keywordtype">unsigned</span>(100), <span class="stringliteral">"maxGen"</span>, <span class="stringliteral">"Maximum number of generations"</span>,<span class="charliteral">'G'</span>, <span class="stringliteral">"Stopping criterion"</span> ).value();
00072 
00073     <span class="keywordtype">unsigned</span> minGen = parser.createParam(<span class="keywordtype">unsigned</span>(100), <span class="stringliteral">"minGen"</span>, <span class="stringliteral">"Minimum number of generations"</span>,<span class="charliteral">'g'</span>, <span class="stringliteral">"Stopping criterion"</span> ).value();
00074 
00075     <span class="keywordtype">unsigned</span> steadyGen = parser.createParam(<span class="keywordtype">unsigned</span>(100), <span class="stringliteral">"steadyGen"</span>, <span class="stringliteral">"Number of generations with no improvement"</span>,<span class="charliteral">'s'</span>, <span class="stringliteral">"Stopping criterion"</span> ).value();
00076 
00077    <span class="comment">// operators probabilities at the algorithm level</span>
00078     <span class="keywordtype">double</span> pCross = parser.createParam(<span class="keywordtype">double</span>(0.6), <span class="stringliteral">"pCross"</span>, <span class="stringliteral">"Probability of Crossover"</span>, <span class="charliteral">'C'</span>, <span class="stringliteral">"Genetic Operators"</span> ).value();
00079 
00080     <span class="keywordtype">double</span> pMut = parser.createParam(<span class="keywordtype">double</span>(0.1), <span class="stringliteral">"pMut"</span>, <span class="stringliteral">"Probability of Mutation"</span>, <span class="charliteral">'M'</span>, <span class="stringliteral">"Genetic Operators"</span> ).value();
00081 
00082    <span class="comment">// relative rates for crossovers</span>
00083     <span class="keywordtype">double</span> hypercubeRate = parser.createParam(<span class="keywordtype">double</span>(1), <span class="stringliteral">"hypercubeRate"</span>, <span class="stringliteral">"Relative rate for hypercube crossover"</span>, <span class="charliteral">'\0'</span>, <span class="stringliteral">"Genetic Operators"</span> ).value();
00084 
00085     <span class="keywordtype">double</span> segmentRate = parser.createParam(<span class="keywordtype">double</span>(1), <span class="stringliteral">"segmentRate"</span>, <span class="stringliteral">"Relative rate for segment crossover"</span>, <span class="charliteral">'\0'</span>, <span class="stringliteral">"Genetic Operators"</span> ).value();
00086 
00087     <span class="comment">// internal parameters for the mutations</span>
00088     <span class="keywordtype">double</span> EPSILON = parser.createParam(<span class="keywordtype">double</span>(0.01), <span class="stringliteral">"EPSILON"</span>, <span class="stringliteral">"Width for uniform mutation"</span>, <span class="charliteral">'\0'</span>, <span class="stringliteral">"Genetic Operators"</span> ).value();
00089 
00090     <span class="keywordtype">double</span> SIGMA = parser.createParam(<span class="keywordtype">double</span>(0.3), <span class="stringliteral">"SIGMA"</span>, <span class="stringliteral">"Sigma for normal mutation"</span>, <span class="charliteral">'\0'</span>, <span class="stringliteral">"Genetic Operators"</span> ).value();
00091 
00092    <span class="comment">// relative rates for mutations</span>
00093     <span class="keywordtype">double</span> uniformMutRate = parser.createParam(<span class="keywordtype">double</span>(1), <span class="stringliteral">"uniformMutRate"</span>, <span class="stringliteral">"Relative rate for uniform mutation"</span>, <span class="charliteral">'\0'</span>, <span class="stringliteral">"Genetic Operators"</span> ).value();
00094 
00095     <span class="keywordtype">double</span> detMutRate = parser.createParam(<span class="keywordtype">double</span>(1), <span class="stringliteral">"detMutRate"</span>, <span class="stringliteral">"Relative rate for det-uniform mutation"</span>, <span class="charliteral">'\0'</span>, <span class="stringliteral">"Genetic Operators"</span> ).value();
00096 
00097     <span class="keywordtype">double</span> normalMutRate = parser.createParam(<span class="keywordtype">double</span>(1), <span class="stringliteral">"normalMutRate"</span>, <span class="stringliteral">"Relative rate for normal mutation"</span>, <span class="charliteral">'\0'</span>, <span class="stringliteral">"Genetic Operators"</span> ).value();
00098 
00099     <span class="comment">// the name of the "status" file where all actual parameter values will be saved</span>
00100     string str_status = parser.ProgramName() + <span class="stringliteral">".status"</span>; <span class="comment">// default value</span>
00101     string statusName = parser.createParam(str_status, <span class="stringliteral">"status"</span>,<span class="stringliteral">"Status file"</span>,<span class="charliteral">'S'</span>, <span class="stringliteral">"Persistence"</span> ).value();
00102 
00103    <span class="comment">// do the following AFTER ALL PARAMETERS HAVE BEEN PROCESSED</span>
00104    <span class="comment">// i.e. in case you need parameters somewhere else, postpone these</span>
00105     <span class="keywordflow">if</span> (parser.userNeedsHelp())
00106       {
00107         parser.printHelp(cout);
00108         exit(1);
00109       }
00110     <span class="keywordflow">if</span> (statusName != <span class="stringliteral">""</span>)
00111       {
00112         ofstream os(statusName.c_str());
00113         os &lt;&lt; parser;           <span class="comment">// and you can use that file as parameter file</span>
00114       }
00115 
00116 <span class="comment">// EVAL</span>
00118 <span class="comment"></span>  <span class="comment">// Fitness function</span>
00120 <span class="comment"></span>  <span class="comment">// Evaluation: from a plain C++ fn to an EvalFunc Object</span>
00121   <span class="comment">// you need to give the full description of the function</span>
00122   <a class="code" href="structeo_eval_func_ptr.html">eoEvalFuncPtr&lt;Indi, double, const vector&lt;double&gt;</a>&amp; &gt; plainEval(  real_value );
00123   <span class="comment">// ... to an object that counts the nb of actual evaluations</span>
00124   <a class="code" href="classeo_eval_func_counter.html">eoEvalFuncCounter&lt;Indi&gt;</a> eval(plainEval);
00125 
00126 <span class="comment">// INIT</span>
00128 <span class="comment"></span>  <span class="comment">// Initilisation of population</span>
00130 <span class="comment"></span>  <span class="comment">// Either load or initialize</span>
00131   <span class="comment">// create an empty pop</span>
00132   <a class="code" href="classeo_pop.html">eoPop&lt;Indi&gt;</a> pop;
00133   <span class="comment">// create a state for reading</span>
00134   <a class="code" href="classeo_state.html">eoState</a> inState;              <span class="comment">// a state for loading - WITHOUT the parser</span>
00135   <span class="comment">// register the rng and the pop in the state, so they can be loaded,</span>
00136   <span class="comment">// and the present run will be the exact conitnuation of the saved run</span>
00137   <span class="comment">// eventually with different parameters</span>
00138   inState.<a class="code" href="classeo_state.html#a2">registerObject</a>(rng);
00139   inState.<a class="code" href="classeo_state.html#a2">registerObject</a>(pop);
00140 
00141   <span class="keywordflow">if</span> (loadName != <span class="stringliteral">""</span>)
00142     {
00143       inState.<a class="code" href="classeo_state.html#a5">load</a>(loadName); <span class="comment">//  load the pop and the rng</span>
00144       <span class="comment">// the fitness is read in the file:</span>
00145       <span class="comment">// do only evaluate the pop if the fitness has changed</span>
00146     }
00147   <span class="keywordflow">else</span>
00148     {
00149       rng.<a class="code" href="classeo_rng.html#a2">reseed</a>(seed);
00150       <span class="comment">// a Indi random initializer</span>
00151       <span class="comment">// based on boolean_generator class (see utils/rnd_generator.h)</span>
00152       <a class="code" href="classeo_uniform_generator.html">eoUniformGenerator&lt;double&gt;</a> uGen(-1.0, 1.0);
00153       <a class="code" href="classeo_init_fixed_length.html">eoInitFixedLength&lt;Indi&gt;</a> random(vecSize, uGen);
00154 
00155       <span class="comment">// Init pop from the randomizer: need to use the append function</span>
00156       pop.<a class="code" href="classeo_pop.html#a2">append</a>(popSize, random);
00157       <span class="comment">// and evaluate pop (STL syntax)</span>
00158       apply&lt;Indi&gt;(eval, pop);
00159     } <span class="comment">// end of initializatio of the population</span>
00160 
00161 <span class="comment">// OUTPUT</span>
00162   <span class="comment">// sort pop before printing it!</span>
00163   pop.<a class="code" href="classeo_pop.html#a5">sort</a>();
00164   <span class="comment">// Print (sorted) intial population (raw printout)</span>
00165   cout &lt;&lt; <span class="stringliteral">"Initial Population"</span> &lt;&lt; endl;
00166   cout &lt;&lt; pop;
00167 
00168 <span class="comment">// ENGINE</span>
00170 <span class="comment"></span>  <span class="comment">// selection and replacement</span>
00172 <span class="comment"></span><span class="comment">// SELECT</span>
00173   <span class="comment">// The robust tournament selection</span>
00174   <a class="code" href="classeo_det_tournament_select.html">eoDetTournamentSelect&lt;Indi&gt;</a> selectOne(tSize);
00175   <span class="comment">// is now encapsulated in a eoSelectPerc (entage)</span>
00176   <a class="code" href="classeo_select_perc.html">eoSelectPerc&lt;Indi&gt;</a> select(selectOne);<span class="comment">// by default rate==1</span>
00177 
00178 <span class="comment">// REPLACE</span>
00179   <span class="comment">// And we now have the full slection/replacement - though with</span>
00180   <span class="comment">// no replacement (== generational replacement) at the moment :-)</span>
00181   <a class="code" href="classeo_generational_replacement.html">eoGenerationalReplacement&lt;Indi&gt;</a> replace;
00182 
00183 <span class="comment">// OPERATORS</span>
00185 <span class="comment"></span>  <span class="comment">// The variation operators</span>
00187 <span class="comment"></span><span class="comment">// CROSSOVER</span>
00188   <span class="comment">// uniform chooce on segment made by the parents</span>
00189   <a class="code" href="classeo_segment_crossover.html">eoSegmentCrossover&lt;Indi&gt;</a> xoverS;
00190   <span class="comment">// uniform choice in hypercube built by the parents</span>
00191   eoHypercubeCrossover&lt;Indi&gt; xoverA;
00192   <span class="comment">// Combine them with relative weights</span>
00193   <a class="code" href="classeo_prop_combined_quad_op.html">eoPropCombinedQuadOp&lt;Indi&gt;</a> xover(xoverS, segmentRate);
00194   xover.add(xoverA, hypercubeRate, <span class="keyword">true</span>);
00195 
00196 <span class="comment">// MUTATION</span>
00197   <span class="comment">// offspring(i) uniformly chosen in [parent(i)-epsilon, parent(i)+epsilon]</span>
00198   <a class="code" href="classeo_uniform_mutation.html">eoUniformMutation&lt;Indi&gt;</a>  mutationU(EPSILON);
00199   <span class="comment">// k (=1) coordinates of parents are uniformly modified</span>
00200   <a class="code" href="classeo_det_uniform_mutation.html">eoDetUniformMutation&lt;Indi&gt;</a>  mutationD(EPSILON);
00201   <span class="comment">// all coordinates of parents are normally modified (stDev SIGMA)</span>
00202   <a class="code" href="classeo_normal_mutation.html">eoNormalMutation&lt;Indi&gt;</a>  mutationN(SIGMA);
00203   <span class="comment">// Combine them with relative weights</span>
00204   <a class="code" href="classeo_prop_combined_mon_op.html">eoPropCombinedMonOp&lt;Indi&gt;</a> mutation(mutationU, uniformMutRate);
00205   mutation.add(mutationD, detMutRate);
00206   mutation.add(mutationN, normalMutRate, <span class="keyword">true</span>);
00207 
00208   <span class="comment">// The operators are  encapsulated into an eoTRansform object</span>
00209   <a class="code" href="classeo_s_g_a_transform.html">eoSGATransform&lt;Indi&gt;</a> transform(xover, pCross, mutation, pMut);
00210 
00211 <span class="comment">// STOP</span>
00213 <span class="comment"></span>  <span class="comment">// termination condition see FirstBitEA.cpp</span>
00215 <span class="comment"></span>  <a class="code" href="classeo_gen_continue.html">eoGenContinue&lt;Indi&gt;</a> genCont(maxGen);
00216   <a class="code" href="classeo_steady_fit_continue.html">eoSteadyFitContinue&lt;Indi&gt;</a> steadyCont(minGen, steadyGen);
00217   <a class="code" href="classeo_fit_continue.html">eoFitContinue&lt;Indi&gt;</a> fitCont(0);
00218   <a class="code" href="classeo_combined_continue.html">eoCombinedContinue&lt;Indi&gt;</a> continuator(genCont);
00219   continuator.add(steadyCont);
00220   continuator.add(fitCont);
00221 
00222 
00223 <span class="comment">// CHECKPOINT</span>
00224   <span class="comment">// but now you want to make many different things every generation</span>
00225   <span class="comment">// (e.g. statistics, plots, ...).</span>
00226   <span class="comment">// the class eoCheckPoint is dedicated to just that:</span>
00227 
00228   <span class="comment">// Declare a checkpoint (from a continuator: an eoCheckPoint</span>
00229   <span class="comment">// IS AN eoContinue and will be called in the loop of all algorithms)</span>
00230   <a class="code" href="classeo_check_point.html">eoCheckPoint&lt;Indi&gt;</a> checkpoint(continuator);
00231 
00232     <span class="comment">// Create a counter parameter</span>
00233     <a class="code" href="classeo_value_param.html">eoValueParam&lt;unsigned&gt;</a> generationCounter(0, <span class="stringliteral">"Gen."</span>);
00234 
00235     <span class="comment">// Create an incrementor (sub-class of eoUpdater). Note that the</span>
00236     <span class="comment">// parameter's value is passed by reference,</span>
00237     <span class="comment">// so every time the incrementer is updated (every generation),</span>
00238     <span class="comment">// the data in generationCounter will change.</span>
00239     <a class="code" href="classeo_incrementor.html">eoIncrementor&lt;unsigned&gt;</a> increment(generationCounter.value());
00240 
00241     <span class="comment">// Add it to the checkpoint,</span>
00242     <span class="comment">// so the counter is updated (here, incremented) every generation</span>
00243     checkpoint.add(increment);
00244 
00245     <span class="comment">// now some statistics on the population:</span>
00246     <span class="comment">// Best fitness in population</span>
00247     <a class="code" href="classeo_best_fitness_stat.html">eoBestFitnessStat&lt;Indi&gt;</a> bestStat;
00248     <span class="comment">// Second moment stats: average and stdev</span>
00249     <a class="code" href="classeo_second_moment_stats.html">eoSecondMomentStats&lt;Indi&gt;</a> SecondStat;
00250 
00251     <span class="comment">// Add them to the checkpoint to get them called at the appropriate time</span>
00252     checkpoint.add(bestStat);
00253     checkpoint.add(SecondStat);
00254 
00255     <span class="comment">// The Stdout monitor will print parameters to the screen ...</span>
00256     <a class="code" href="classeo_stdout_monitor.html">eoStdoutMonitor</a> monitor(<span class="keyword">false</span>);
00257 
00258     <span class="comment">// when called by the checkpoint (i.e. at every generation)</span>
00259     checkpoint.add(monitor);
00260 
00261     <span class="comment">// the monitor will output a series of parameters: add them</span>
00262     monitor.add(generationCounter);
00263     monitor.add(eval);          <span class="comment">// because now eval is an eoEvalFuncCounter!</span>
00264     monitor.add(bestStat);
00265     monitor.add(SecondStat);
00266 
00267     <span class="comment">// A file monitor: will print parameters to ... a File, yes, you got it!</span>
00268     <a class="code" href="classeo_file_monitor.html">eoFileMonitor</a> fileMonitor(<span class="stringliteral">"stats.xg"</span>, <span class="stringliteral">" "</span>);
00269 
00270     <span class="comment">// the checkpoint mechanism can handle multiple monitors</span>
00271     checkpoint.add(fileMonitor);
00272 
00273     <span class="comment">// the fileMonitor can monitor parameters, too, but you must tell it!</span>
00274     fileMonitor.add(generationCounter);
00275     fileMonitor.add(bestStat);
00276     fileMonitor.add(SecondStat);
00277 
00278     <span class="comment">// Last type of item the eoCheckpoint can handle: state savers:</span>
00279     <a class="code" href="classeo_state.html">eoState</a> outState;
00280     <span class="comment">// Register the algorithm into the state (so it has something to save!!)</span>
00281     outState.<a class="code" href="classeo_state.html#a2">registerObject</a>(parser);
00282     outState.<a class="code" href="classeo_state.html#a2">registerObject</a>(pop);
00283     outState.<a class="code" href="classeo_state.html#a2">registerObject</a>(rng);
00284 
00285     <span class="comment">// and feed the state to state savers</span>
00286     <span class="comment">// save state every 100th  generation</span>
00287     <a class="code" href="classeo_counted_state_saver.html">eoCountedStateSaver</a> stateSaver1(20, outState, <span class="stringliteral">"generation"</span>);
00288     <span class="comment">// save state every 1 seconds</span>
00289     <a class="code" href="classeo_timed_state_saver.html">eoTimedStateSaver</a>   stateSaver2(1, outState, <span class="stringliteral">"time"</span>);
00290 
00291     <span class="comment">// Don't forget to add the two savers to the checkpoint</span>
00292     checkpoint.add(stateSaver1);
00293     checkpoint.add(stateSaver2);
00294     <span class="comment">// and that's it for the (control and) output</span>
00295 
00296 <span class="comment">// GENERATION</span>
00298 <span class="comment"></span>  <span class="comment">// the algorithm</span>
00300 <span class="comment"></span>
00301   <span class="comment">// Easy EA requires</span>
00302   <span class="comment">// stopping criterion, eval, selection, transformation, replacement</span>
00303   <a class="code" href="classeo_easy_e_a.html">eoEasyEA&lt;Indi&gt;</a> gga(checkpoint, eval, select, transform, replace);
00304 
00305   <span class="comment">// Apply algo to pop - that's it!</span>
00306   gga(pop);
00307 
00308 <span class="comment">// OUTPUT</span>
00309   <span class="comment">// Print (sorted) intial population</span>
00310   pop.sort();
00311   cout &lt;&lt; <span class="stringliteral">"FINAL Population\n"</span> &lt;&lt; pop &lt;&lt; endl;
00312 <span class="comment">// GENERAL</span>
00313 }
00314 
00315 <span class="comment">// A main that catches the exceptions</span>
00316 
00317 <span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)
00318 {
00319     <span class="keywordflow">try</span>
00320     {
00321         main_function(argc, argv);
00322     }
00323     <span class="keywordflow">catch</span>(exception&amp; e)
00324     {
00325         cout &lt;&lt; <span class="stringliteral">"Exception: "</span> &lt;&lt; e.what() &lt;&lt; <span class="charliteral">'\n'</span>;
00326     }
00327 
00328     <span class="keywordflow">return</span> 1;
00329 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Thu Oct 19 05:06:42 2006 for EO by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
