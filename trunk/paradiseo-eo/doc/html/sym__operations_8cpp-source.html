<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>EO: sym_operations.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<div class="nav">
<a class="el" href="dir_000007.html">contrib</a>&nbsp;/&nbsp;<a class="el" href="dir_000008.html">mathsym</a>&nbsp;/&nbsp;<a class="el" href="dir_000022.html">fun</a></div>
<h1>sym_operations.cpp</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">/*          </span>
00002 <span class="comment"> *             Copyright (C) 2005 Maarten Keijzer</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> *          This program is free software; you can redistribute it and/or modify</span>
00005 <span class="comment"> *          it under the terms of version 2 of the GNU General Public License as </span>
00006 <span class="comment"> *          published by the Free Software Foundation. </span>
00007 <span class="comment"> *</span>
00008 <span class="comment"> *          This program is distributed in the hope that it will be useful,</span>
00009 <span class="comment"> *          but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00010 <span class="comment"> *          MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00011 <span class="comment"> *          GNU General Public License for more details.</span>
00012 <span class="comment"> *</span>
00013 <span class="comment"> *          You should have received a copy of the GNU General Public License</span>
00014 <span class="comment"> *          along with this program; if not, write to the Free Software</span>
00015 <span class="comment"> *          Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
00016 <span class="comment"> */</span>
00017 
00018 <span class="preprocessor">#include &lt;FunDef.h&gt;</span>
00019 
00020 <span class="keyword">using</span> <span class="keyword">namespace </span>std;
00021 
00022 Sym simplify_constants(Sym sym) {
00023 
00024     SymVec args = sym.args();
00025     token_t token = sym.token();
00026     
00027     <span class="keywordtype">bool</span> has_changed = <span class="keyword">false</span>;
00028     <span class="keywordtype">bool</span> all_constants = <span class="keyword">true</span>;
00029 
00030     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; args.size(); ++i) {
00031         
00032         Sym arg = simplify_constants(args[i]);
00033         
00034         <span class="keywordflow">if</span> (arg != args[i]) {
00035             has_changed = <span class="keyword">true</span>;
00036         }
00037         args[i] = arg;
00038 
00039         all_constants &amp;= is_constant(args[i].token());
00040     }
00041     
00042     <span class="keywordflow">if</span> (args.size() == 0) {
00043         
00044         <span class="keywordflow">if</span> (sym.token() == sum_token) <span class="keywordflow">return</span> SymConst(0.0);
00045         <span class="keywordflow">if</span> (sym.token() == prod_token) <span class="keywordflow">return</span> SymConst(1.0);
00046         
00047         <span class="keywordflow">return</span> sym; <span class="comment">// variable or constant</span>
00048     }
00049     
00050     <span class="keywordflow">if</span> (all_constants) {
00051         <span class="comment">// evaluate </span>
00052         
00053         vector&lt;double&gt; dummy;
00054         
00055         <span class="keywordtype">double</span> v = ::eval(sym, dummy);
00056         
00057         Sym result = SymConst(v);
00058         
00059         <span class="keywordflow">return</span> result;
00060     }
00061 
00062     <span class="keywordflow">if</span> (has_changed) {
00063         <span class="keywordflow">return</span> Sym(token, args);
00064     }
00065 
00066     <span class="keywordflow">return</span> sym;
00067     
00068 }
00069 
00070 <span class="comment">// currently only simplifies constants</span>
00071 Sym simplify(Sym sym) {
00072     
00073     <span class="keywordflow">return</span> simplify_constants(sym);
00074     
00075 }
00076 
00077 Sym derivative(token_t token, Sym x) {
00078     Sym one = Sym(prod_token);
00079     
00080     <span class="keywordflow">switch</span> (token) {
00081         <span class="keywordflow">case</span> inv_token : <span class="keywordflow">return</span> Sym(inv_token, sqr(x));
00082         
00083         <span class="keywordflow">case</span> sin_token : <span class="keywordflow">return</span> -cos(x);
00084         <span class="keywordflow">case</span> cos_token : <span class="keywordflow">return</span> sin(x);
00085         <span class="keywordflow">case</span> tan_token : <span class="keywordflow">return</span> one + sqr(tan(x));
00086                          
00087         <span class="keywordflow">case</span> asin_token : <span class="keywordflow">return</span> inv( sqrt(one - sqr(x)));
00088         <span class="keywordflow">case</span> acos_token:  <span class="keywordflow">return</span> -inv( sqrt(one - sqr(x)));
00089         <span class="keywordflow">case</span> atan_token : <span class="keywordflow">return</span> inv( sqrt(one + sqr(x)));
00090         
00091         <span class="keywordflow">case</span> cosh_token : <span class="keywordflow">return</span> -sinh(x);
00092         <span class="keywordflow">case</span> sinh_token : <span class="keywordflow">return</span> cosh(x);
00093         <span class="keywordflow">case</span> tanh_token : <span class="keywordflow">return</span> one - sqr( tanh(x) );
00094         
00095         <span class="keywordflow">case</span> asinh_token : <span class="keywordflow">return</span> inv( sqrt( one + sqr(x) ));
00096         <span class="keywordflow">case</span> acosh_token : <span class="keywordflow">return</span> inv( sqrt(x-one) * sqrt(x + one)  );
00097         <span class="keywordflow">case</span> atanh_token : <span class="keywordflow">return</span> inv(one - sqr(x));
00098                          
00099         <span class="keywordflow">case</span> exp_token : <span class="keywordflow">return</span> exp(x);
00100         <span class="keywordflow">case</span> log_token : <span class="keywordflow">return</span> inv(x);
00101 
00102         <span class="keywordflow">case</span> sqr_token : <span class="keywordflow">return</span> SymConst(2.0) * x;
00103         <span class="keywordflow">case</span> sqrt_token : <span class="keywordflow">return</span> SymConst(0.5) * inv( sqrt(x));
00104         <span class="keywordflow">default</span> :
00105             <span class="keywordflow">throw</span> differentiation_error();
00106     }
00107     
00108     <span class="keywordflow">return</span> x;
00109 }
00110 
00111 <span class="keyword">extern</span> Sym differentiate(Sym sym, token_t dx) {
00112     
00113     token_t token = sym.token();
00114     
00115     Sym zero = Sym(sum_token);
00116     Sym one  = Sym(prod_token);
00117     
00118     <span class="keywordflow">if</span> (token == dx) {
00119         <span class="keywordflow">return</span> one;
00120     }
00121     
00122     SymVec args = sym.args();
00123 
00124     <span class="keywordflow">if</span> (args.size() == 0) { <span class="comment">// df/dx with f != x</span>
00125         <span class="keywordflow">return</span> zero;
00126     }
00127     
00128     <span class="keywordflow">switch</span> (token) {
00129         
00130         <span class="keywordflow">case</span> sum_token: 
00131             {
00132                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; args.size(); ++i) {
00133                     args[i] = differentiate(args[i], dx);
00134                 }
00135 
00136                 <span class="keywordflow">if</span> (args.size() == 1) <span class="keywordflow">return</span> args[0];
00137                 <span class="keywordflow">return</span> Sym(sum_token, args);
00138             }
00139         <span class="keywordflow">case</span> min_token : 
00140             {
00141                 <span class="keywordflow">return</span> -differentiate(args[0],dx);
00142             }
00143         <span class="keywordflow">case</span> prod_token: 
00144             {
00145                 <span class="keywordflow">if</span> (args.size() == 1) <span class="keywordflow">return</span> differentiate(args[0], dx);
00146                 
00147                 <span class="keywordflow">if</span> (args.size() == 2) {
00148                     <span class="keywordflow">return</span> args[0] * differentiate(args[1], dx) + args[1] * differentiate(args[0], dx);
00149                 }
00150                 <span class="comment">// else </span>
00151                 Sym c = args.back();
00152                 args.pop_back();
00153                 Sym f = Sym(prod_token, args);
00154                 Sym df = differentiate( f, dx);
00155 
00156                 <span class="keywordflow">return</span> c * df + f * differentiate(c,dx);
00157             }
00158         <span class="keywordflow">case</span> pow_token : 
00159             {
00160                 <span class="keywordflow">return</span> pow(args[0], args[1]) * args[1] * inv(args[0]);
00161             }
00162         <span class="keywordflow">case</span> ifltz_token : 
00163             { <span class="comment">// cannot be differentiated</span>
00164                 <span class="keywordflow">throw</span> differentiation_error(); <span class="comment">// TODO define proper exception</span>
00165             }
00166             
00167         <span class="keywordflow">default</span>: <span class="comment">// unary function: apply chain rule</span>
00168             {
00169                 Sym arg = args[0];
00170                 <span class="keywordflow">return</span> derivative(token, arg) * differentiate(arg, dx);
00171             }
00172     }
00173     
00174 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Thu Oct 19 05:06:42 2006 for EO by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
